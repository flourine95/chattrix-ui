# PROJECT STRUCTURE
- lib/core/constants/api_constants.dart
- lib/core/constants/app_constants.dart
- lib/core/constants/websocket_events.dart
- lib/core/domain/enums/conversation_filter.dart
- lib/core/domain/enums/conversation_type.dart
- lib/core/domain/enums/enums.dart
- lib/core/domain/enums/gender.dart
- lib/core/domain/enums/profile_visibility.dart
- lib/core/errors/exceptions.dart
- lib/core/errors/failures.dart
- lib/core/network/api_interceptor.dart
- lib/core/network/api_response.dart
- lib/core/network/auth_interceptor.dart
- lib/core/network/dio_client.dart
- lib/core/network/models/api_response.dart
- lib/core/network/models/api_response_extensions.dart
- lib/core/network/websocket_client.dart
- lib/core/network/websocket_client_impl.dart
- lib/core/network/websocket_connection_manager.dart
- lib/core/network/websocket_message_router.dart
- lib/core/network/websocket_providers.dart
- lib/core/network/websocket_service.dart
- lib/core/repositories/base_repository.dart
- lib/core/router/app_router.dart
- lib/core/router/redirect_guards.dart
- lib/core/router/route_config.dart
- lib/core/router/route_paths.dart
- lib/core/router/router_notifiers.dart
- lib/core/router/widgets/nav_shell.dart
- lib/core/services/screen_reader_service.dart
- lib/core/services/token_cache_service.dart
- lib/core/theme/app_theme.dart
- lib/core/toast/toast_controller.dart
- lib/core/toast/toast_overlay.dart
- lib/core/toast/toast_type.dart
- lib/core/utils/app_logger.dart
- lib/core/utils/avatar_generator.dart
- lib/core/utils/retry_helper.dart
- lib/core/utils/riverpod_logger.dart
- lib/core/widgets/app_input_field.dart
- lib/core/widgets/primary_button.dart
- lib/core/widgets/user_avatar.dart
- lib/features/auth/data/datasources/auth_local_datasource_impl.dart
- lib/features/auth/data/datasources/auth_remote_datasource_impl.dart
- lib/features/auth/data/mappers/auth_tokens_mapper.dart
- lib/features/auth/data/mappers/user_mapper.dart
- lib/features/auth/data/models/auth_tokens_dto.dart
- lib/features/auth/data/models/change_password_request.dart
- lib/features/auth/data/models/forgot_password_request.dart
- lib/features/auth/data/models/reset_password_request.dart
- lib/features/auth/data/models/user_dto.dart
- lib/features/auth/data/models/verify_email_request.dart
- lib/features/auth/data/repositories/auth_repository_impl.dart
- lib/features/auth/domain/datasources/auth_local_datasource.dart
- lib/features/auth/domain/datasources/auth_remote_datasource.dart
- lib/features/auth/domain/entities/auth_tokens.dart
- lib/features/auth/domain/entities/user.dart
- lib/features/auth/domain/repositories/auth_repository.dart
- lib/features/auth/domain/usecases/change_password_usecase.dart
- lib/features/auth/domain/usecases/forgot_password_usecase.dart
- lib/features/auth/domain/usecases/get_current_user_usecase.dart
- lib/features/auth/domain/usecases/is_logged_in_usecase.dart
- lib/features/auth/domain/usecases/login_usecase.dart
- lib/features/auth/domain/usecases/logout_all_usecase.dart
- lib/features/auth/domain/usecases/logout_usecase.dart
- lib/features/auth/domain/usecases/refresh_token_usecase.dart
- lib/features/auth/domain/usecases/register_usecase.dart
- lib/features/auth/domain/usecases/resend_verification_usecase.dart
- lib/features/auth/domain/usecases/reset_password_usecase.dart
- lib/features/auth/domain/usecases/verify_email_usecase.dart
- lib/features/auth/presentation/pages/forgot_password_screen.dart
- lib/features/auth/presentation/pages/login_screen.dart
- lib/features/auth/presentation/pages/login_screen_modern.dart
- lib/features/auth/presentation/pages/otp_verification_screen.dart
- lib/features/auth/presentation/pages/register_screen.dart
- lib/features/auth/presentation/providers/auth_providers.dart
- lib/features/auth/presentation/providers/auth_repository_provider.dart
- lib/features/auth/presentation/providers/auth_state_provider.dart
- lib/features/auth/presentation/state/auth_state.dart
- lib/features/auth/presentation/widgets/social_login_button.dart
- lib/features/call/data/datasources/call_remote_datasource_impl.dart
- lib/features/call/data/datasources/call_websocket_datasource_impl.dart
- lib/features/call/data/models/call_accept_model.dart
- lib/features/call/data/models/call_connection_model.dart
- lib/features/call/data/models/call_end_model.dart
- lib/features/call/data/models/call_info_model.dart
- lib/features/call/data/models/call_invitation_model.dart
- lib/features/call/data/models/call_reject_model.dart
- lib/features/call/data/models/call_timeout_model.dart
- lib/features/call/data/models/websocket/call_accept_dto.dart
- lib/features/call/data/models/websocket/call_end_dto.dart
- lib/features/call/data/models/websocket/call_invitation_dto.dart
- lib/features/call/data/models/websocket/call_reject_dto.dart
- lib/features/call/data/models/websocket/call_timeout_dto.dart
- lib/features/call/data/repositories/call_repository_impl.dart
- lib/features/call/domain/datasources/call_remote_datasource.dart
- lib/features/call/domain/datasources/call_websocket_datasource.dart
- lib/features/call/domain/entities/call_accept.dart
- lib/features/call/domain/entities/call_connection.dart
- lib/features/call/domain/entities/call_end.dart
- lib/features/call/domain/entities/call_end_reason.dart
- lib/features/call/domain/entities/call_info.dart
- lib/features/call/domain/entities/call_invitation.dart
- lib/features/call/domain/entities/call_reject.dart
- lib/features/call/domain/entities/call_reject_reason.dart
- lib/features/call/domain/entities/call_status.dart
- lib/features/call/domain/entities/call_timeout.dart
- lib/features/call/domain/entities/call_type.dart
- lib/features/call/domain/repositories/call_repository.dart
- lib/features/call/domain/usecases/accept_call_usecase.dart
- lib/features/call/domain/usecases/end_call_usecase.dart
- lib/features/call/domain/usecases/initiate_call_usecase.dart
- lib/features/call/domain/usecases/reject_call_usecase.dart
- lib/features/call/presentation/pages/call_page.dart
- lib/features/call/presentation/pages/incoming_call_page.dart
- lib/features/call/presentation/pages/outgoing_call_page.dart
- lib/features/call/presentation/providers/call_repository_provider.dart
- lib/features/call/presentation/providers/call_service_provider.dart
- lib/features/call/presentation/providers/call_usecase_provider.dart
- lib/features/call/presentation/providers/call_websocket_provider.dart
- lib/features/call/presentation/state/call_notifier.dart
- lib/features/call/presentation/state/call_state.dart
- lib/features/call/presentation/widgets/call_control_button.dart
- lib/features/call/presentation/widgets/call_controls_panel.dart
- lib/features/call/services/agora_service.dart
- lib/features/chat/data/datasources/chat_remote_datasource_impl.dart
- lib/features/chat/data/datasources/chat_websocket_datasource_impl.dart
- lib/features/chat/data/models/conversation_model.dart
- lib/features/chat/data/models/conversation_update_dto.dart
- lib/features/chat/data/models/conversation_update_model.dart
- lib/features/chat/data/models/mentioned_user_model.dart
- lib/features/chat/data/models/message_delete_dto.dart
- lib/features/chat/data/models/message_model.dart
- lib/features/chat/data/models/message_sender_model.dart
- lib/features/chat/data/models/message_update_dto.dart
- lib/features/chat/data/models/outgoing_message_dto.dart
- lib/features/chat/data/models/participant_model.dart
- lib/features/chat/data/models/reaction_event_dto.dart
- lib/features/chat/data/models/read_receipt_model.dart
- lib/features/chat/data/models/reply_to_message_model.dart
- lib/features/chat/data/models/search_user_model.dart
- lib/features/chat/data/models/typing_indicator_model.dart
- lib/features/chat/data/models/user_status_model.dart
- lib/features/chat/data/models/user_status_update_model.dart
- lib/features/chat/data/models/websocket/message_delete_dto.dart
- lib/features/chat/data/models/websocket/message_update_dto.dart
- lib/features/chat/data/models/websocket/outgoing_message_dto.dart
- lib/features/chat/data/models/websocket/reaction_event_dto.dart
- lib/features/chat/data/repositories/chat_repository_impl.dart
- lib/features/chat/data/repositories/user_status_repository_impl.dart
- lib/features/chat/domain/datasources/chat_remote_datasource.dart
- lib/features/chat/domain/datasources/chat_websocket_datasource.dart
- lib/features/chat/domain/entities/conversation.dart
- lib/features/chat/domain/entities/conversation_update.dart
- lib/features/chat/domain/entities/mentioned_user.dart
- lib/features/chat/domain/entities/message.dart
- lib/features/chat/domain/entities/message_sender.dart
- lib/features/chat/domain/entities/participant.dart
- lib/features/chat/domain/entities/read_receipt.dart
- lib/features/chat/domain/entities/reply_to_message.dart
- lib/features/chat/domain/entities/search_user.dart
- lib/features/chat/domain/entities/typing_indicator.dart
- lib/features/chat/domain/entities/user_note_entity.dart
- lib/features/chat/domain/entities/user_status.dart
- lib/features/chat/domain/entities/user_status_update.dart
- lib/features/chat/domain/repositories/chat_repository.dart
- lib/features/chat/domain/repositories/user_status_repository.dart
- lib/features/chat/domain/usecases/create_conversation_usecase.dart
- lib/features/chat/domain/usecases/delete_message_usecase.dart
- lib/features/chat/domain/usecases/edit_message_usecase.dart
- lib/features/chat/domain/usecases/get_conversation_usecase.dart
- lib/features/chat/domain/usecases/get_conversations_usecase.dart
- lib/features/chat/domain/usecases/get_messages_usecase.dart
- lib/features/chat/domain/usecases/get_online_users_usecase.dart
- lib/features/chat/domain/usecases/get_user_status_usecase.dart
- lib/features/chat/domain/usecases/search_conversations_usecase.dart
- lib/features/chat/domain/usecases/search_users_usecase.dart
- lib/features/chat/domain/usecases/send_message_usecase.dart
- lib/features/chat/domain/usecases/toggle_reaction_usecase.dart
- lib/features/chat/presentation/pages/chat_info_page.dart
- lib/features/chat/presentation/pages/chat_list_demo_page.dart
- lib/features/chat/presentation/pages/chat_list_page.dart
- lib/features/chat/presentation/pages/chat_view_page.dart
- lib/features/chat/presentation/pages/new_chat_page.dart
- lib/features/chat/presentation/pages/new_group_chat_page.dart
- lib/features/chat/presentation/pages/search_conversations_page.dart
- lib/features/chat/presentation/providers/chat_datasource_provider.dart
- lib/features/chat/presentation/providers/chat_providers.dart
- lib/features/chat/presentation/providers/chat_repository_provider.dart
- lib/features/chat/presentation/providers/chat_state_provider.dart
- lib/features/chat/presentation/providers/chat_usecase_provider.dart
- lib/features/chat/presentation/providers/chat_websocket_provider_new.dart
- lib/features/chat/presentation/providers/search_conversations_provider.dart
- lib/features/chat/presentation/providers/typing_providers.dart
- lib/features/chat/presentation/providers/user_notes_provider.dart
- lib/features/chat/presentation/state/conversations_notifier.dart
- lib/features/chat/presentation/state/filter_notifier.dart
- lib/features/chat/presentation/state/messages_notifier.dart
- lib/features/chat/presentation/state/online_users_notifier.dart
- lib/features/chat/presentation/utils/conversation_utils.dart
- lib/features/chat/presentation/utils/format_utils.dart
- lib/features/chat/presentation/utils/typing_debouncer.dart
- lib/features/chat/presentation/widgets/attachment_picker_bottom_sheet.dart
- lib/features/chat/presentation/widgets/chat_info/chat_info_header.dart
- lib/features/chat/presentation/widgets/chat_info/media_grid_item.dart
- lib/features/chat/presentation/widgets/chat_info/media_grid_widget.dart
- lib/features/chat/presentation/widgets/chat_info/members_list_widget.dart
- lib/features/chat/presentation/widgets/chat_info/message_search_widget.dart
- lib/features/chat/presentation/widgets/chat_info/settings_section_widget.dart
- lib/features/chat/presentation/widgets/conversation_list_item.dart
- lib/features/chat/presentation/widgets/edit_message_dialog.dart
- lib/features/chat/presentation/widgets/filter_chip_widget.dart
- lib/features/chat/presentation/widgets/lazy_media_loader.dart
- lib/features/chat/presentation/widgets/mention_text_field.dart
- lib/features/chat/presentation/widgets/message_action_overlay.dart
- lib/features/chat/presentation/widgets/message_bubble.dart
- lib/features/chat/presentation/widgets/message_bubbles/audio_message_bubble.dart
- lib/features/chat/presentation/widgets/message_bubbles/document_message_bubble.dart
- lib/features/chat/presentation/widgets/message_bubbles/image_message_bubble.dart
- lib/features/chat/presentation/widgets/message_bubbles/location_message_bubble.dart
- lib/features/chat/presentation/widgets/message_bubbles/text_message_bubble.dart
- lib/features/chat/presentation/widgets/message_bubbles/video_message_bubble.dart
- lib/features/chat/presentation/widgets/message_long_press_overlay.dart
- lib/features/chat/presentation/widgets/message_reactions.dart
- lib/features/chat/presentation/widgets/note_dialog.dart
- lib/features/chat/presentation/widgets/online_user_item.dart
- lib/features/chat/presentation/widgets/reply_message_preview.dart
- lib/features/chat/presentation/widgets/typing_indicator_widget.dart
- lib/features/chat/presentation/widgets/upload_progress_overlay.dart
- lib/features/chat/presentation/widgets/voice_recorder_widget.dart
- lib/features/chat/services/cloudinary_provider.dart
- lib/features/chat/services/cloudinary_service.dart
- lib/features/chat/services/image_compression_provider.dart
- lib/features/chat/services/image_compression_service.dart
- lib/features/chat/services/media_picker_provider.dart
- lib/features/chat/services/media_picker_service.dart
- lib/features/chat/services/voice_recorder_provider.dart
- lib/features/chat/services/voice_recorder_service.dart
- lib/features/contacts/data/datasources/contact_remote_datasource_impl.dart
- lib/features/contacts/data/models/contact_model.dart
- lib/features/contacts/data/models/friend_request_cancel_dto.dart
- lib/features/contacts/data/models/friend_request_model.dart
- lib/features/contacts/data/models/friend_request_reject_dto.dart
- lib/features/contacts/data/models/websocket/friend_request_cancel_dto.dart
- lib/features/contacts/data/models/websocket/friend_request_reject_dto.dart
- lib/features/contacts/data/repositories/contact_repository_impl.dart
- lib/features/contacts/domain/datasources/contact_remote_datasource.dart
- lib/features/contacts/domain/entities/contact.dart
- lib/features/contacts/domain/entities/friend_request.dart
- lib/features/contacts/domain/repositories/contact_repository.dart
- lib/features/contacts/domain/usecases/accept_friend_request_usecase.dart
- lib/features/contacts/domain/usecases/cancel_friend_request_usecase.dart
- lib/features/contacts/domain/usecases/get_contacts_usecase.dart
- lib/features/contacts/domain/usecases/get_received_friend_requests_usecase.dart
- lib/features/contacts/domain/usecases/get_sent_friend_requests_usecase.dart
- lib/features/contacts/domain/usecases/reject_friend_request_usecase.dart
- lib/features/contacts/domain/usecases/send_friend_request_usecase.dart
- lib/features/contacts/presentation/pages/contacts_demo_page.dart
- lib/features/contacts/presentation/pages/contacts_page.dart
- lib/features/contacts/presentation/pages/friend_requests_page.dart
- lib/features/contacts/presentation/pages/send_friend_request_page.dart
- lib/features/contacts/presentation/providers/contact_providers.dart
- lib/features/notes/data/datasources/notes_remote_datasource_impl.dart
- lib/features/notes/data/models/note_delete_dto.dart
- lib/features/notes/data/models/user_note_dto.dart
- lib/features/notes/data/models/user_note_model.dart
- lib/features/notes/data/repositories/notes_repository_impl.dart
- lib/features/notes/domain/datasources/notes_remote_datasource.dart
- lib/features/notes/domain/entities/user_note.dart
- lib/features/notes/domain/repositories/notes_repository.dart
- lib/features/notes/domain/usecases/create_or_update_note_usecase.dart
- lib/features/notes/domain/usecases/delete_my_note_usecase.dart
- lib/features/notes/domain/usecases/get_contact_notes_usecase.dart
- lib/features/notes/domain/usecases/get_my_note_usecase.dart
- lib/features/notes/presentation/providers/notes_providers.dart
- lib/features/profile/data/datasources/profile_remote_datasource_impl.dart
- lib/features/profile/data/models/profile_model.dart
- lib/features/profile/data/models/update_profile_request.dart
- lib/features/profile/data/repositories/profile_repository_impl.dart
- lib/features/profile/domain/datasources/profile_remote_datasource.dart
- lib/features/profile/domain/entities/profile.dart
- lib/features/profile/domain/entities/update_profile_params.dart
- lib/features/profile/domain/repositories/profile_repository.dart
- lib/features/profile/domain/usecases/get_profile_usecase.dart
- lib/features/profile/domain/usecases/update_profile_usecase.dart
- lib/features/profile/presentation/pages/edit_profile_page.dart
- lib/features/profile/presentation/pages/profile_page.dart
- lib/features/profile/presentation/pages/settings_page.dart
- lib/features/profile/presentation/providers/profile_providers.dart
- lib/features/profile/presentation/widgets/profile_picker_widgets.dart
- lib/features/profile/presentation/widgets/profile_shared_components.dart
- lib/features/profile/presentation/widgets/profile_ui_components.dart
- lib/features/profile/presentation/widgets/single_field_editor.dart
- lib/main.dart
- lib/main_preview.dart

==================================================

================================================================
FILE: lib/core/constants/api_constants.dart
================================================================
import 'package:flutter/foundation.dart' show kDebugMode, kIsWeb, defaultTargetPlatform, TargetPlatform;
import 'package:flutter_dotenv/flutter_dotenv.dart';

class ApiConstants {
  static String get _host => dotenv.env['API_HOST'] ?? 'localhost';

  static String get _port => dotenv.env['API_PORT'] ?? '8080';

  static String get _apiPath => dotenv.env['API_PATH'] ?? '/api';

  static String get _wsPath => dotenv.env['WS_PATH'] ?? '';

  static const String _androidEmulatorHost = '10.0.2.2';

  static String get _effectiveHost {
    if (kIsWeb) {
      return _host;
    }

    if (defaultTargetPlatform == TargetPlatform.android) {
      return _androidEmulatorHost;
    }

    return _host;
  }
  static bool get _useSecureProtocol {
    final useSecure = dotenv.env['USE_SECURE_PROTOCOL'];
    if (useSecure != null) {
      return useSecure.toLowerCase() == 'true';
    }

    if (!kDebugMode) {
      return true;
    }

    final host = _effectiveHost;
    final isLocalhost = host == 'localhost' || host == '127.0.0.1' || host == '10.0.2.2' || host == '0.0.0.0';

    return !isLocalhost;
  }

  static String get _baseUrl {
    final host = _effectiveHost;
    final protocol = _useSecureProtocol ? 'https' : 'http';
    final url = '$protocol://$host:$_port$_apiPath';

    return url;
  }

  static String get _wsBaseUrl {
    final host = _effectiveHost;
    final protocol = _useSecureProtocol ? 'wss' : 'ws';
    final url = '$protocol://$host:$_port$_wsPath';

    return url;
  }

  static const String _v1 = 'v1';
  static String get register => '$_baseUrl/$_v1/auth/register';

  static String get verifyEmail => '$_baseUrl/$_v1/auth/verify-email';

  static String get resendVerification => '$_baseUrl/$_v1/auth/resend-verification';

  static String get login => '$_baseUrl/$_v1/auth/login';

  static String get me => '$_baseUrl/$_v1/auth/me';

  static String get refresh => '$_baseUrl/$_v1/auth/refresh';

  static String get changePassword => '$_baseUrl/$_v1/auth/change-password';

  static String get forgotPassword => '$_baseUrl/$_v1/auth/forgot-password';

  static String get resetPassword => '$_baseUrl/$_v1/auth/reset-password';

  static String get logout => '$_baseUrl/$_v1/auth/logout';

  static String get logoutAll => '$_baseUrl/$_v1/auth/logout-all';
  static String get getProfile => '$_baseUrl/$_v1/profile/me';

  static String get updateProfile => '$_baseUrl/$_v1/profile/me';

  static String profileByUserId(int userId) => '$_baseUrl/$_v1/profile/$userId';

  static String profileByUsername(String username) => '$_baseUrl/$_v1/profile/username/$username';
  static String get conversations => '$_baseUrl/$_v1/conversations';

  static String conversationById(String id) => '$_baseUrl/$_v1/conversations/$id';

  static String messagesInConversation(String conversationId) =>
      '$_baseUrl/$_v1/conversations/$conversationId/messages';
  static String get searchUsers => '$_baseUrl/$_v1/users/search';

  static String get onlineUsers => '$_baseUrl/$_v1/users/status/online';

  static String onlineUsersInConversation(String conversationId) =>
      '$_baseUrl/$_v1/users/status/online/conversation/$conversationId';

  static String userStatus(String userId) => '$_baseUrl/$_v1/users/status/$userId';
  static String messageReactions(String messageId) => '$_baseUrl/$_v1/messages/$messageId/reactions';

  static String deleteReaction(String messageId, String emoji) => '$_baseUrl/$_v1/messages/$messageId/reactions/$emoji';

  static String messageEdit(String messageId) => '$_baseUrl/$_v1/messages/$messageId/edit';

  static String messageDelete(String messageId) => '$_baseUrl/$_v1/messages/$messageId';

  static String messageEditHistory(String messageId) => '$_baseUrl/$_v1/messages/$messageId/edit-history';

  static String messageRead(String messageId) => '$_baseUrl/$_v1/messages/$messageId/read';
  static String get typingStart => '$_baseUrl/$_v1/typing/start';

  static String get typingStop => '$_baseUrl/$_v1/typing/stop';

  static String typingStatus(String conversationId) => '$_baseUrl/$_v1/typing/status/$conversationId';
  static String get sendFriendRequest => '$_baseUrl/$_v1/friend-requests';

  static String get receivedFriendRequests => '$_baseUrl/$_v1/friend-requests/received';

  static String get sentFriendRequests => '$_baseUrl/$_v1/friend-requests/sent';

  static String acceptFriendRequest(int requestId) => '$_baseUrl/$_v1/friend-requests/$requestId/accept';

  static String rejectFriendRequest(int requestId) => '$_baseUrl/$_v1/friend-requests/$requestId/reject';

  static String cancelFriendRequest(int requestId) => '$_baseUrl/$_v1/friend-requests/$requestId';
  static String get contacts => '$_baseUrl/$_v1/contacts';

  static String contactById(int contactId) => '$_baseUrl/$_v1/contacts/$contactId';

  static String updateContactNickname(int contactId) => '$_baseUrl/$_v1/contacts/$contactId/nickname';

  static String deleteContact(int contactId) => '$_baseUrl/$_v1/contacts/$contactId';

  static String get favoriteContacts => '$_baseUrl/$_v1/contacts/favorites';

  static String toggleContactFavorite(int contactId) => '$_baseUrl/$_v1/contacts/$contactId/favorite';
  static String get notes => '$_baseUrl/$_v1/notes';

  static String get myNotes => '$_baseUrl/$_v1/notes/me';

  static String notesByUserId(int userId) => '$_baseUrl/$_v1/notes/$userId';

  static String noteReplies(int noteId) => '$_baseUrl/$_v1/notes/$noteId/replies';

  static String noteReact(int noteId) => '$_baseUrl/$_v1/notes/$noteId/react';
  static String get initiateCall => '$_baseUrl/$_v1/calls/initiate';

  static String acceptCall(String callId) => '$_baseUrl/$_v1/calls/$callId/accept';

  static String rejectCall(String callId) => '$_baseUrl/$_v1/calls/$callId/reject';

  static String endCall(String callId) => '$_baseUrl/$_v1/calls/$callId/end';

  static String get chatWebSocket => '$_wsBaseUrl/ws/chat';

  static String chatWebSocketWithToken(String token) => '$chatWebSocket?token=$token';
}

================================================================
FILE: lib/core/constants/app_constants.dart
================================================================
class AppConstants {
  static const Duration connectTimeout = Duration(seconds: 30);

  static const Duration receiveTimeout = Duration(seconds: 30);

  static const Duration reconnectDelay = Duration(seconds: 3);

  static const Duration heartbeatInterval = Duration(seconds: 30);

  static const int maxReconnectAttempts = 5;

  static const String contentTypeJson = 'application/json';
  static const String authorization = 'Authorization';
  static const String bearer = 'Bearer';

  static const String accessTokenKey = 'access_token';
  static const String refreshTokenKey = 'refresh_token';
}

================================================================
FILE: lib/core/constants/websocket_events.dart
================================================================
class WebSocketEvents {
  static const String chatMessage = 'chat.message';
  static const String messageUpdated = 'message.updated';
  static const String messageDeleted = 'message.deleted';
  static const String messageReaction = 'message.reaction';
  static const String conversationUpdate = 'conversation.update';
  static const String typingIndicator = 'typing.indicator';
  static const String userStatus = 'user.status';
  static const String friendRequestReceived = 'friend.request.received';
  static const String friendRequestAccepted = 'friend.request.accepted';
  static const String friendRequestRejected = 'friend.request.rejected';
  static const String friendRequestCancelled = 'friend.request.cancelled';
  static const String noteCreated = 'note.created';
  static const String noteUpdated = 'note.updated';
  static const String noteDeleted = 'note.deleted';
  static const String callIncoming = 'call.incoming';
  static const String callAccepted = 'call.accepted';
  static const String callRejected = 'call.rejected';
  static const String callEnded = 'call.ended';
  static const String callTimeout = 'call.timeout';
}

================================================================
FILE: lib/core/domain/enums/conversation_filter.dart
================================================================
enum ConversationFilter {
  all,
  unread,
  groups,
}

================================================================
FILE: lib/core/domain/enums/conversation_type.dart
================================================================
enum ConversationType {
  direct,
  group,
}

================================================================
FILE: lib/core/domain/enums/enums.dart
================================================================
export 'conversation_filter.dart';
export 'conversation_type.dart';
export 'gender.dart';
export 'profile_visibility.dart';

================================================================
FILE: lib/core/domain/enums/gender.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

enum Gender {
  @JsonValue('MALE')
  male,
  @JsonValue('FEMALE')
  female,
  @JsonValue('OTHER')
  other;

  String get label {
    switch (this) {
      case Gender.male:
        return 'Male';
      case Gender.female:
        return 'Female';
      case Gender.other:
        return 'Other';
    }
  }
}

================================================================
FILE: lib/core/domain/enums/profile_visibility.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

enum ProfileVisibility {
  @JsonValue('PUBLIC')
  public,
  @JsonValue('FRIENDS_ONLY')
  friendsOnly,
  @JsonValue('PRIVATE')
  private;

  String get label {
    switch (this) {
      case ProfileVisibility.public:
        return 'Public';
      case ProfileVisibility.friendsOnly:
        return 'Friends Only';
      case ProfileVisibility.private:
        return 'Private';
    }
  }
}

================================================================
FILE: lib/core/errors/exceptions.dart
================================================================
class ApiException implements Exception {
  final String message;
  final String code;
  final int statusCode;
  final Map<String, String>? details;
  final String? requestId;

  ApiException({required this.message, required this.code, required this.statusCode, this.details, this.requestId});

  @override
  String toString() => 'ApiException($code): $message${requestId != null ? ' [RequestID: $requestId]' : ''}';
}
class ServerException implements Exception {
  final String message;
  final String? errorCode;
  final int? statusCode;

  ServerException({required this.message, this.errorCode, this.statusCode});

  @override
  String toString() => 'ServerException: $message (Code: $errorCode)';
}
class NetworkException implements Exception {
  final String message;

  NetworkException({this.message = 'No internet connection'});

  @override
  String toString() => 'NetworkException: $message';
}

================================================================
FILE: lib/core/errors/failures.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'failures.freezed.dart';
@freezed
abstract class Failure with _$Failure {
  const factory Failure.server({required String message, required String code, String? requestId}) = ServerFailure;
  const factory Failure.network({required String message, required String code}) = NetworkFailure;
  const factory Failure.validation({
    required String message,
    required String code,
    Map<String, String>? details,
    String? requestId,
  }) = ValidationFailure;
  const factory Failure.auth({required String message, required String code, String? requestId}) = AuthFailure;
  const factory Failure.notFound({required String message, required String code, String? requestId}) = NotFoundFailure;
  const factory Failure.conflict({required String message, required String code, String? requestId}) = ConflictFailure;
  const factory Failure.rateLimit({required String message, required String code, String? requestId}) =
      RateLimitFailure;
}
extension FailureMessage on Failure {
  String get userMessage {
    return when(
      server: (message, code, requestId) => 'Server error. Please try again later.',
      network: (message, code) => 'Network error. Please check your internet connection.',
      validation: (message, code, details, requestId) => message,
      auth: (message, code, requestId) => 'Authentication failed. Please login again.',
      notFound: (message, code, requestId) => 'Resource not found. Please try again.',
      conflict: (message, code, requestId) => 'A conflict occurred. Please refresh and try again.',
      rateLimit: (message, code, requestId) => 'Too many requests. Please wait a moment and try again.',
    );
  }
}

================================================================
FILE: lib/core/network/api_interceptor.dart
================================================================
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import '../errors/exceptions.dart';
class ApiInterceptor extends Interceptor {
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    if (err.response != null && err.response!.data != null) {
      final data = err.response!.data;

      if (data is Map<String, dynamic>) {
        final message = data['message'] as String? ?? 'Unknown error';
        final code = data['code'] as String? ?? 'UNKNOWN_ERROR';
        final requestId = data['requestId'] as String?;
        Map<String, String>? details;
        if (data['details'] != null && data['details'] is Map) {
          details = (data['details'] as Map).map((key, value) => MapEntry(key.toString(), value.toString()));
        }

        debugPrint('API Error: $code - $message${requestId != null ? ' [RequestID: $requestId]' : ''}');
        if (details != null) {
          debugPrint('Details: $details');
        }

        throw ApiException(
          message: message,
          code: code,
          statusCode: err.response!.statusCode ?? 500,
          details: details,
          requestId: requestId,
        );
      }
    }
    super.onError(err, handler);
  }
}

================================================================
FILE: lib/core/network/api_response.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'api_response.freezed.dart';
part 'api_response.g.dart';
@Freezed(genericArgumentFactories: true)
abstract class ApiResponse<T> with _$ApiResponse<T> {
  const factory ApiResponse({required bool success, required String message, T? data}) = _ApiResponse<T>;

  factory ApiResponse.fromJson(Map<String, dynamic> json, T Function(Object?) fromJsonT) =>
      _$ApiResponseFromJson(json, fromJsonT);
}

================================================================
FILE: lib/core/network/auth_interceptor.dart
================================================================
import 'package:chattrix_ui/core/constants/api_constants.dart';
import 'package:chattrix_ui/core/constants/app_constants.dart';
import 'package:chattrix_ui/core/services/token_cache_service.dart';
import 'package:chattrix_ui/core/utils/app_logger.dart';
import 'package:dio/dio.dart';

class AuthInterceptor extends QueuedInterceptor {
  final Dio dio;
  final TokenCacheService tokenCacheService;

  late final Dio _refreshDio;
  bool _isRefreshing = false;

  AuthInterceptor({required this.dio, required this.tokenCacheService}) {
    _refreshDio = Dio(
      BaseOptions(
        contentType: AppConstants.contentTypeJson,
        validateStatus: (status) => true,
      ),
    );
  }

  @override
  Future<void> onRequest(RequestOptions options, RequestInterceptorHandler handler) async {
    final accessToken = await tokenCacheService.getAccessToken();

    if (accessToken != null) {
      options.headers[AppConstants.authorization] = '${AppConstants.bearer} $accessToken';
    }

    handler.next(options);
  }

  @override
  Future<void> onError(DioException err, ErrorInterceptorHandler handler) async {
    if (err.response?.statusCode == 401) {
      final isRefreshEndpoint = err.requestOptions.path.contains('/auth/refresh');
      final isLoginEndpoint = err.requestOptions.path.contains('/auth/login');
      final isRegisterEndpoint = err.requestOptions.path.contains('/auth/register');
      final isVerifyEndpoint = err.requestOptions.path.contains('/auth/verify-email');
      final isResendEndpoint = err.requestOptions.path.contains('/auth/resend-verification');
      final isForgotPasswordEndpoint = err.requestOptions.path.contains('/auth/forgot-password');
      final isResetPasswordEndpoint = err.requestOptions.path.contains('/auth/reset-password');
      if (isRefreshEndpoint ||
          isLoginEndpoint ||
          isRegisterEndpoint ||
          isVerifyEndpoint ||
          isResendEndpoint ||
          isForgotPasswordEndpoint ||
          isResetPasswordEndpoint) {
        return handler.next(err);
      }
      if (_isRefreshing) {
        AppLogger.debug('üîê Token refresh already in progress, waiting...', tag: 'AuthInterceptor');
        await Future.delayed(const Duration(milliseconds: 500));
        final currentToken = await tokenCacheService.getAccessToken();
        if (currentToken != null &&
            currentToken !=
                err.requestOptions.headers[AppConstants.authorization]?.toString().replaceFirst(
                  '${AppConstants.bearer} ',
                  '',
                )) {
          AppLogger.debug('üîê Token was refreshed, retrying request', tag: 'AuthInterceptor');
          err.requestOptions.headers[AppConstants.authorization] = '${AppConstants.bearer} $currentToken';
          try {
            final response = await dio.fetch(err.requestOptions);
            return handler.resolve(response);
          } catch (e) {
            return handler.next(err);
          }
        }
        return handler.next(err);
      }

      try {
        _isRefreshing = true;
        AppLogger.debug('üîê Attempting to refresh access token...', tag: 'AuthInterceptor');
        final newAccessToken = await _refreshAccessToken();

        if (newAccessToken != null) {
          AppLogger.debug('üîê Token refresh successful, retrying original request', tag: 'AuthInterceptor');
          err.requestOptions.headers[AppConstants.authorization] = '${AppConstants.bearer} $newAccessToken';
          try {
            final response = await dio.fetch(err.requestOptions);
            return handler.resolve(response);
          } catch (retryError) {
            AppLogger.error('üîê Retry failed after token refresh', tag: 'AuthInterceptor');
            await _clearTokens();
            return handler.next(err);
          }
        } else {
          AppLogger.warning('üîê Token refresh failed, user needs to re-login', tag: 'AuthInterceptor');
          return handler.next(err);
        }
      } catch (refreshError) {
        AppLogger.error('üîê Token refresh exception: $refreshError', tag: 'AuthInterceptor');
        await _clearTokens();
        return handler.next(err);
      } finally {
        _isRefreshing = false;
      }
    }

    handler.next(err);
  }

  Future<String?> _refreshAccessToken() async {
    try {
      final refreshToken = await tokenCacheService.getRefreshToken();

      if (refreshToken == null) {
        await _clearTokens();
        return null;
      }
      final response = await _refreshDio.post(ApiConstants.refresh, data: {'refreshToken': refreshToken});

      if (response.statusCode == 200) {
        try {
          final data = response.data['data'];
          final newAccessToken = data['accessToken'] as String;
          final newRefreshToken = data['refreshToken'] as String;
          await tokenCacheService.setTokens(newAccessToken, newRefreshToken);

          return newAccessToken;
        } catch (parseError) {
          await _clearTokens();
          return null;
        }
      } else {
        await _clearTokens();
        return null;
      }
    } catch (e) {
      await _clearTokens();
      return null;
    }
  }

  Future<void> _clearTokens() async {
    await tokenCacheService.clearTokens();
  }
}

================================================================
FILE: lib/core/network/dio_client.dart
================================================================
import 'package:chattrix_ui/core/constants/app_constants.dart';
import 'package:dio/dio.dart';

class DioClient {
  static Dio createDio({String? baseUrl}) {
    final dio = Dio(
      BaseOptions(
        connectTimeout: AppConstants.connectTimeout,
        receiveTimeout: AppConstants.receiveTimeout,
        contentType: AppConstants.contentTypeJson,
        validateStatus: (status) => status != null && status >= 200 && status < 300,
      ),
    );
    return dio;
  }
}

================================================================
FILE: lib/core/network/models/api_response.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'api_response.freezed.dart';
part 'api_response.g.dart';

@Freezed(genericArgumentFactories: true)
abstract class ApiResponse<T> with _$ApiResponse<T> {
  const factory ApiResponse({
    required bool success,
    String? message,
    T? data,
    String? code, // Error code: VALIDATION_ERROR, UNAUTHORIZED, etc.
    Map<String, dynamic>? details, // Field-level validation errors
    String? requestId, // Request tracking ID
  }) = _ApiResponse<T>;

  factory ApiResponse.fromJson(
    Map<String, dynamic> json,
    T Function(Object?) fromJsonT,
  ) =>
      _$ApiResponseFromJson(json, fromJsonT);
}
extension ApiResponseX<T> on ApiResponse<T> {
  bool get isSuccess => success && data != null;
  bool get isError => !success || code != null;
  String? get errorMessage => message;
  String? get errorCode => code;
  Map<String, String>? get validationErrors {
    if (details == null) return null;
    return details!.map((key, value) => MapEntry(key, value.toString()));
  }
}

================================================================
FILE: lib/core/network/models/api_response_extensions.dart
================================================================
import 'package:chattrix_ui/core/errors/exceptions.dart';
import 'package:chattrix_ui/core/network/models/api_response.dart';

extension ApiResponseUtils<T> on ApiResponse<T> {
  T getDataOrThrow() {
    if (success) {
      if (data != null) {
        return data!;
      }

      return data as T;
    }

    throw ServerException(message: message ?? 'Unknown error occurred', errorCode: code);
  }
}

================================================================
FILE: lib/core/network/websocket_client.dart
================================================================
abstract class WebSocketClient {
  Future<void> connect(String url);

  Future<void> disconnect();

  void send(String message);

  Stream<String> get messageStream;

  Stream<bool> get connectionStream;

  bool get isConnected;

  void dispose();
}

================================================================
FILE: lib/core/network/websocket_client_impl.dart
================================================================
import 'dart:async';

import 'package:chattrix_ui/core/network/websocket_client.dart';
import 'package:chattrix_ui/core/utils/app_logger.dart';
import 'package:web_socket_channel/web_socket_channel.dart';

class WebSocketClientImpl implements WebSocketClient {
  WebSocketChannel? _channel;

  final _messageController = StreamController<String>.broadcast();
  final _connectionController = StreamController<bool>.broadcast();

  @override
  Stream<String> get messageStream => _messageController.stream;

  @override
  Stream<bool> get connectionStream => _connectionController.stream;

  @override
  bool get isConnected => _channel != null;

  @override
  Future<void> connect(String url) async {
    if (_channel != null) {
      AppLogger.websocket('Client already connected');
      return;
    }

    try {
      AppLogger.websocket('Connecting to: $url');
      _channel = WebSocketChannel.connect(Uri.parse(url));

      _connectionController.add(true);
      AppLogger.websocket('Connection established');

      _channel!.stream.listen(
        (message) {
          if (message is String) {
            _messageController.add(message);
          }
        },
        onError: (error, stackTrace) {
          AppLogger.websocket('Stream error: $error', isError: true);
          _handleDisconnect();
        },
        onDone: () {
          AppLogger.websocket('Stream closed by server');
          _handleDisconnect();
        },
        cancelOnError: false,
      );
    } catch (e, stackTrace) {
      AppLogger.error('Connection failed', error: e, stackTrace: stackTrace, tag: 'WebSocket');
      _connectionController.add(false);
      _channel = null;
      rethrow;
    }
  }

  @override
  Future<void> disconnect() async {
    if (_channel != null) {
      AppLogger.websocket('Closing connection...');
      await _channel!.sink.close();
      _channel = null;
      _connectionController.add(false);
    }
  }

  @override
  void send(String message) {
    if (_channel == null) {
      AppLogger.websocket('Cannot send message: Not connected', isError: true);
      return;
    }
    _channel!.sink.add(message);
  }

  void _handleDisconnect() {
    if (_channel != null) {
      _connectionController.add(false);
      _channel = null;
      AppLogger.websocket('Disconnected handled');
    }
  }

  @override
  void dispose() {
    disconnect();
    _messageController.close();
    _connectionController.close();
  }
}

================================================================
FILE: lib/core/network/websocket_connection_manager.dart
================================================================
import 'dart:async';

import 'package:chattrix_ui/core/network/websocket_client.dart';
import 'package:chattrix_ui/core/utils/app_logger.dart';

class WebSocketConnectionManager {
  final WebSocketClient _client;
  final Duration reconnectDelay;
  final Duration heartbeatInterval;

  Timer? _heartbeatTimer;
  Timer? _reconnectTimer;
  StreamSubscription? _connectionSubscription;
  bool _isManualDisconnect = false;
  String? _lastUrl;

  WebSocketConnectionManager({
    required WebSocketClient client,
    this.reconnectDelay = const Duration(seconds: 5),
    this.heartbeatInterval = const Duration(seconds: 30),
  }) : _client = client {
    _connectionSubscription = _client.connectionStream.listen((isConnected) {
      if (!isConnected && !_isManualDisconnect && _lastUrl != null) {
        AppLogger.websocket('Connection lost. Stopping heartbeat and scheduling reconnect.');
        _stopHeartbeat();
        _scheduleReconnect();
      }
    });
  }

  Future<void> connect(String url) async {
    _isManualDisconnect = false;
    _lastUrl = url;

    try {
      await _client.connect(url);
      _startHeartbeat();
    } catch (e) {
      AppLogger.websocket('Connect exception caught in manager. Scheduling reconnect.', isError: true);
      _scheduleReconnect();
    }
  }

  Future<void> disconnect() async {
    AppLogger.websocket('Manual disconnect requested');
    _isManualDisconnect = true;
    _stopHeartbeat();
    _reconnectTimer?.cancel();
    _lastUrl = null;
    await _client.disconnect();
  }

  void _scheduleReconnect() {
    _reconnectTimer?.cancel();

    if (_isManualDisconnect || _lastUrl == null) return;

    AppLogger.websocket('Scheduling reconnect in ${reconnectDelay.inSeconds}s');
    _reconnectTimer = Timer(reconnectDelay, () {
      if (!_isManualDisconnect && _lastUrl != null) {
        AppLogger.websocket('Attempting to reconnect...');
        connect(_lastUrl!);
      }
    });
  }

  void _startHeartbeat() {
    _stopHeartbeat();
    AppLogger.websocket('Starting heartbeat');

    _heartbeatTimer = Timer.periodic(heartbeatInterval, (timer) {
      if (_client.isConnected) {
        AppLogger.debug('Sending heartbeat', tag: 'WebSocket');
        _client.send('{"type":"heartbeat","payload":{}}');
      }
    });
  }

  void _stopHeartbeat() {
    _heartbeatTimer?.cancel();
    _heartbeatTimer = null;
  }

  WebSocketClient get client => _client;

  void dispose() {
    _stopHeartbeat();
    _reconnectTimer?.cancel();
    _connectionSubscription?.cancel();
    disconnect();
  }
}

================================================================
FILE: lib/core/network/websocket_message_router.dart
================================================================
import 'dart:async';
import 'package:chattrix_ui/core/utils/app_logger.dart';

class WebSocketMessageRouter {
  final Map<String, StreamController<Map<String, dynamic>>> _controllers = {};
  final _rawMessageController = StreamController<Map<String, dynamic>>.broadcast();

  void registerMessageType(String messageType) {
    if (!_controllers.containsKey(messageType)) {
      AppLogger.websocket('Registering handler for type: $messageType');
      _controllers[messageType] = StreamController<Map<String, dynamic>>.broadcast();
    }
  }

  void unregisterMessageType(String messageType) {
    _controllers[messageType]?.close();
    _controllers.remove(messageType);
  }

  void routeMessage(Map<String, dynamic> message) {
    final type = message['type'] as String?;

    _rawMessageController.add(message);

    if (type == null) {
      AppLogger.websocket('Received message without type', isError: true);
      return;
    }

    final controller = _controllers[type];
    if (controller != null && !controller.isClosed) {
      controller.add(message);
    } else {
      AppLogger.debug('No handler registered for type: $type', tag: 'WebSocketRouter');
    }
  }

  Stream<Map<String, dynamic>> getStreamForType(String messageType) {
    registerMessageType(messageType);
    return _controllers[messageType]!.stream;
  }

  Stream<Map<String, dynamic>> getStreamForTypes(List<String> messageTypes) {
    final controller = StreamController<Map<String, dynamic>>.broadcast();

    for (final type in messageTypes) {
      registerMessageType(type);
      _controllers[type]!.stream.listen(
            (message) => controller.add(message),
        onError: (error) => controller.addError(error),
      );
    }

    return controller.stream;
  }

  Stream<Map<String, dynamic>> get rawMessageStream => _rawMessageController.stream;

  void dispose() {
    for (final controller in _controllers.values) {
      controller.close();
    }
    _controllers.clear();
    _rawMessageController.close();
  }
}

================================================================
FILE: lib/core/network/websocket_providers.dart
================================================================
import 'package:chattrix_ui/core/constants/app_constants.dart';
import 'package:chattrix_ui/core/network/websocket_client.dart';
import 'package:chattrix_ui/core/network/websocket_client_impl.dart';
import 'package:chattrix_ui/core/network/websocket_connection_manager.dart';
import 'package:chattrix_ui/core/network/websocket_message_router.dart';
import 'package:chattrix_ui/core/network/websocket_service.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'websocket_providers.g.dart';

@Riverpod(keepAlive: true)
WebSocketClient webSocketClient(Ref ref) {
  final client = WebSocketClientImpl();

  ref.onDispose(() => client.dispose());

  return client;
}

@Riverpod(keepAlive: true)
WebSocketMessageRouter webSocketMessageRouter(Ref ref) {
  final router = WebSocketMessageRouter();

  ref.onDispose(() => router.dispose());

  return router;
}

@Riverpod(keepAlive: true)
WebSocketConnectionManager webSocketConnectionManager(Ref ref) {
  final client = ref.watch(webSocketClientProvider);

  final manager = WebSocketConnectionManager(
    client: client,
    reconnectDelay: AppConstants.reconnectDelay,
    heartbeatInterval: AppConstants.heartbeatInterval,
  );

  ref.onDispose(() => manager.dispose());

  return manager;
}

@Riverpod(keepAlive: true)
WebSocketService webSocketService(Ref ref) {
  final connectionManager = ref.watch(webSocketConnectionManagerProvider);
  final messageRouter = ref.watch(webSocketMessageRouterProvider);

  final service = WebSocketService(connectionManager: connectionManager, messageRouter: messageRouter);

  ref.onDispose(() => service.dispose());

  return service;
}

================================================================
FILE: lib/core/network/websocket_service.dart
================================================================
import 'dart:async';
import 'dart:convert';
import 'package:chattrix_ui/core/utils/app_logger.dart';
import 'package:chattrix_ui/core/network/websocket_connection_manager.dart';
import 'package:chattrix_ui/core/network/websocket_message_router.dart';

class WebSocketService {
  final WebSocketConnectionManager _connectionManager;
  final WebSocketMessageRouter _messageRouter;
  StreamSubscription<String>? _messageSubscription;

  WebSocketService({
    required WebSocketConnectionManager connectionManager,
    required WebSocketMessageRouter messageRouter,
  })  : _connectionManager = connectionManager,
        _messageRouter = messageRouter;

  Future<void> connect(String url) async {
    AppLogger.websocket('Service initiating connection...');
    await _connectionManager.connect(url);
    _subscribeToMessages();
  }

  Future<void> disconnect() async {
    AppLogger.websocket('Service disconnecting...');
    await _messageSubscription?.cancel();
    await _connectionManager.disconnect();
  }

  void send(Map<String, dynamic> payload) {
    if (!_connectionManager.client.isConnected) {
      AppLogger.websocket('Attempted to send message while disconnected', isError: true);
      return;
    }
    final jsonString = jsonEncode(payload);
    _connectionManager.client.send(jsonString);
  }

  void _subscribeToMessages() {
    _messageSubscription?.cancel();
    _messageSubscription = _connectionManager.client.messageStream.listen(
          (messageString) {
        try {
          final data = jsonDecode(messageString) as Map<String, dynamic>;
          _messageRouter.routeMessage(data);
        } catch (e, st) {
          AppLogger.error('Failed to parse WebSocket message', error: e, stackTrace: st, tag: 'WebSocketService');
        }
      },
      onError: (error) {
        AppLogger.websocket('Service message stream error: $error', isError: true);
      },
    );
  }

  WebSocketMessageRouter get messageRouter => _messageRouter;

  Stream<bool> get connectionStream => _connectionManager.client.connectionStream;

  bool get isConnected => _connectionManager.client.isConnected;

  void dispose() {
    _messageSubscription?.cancel();
    _messageRouter.dispose();
    _connectionManager.dispose();
  }
}

================================================================
FILE: lib/core/repositories/base_repository.dart
================================================================
import 'package:dio/dio.dart';
import 'package:fpdart/fpdart.dart';
import '../errors/failures.dart';
import '../errors/exceptions.dart';
abstract class BaseRepository {
  Future<Either<Failure, T>> executeApiCall<T>(Future<T> Function() apiCall) async {
    try {
      final result = await apiCall();
      return right(result);
    } on ApiException catch (e) {
      return left(_handleApiException(e));
    } on DioException catch (e) {
      return left(_handleDioException(e));
    } catch (e) {
      return left(Failure.server(message: 'Unexpected error: $e', code: 'UNEXPECTED_ERROR'));
    }
  }
  Failure _handleApiException(ApiException e) {
    switch (e.code) {
      case 'VALIDATION_ERROR':
        return Failure.validation(message: e.message, code: e.code, details: e.details, requestId: e.requestId);
      case 'UNAUTHORIZED':
      case 'FORBIDDEN':
        return Failure.auth(message: e.message, code: e.code, requestId: e.requestId);
      case 'RESOURCE_NOT_FOUND':
        return Failure.notFound(message: e.message, code: e.code, requestId: e.requestId);
      case 'CONFLICT':
        return Failure.conflict(message: e.message, code: e.code, requestId: e.requestId);
      case 'RATE_LIMIT_EXCEEDED':
        return Failure.rateLimit(message: e.message, code: e.code, requestId: e.requestId);
      default:
        return Failure.server(message: e.message, code: e.code, requestId: e.requestId);
    }
  }
  Failure _handleDioException(DioException e) {
    if (e.type == DioExceptionType.connectionTimeout || e.type == DioExceptionType.receiveTimeout) {
      return Failure.network(message: 'Connection timeout', code: 'TIMEOUT');
    } else if (e.type == DioExceptionType.connectionError) {
      return Failure.network(message: 'No internet connection', code: 'NO_CONNECTION');
    } else {
      return Failure.server(message: e.message ?? 'Server error', code: 'SERVER_ERROR');
    }
  }
}

================================================================
FILE: lib/core/router/app_router.dart
================================================================
import 'package:chattrix_ui/core/router/redirect_guards.dart';
import 'package:chattrix_ui/core/router/route_config.dart';
import 'package:chattrix_ui/core/router/route_paths.dart';
import 'package:chattrix_ui/core/router/router_notifiers.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class AppRouter {
  static const String loginPath = RoutePaths.login;
  static const String registerPath = RoutePaths.register;
  static const String forgotPasswordPath = RoutePaths.forgotPassword;
  static const String otpVerificationPath = RoutePaths.otpVerification;
  static const String incomingCallPath = RoutePaths.incomingCall;
  static const String outgoingCallPath = RoutePaths.outgoingCall;
  static const String activeCallPath = RoutePaths.activeCall;

  static GoRouter router(WidgetRef ref) {
    return GoRouter(
      initialLocation: RoutePaths.chats, // Production chat list page
      refreshListenable: Listenable.merge([
        ref.watch(authNotifierWrapperProvider),
        ref.watch(callNotifierWrapperProvider),
      ]),
      redirect: (context, state) async {
        final authRedirect = await AuthRedirectGuard.redirect(ref, state);
        if (authRedirect != null) return authRedirect;

        final callRedirect = CallRedirectGuard.redirect(ref, state.matchedLocation);
        if (callRedirect != null) return callRedirect;

        return null;
      },
      routes: RouteConfig.allRoutes,
    );
  }
}

================================================================
FILE: lib/core/router/redirect_guards.dart
================================================================
import 'package:chattrix_ui/core/router/route_paths.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/call/presentation/state/call_notifier.dart';
import 'package:chattrix_ui/features/call/presentation/state/call_state.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class AuthRedirectGuard {
  static Future<String?> redirect(WidgetRef ref, GoRouterState state) async {
    final currentLocation = state.matchedLocation;
    final isLoggedIn = await ref.read(isLoggedInUseCaseProvider)();

    final authRoutes = {
      RoutePaths.login,
      RoutePaths.register,
      RoutePaths.forgotPassword,
      RoutePaths.otpVerification,
    };

    final isGoingToAuth = authRoutes.contains(currentLocation);

    if (!isLoggedIn && !isGoingToAuth) {
      return RoutePaths.login;
    }

    if (isLoggedIn && isGoingToAuth) {
      return RoutePaths.chats;
    }

    return null;
  }
}

class CallRedirectGuard {
  static String? redirect(WidgetRef ref, String currentLocation) {
    final callState = ref.read(callProvider);
    final callRoutes = {
      RoutePaths.incomingCall,
      RoutePaths.outgoingCall,
      RoutePaths.activeCall,
    };

    return callState.when(
      idle: () => _handleIdleState(currentLocation, callRoutes),
      initiating: (_, _) => _handleInitiatingState(currentLocation),
      ringing: (_) => _handleRingingState(currentLocation),
      connecting: (_, _, isOutgoing) =>
          _handleConnectingState(currentLocation, isOutgoing),
      connected: (_, _, isOutgoing, _, _, _, _, _, _, _) =>
          _handleConnectedState(currentLocation),
      ended: (_) => _handleEndedState(currentLocation, callRoutes),
      error: (_) => _handleErrorState(currentLocation, callRoutes),
    );
  }

  static String? _handleIdleState(String location, Set<String> callRoutes) {
    return callRoutes.contains(location) ? RoutePaths.chats : null;
  }

  static String? _handleInitiatingState(String location) {
    return location != RoutePaths.outgoingCall ? RoutePaths.outgoingCall : null;
  }

  static String? _handleRingingState(String location) {
    return location != RoutePaths.incomingCall ? RoutePaths.incomingCall : null;
  }

  static String? _handleConnectingState(String location, bool isOutgoing) {
    if (isOutgoing && location != RoutePaths.outgoingCall) {
      return RoutePaths.outgoingCall;
    } else if (!isOutgoing && location != RoutePaths.activeCall) {
      return RoutePaths.activeCall;
    }
    return null;
  }

  static String? _handleConnectedState(String location) {
    return location != RoutePaths.activeCall ? RoutePaths.activeCall : null;
  }

  static String? _handleEndedState(String location, Set<String> callRoutes) {
    return callRoutes.contains(location) ? RoutePaths.chats : null;
  }

  static String? _handleErrorState(String location, Set<String> callRoutes) {
    return callRoutes.contains(location) ? RoutePaths.chats : null;
  }
}

================================================================
FILE: lib/core/router/route_config.dart
================================================================
import 'package:chattrix_ui/core/router/route_paths.dart';
import 'package:chattrix_ui/core/router/widgets/nav_shell.dart';
import 'package:chattrix_ui/features/auth/presentation/pages/forgot_password_screen.dart';
import 'package:chattrix_ui/features/auth/presentation/pages/login_screen.dart';
import 'package:chattrix_ui/features/auth/presentation/pages/otp_verification_screen.dart';
import 'package:chattrix_ui/features/auth/presentation/pages/register_screen.dart';
import 'package:chattrix_ui/features/call/presentation/pages/call_page.dart';
import 'package:chattrix_ui/features/call/presentation/pages/incoming_call_page.dart';
import 'package:chattrix_ui/features/call/presentation/pages/outgoing_call_page.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/presentation/pages/chat_info_page.dart';
import 'package:chattrix_ui/features/chat/presentation/pages/chat_list_page.dart';
import 'package:chattrix_ui/features/chat/presentation/pages/chat_view_page.dart';
import 'package:chattrix_ui/features/chat/presentation/pages/new_chat_page.dart';
import 'package:chattrix_ui/features/chat/presentation/pages/new_group_chat_page.dart';
import 'package:chattrix_ui/features/chat/presentation/pages/search_conversations_page.dart';
import 'package:chattrix_ui/features/contacts/presentation/pages/contacts_page.dart';
import 'package:chattrix_ui/features/contacts/presentation/pages/contacts_demo_page.dart';
import 'package:chattrix_ui/features/profile/presentation/pages/edit_profile_page.dart';
import 'package:chattrix_ui/features/profile/presentation/pages/profile_page.dart';
import 'package:chattrix_ui/features/profile/presentation/pages/settings_page.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

class RouteConfig {
  static List<RouteBase> get callRoutes => [
    GoRoute(
      path: RoutePaths.incomingCall,
      name: 'incoming-call',
      builder: (context, state) => const IncomingCallPage(),
    ),
    GoRoute(
      path: RoutePaths.outgoingCall,
      name: 'outgoing-call',
      builder: (context, state) => const OutgoingCallPage(),
    ),
    GoRoute(path: RoutePaths.activeCall, name: 'call', builder: (context, state) => const CallPage()),
  ];

  static List<RouteBase> get authRoutes => [
    GoRoute(path: RoutePaths.login, name: 'login', builder: (context, state) => const LoginScreen()),
    GoRoute(path: RoutePaths.register, name: 'register', builder: (context, state) => const RegisterScreen()),
    GoRoute(
      path: RoutePaths.forgotPassword,
      name: 'forgot-password',
      builder: (context, state) => const ForgotPasswordScreen(),
    ),
    GoRoute(path: RoutePaths.otpVerification, name: 'otp', builder: (context, state) => _buildOtpScreen(state)),
  ];

  static ShellRoute get mainRoutes => ShellRoute(
    builder: (context, state, child) => NavShell(child: child),
    routes: [
      GoRoute(
        path: RoutePaths.chats,
        name: 'chats',
        pageBuilder: (context, state) => const NoTransitionPage(child: ChatListPage()),
      ),
      GoRoute(
        path: RoutePaths.contacts,
        name: 'contacts',
        pageBuilder: (context, state) => const NoTransitionPage(child: ContactsPage()),
      ),
      GoRoute(
        path: RoutePaths.profile,
        name: 'profile',
        pageBuilder: (context, state) => const NoTransitionPage(child: ProfilePage()),
      ),
      GoRoute(path: RoutePaths.chatView, name: 'chat-view', builder: (context, state) => _buildChatViewPage(state)),
      GoRoute(path: RoutePaths.newChat, name: 'new-chat', builder: (context, state) => const NewChatPage()),
      GoRoute(path: RoutePaths.newGroup, name: 'new-group', builder: (context, state) => const NewGroupChatPage()),
      GoRoute(path: RoutePaths.chatInfo, name: 'chat-info', builder: (context, state) => _buildChatInfoPage(state)),
      GoRoute(
        path: RoutePaths.searchConversations,
        name: 'search-conversations',
        builder: (context, state) => const SearchConversationsPage(),
      ),
    ],
  );

  static List<RouteBase> get profileRoutes => [
    GoRoute(path: RoutePaths.editProfile, name: 'edit-profile', builder: (context, state) => const EditProfilePage()),
    GoRoute(path: RoutePaths.settings, name: 'settings', builder: (context, state) => const SettingsPage()),
    GoRoute(
      path: RoutePaths.contactsDemo,
      name: 'contacts-demo',
      builder: (context, state) => const ContactListDemoPage(),
    ),
  ];

  static List<RouteBase> get allRoutes => [...callRoutes, ...authRoutes, ...profileRoutes, mainRoutes];

  static Widget _buildOtpScreen(GoRouterState state) {
    String? email;
    bool isPasswordReset = false;

    if (state.extra is Map) {
      final extraMap = state.extra as Map;
      email = extraMap['email'] as String?;
      isPasswordReset = extraMap['isPasswordReset'] as bool? ?? false;
    }

    return OtpVerificationScreen(email: email, isPasswordReset: isPasswordReset);
  }

  static Widget _buildChatViewPage(GoRouterState state) {
    final id = state.pathParameters['id']!;
    return ChatViewPage(chatId: id);
  }

  static Widget _buildChatInfoPage(GoRouterState state) {
    final conversation = state.extra as Conversation;
    return ChatInfoPage(conversation: conversation);
  }
}

================================================================
FILE: lib/core/router/route_paths.dart
================================================================
class RoutePaths {
  static const String login = '/login';
  static const String register = '/register';
  static const String forgotPassword = '/forgot-password';
  static const String otpVerification = '/otp';

  static const String incomingCall = '/incoming-call';
  static const String outgoingCall = '/outgoing-call';
  static const String activeCall = '/call';

  static const String chats = '/';
  static const String contacts = '/contacts';
  static const String profile = '/profile';
  static const String editProfile = '/profile/edit';
  static const String settings = '/settings';
  static const String chatView = '/chat/:id';
  static const String newChat = '/new-chat';
  static const String newGroup = '/new-group';
  static const String chatInfo = '/chat-info';
  static const String searchConversations = '/search-conversations';
  static const String contactsDemo = '/contacts-demo';
}

================================================================
FILE: lib/core/router/router_notifiers.dart
================================================================
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/call/presentation/state/call_notifier.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class AuthNotifierWrapper extends ChangeNotifier {
  AuthNotifierWrapper(this._ref) {
    _ref.listen<AuthState>(authNotifierProvider, (_, _) => notifyListeners());
  }

  final Ref _ref;
}

final authNotifierWrapperProvider = Provider<AuthNotifierWrapper>((ref) {
  return AuthNotifierWrapper(ref);
});

class CallNotifierWrapper extends ChangeNotifier {
  CallNotifierWrapper(this._ref) {
    _ref.listen(callProvider, (_, _) => notifyListeners());
  }

  final Ref _ref;
}

final callNotifierWrapperProvider = Provider<CallNotifierWrapper>((ref) {
  return CallNotifierWrapper(ref);
});

================================================================
FILE: lib/core/router/widgets/nav_shell.dart
================================================================
import 'package:chattrix_ui/core/router/route_paths.dart';
import 'package:flutter/material.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';
import 'package:go_router/go_router.dart';

class NavShell extends StatefulWidget {
  const NavShell({super.key, required this.child});

  final Widget child;

  @override
  State<NavShell> createState() => _NavShellState();
}

class _NavShellState extends State<NavShell> {
  bool _isScrolled = false;

  static const _navRoutes = [
    RoutePaths.chats,
    RoutePaths.contacts,
    RoutePaths.profile,
  ];

  static const _navigationDestinations = [
    NavigationDestination(
      icon: FaIcon(FontAwesomeIcons.solidComments),
      label: 'Chats',
    ),
    NavigationDestination(
      icon: FaIcon(FontAwesomeIcons.addressBook),
      label: 'Contacts',
    ),
    NavigationDestination(
      icon: FaIcon(FontAwesomeIcons.user),
      label: 'Profile',
    ),
  ];

  int _getCurrentIndex(String location) {
    for (int i = 0; i < _navRoutes.length; i++) {
      if (location == _navRoutes[i]) return i;
    }
    return 0;
  }

  bool _shouldShowBottomNav(String location) {
    return !location.startsWith('/chat/') &&
        location != RoutePaths.newChat &&
        location != RoutePaths.newGroup &&
        location != RoutePaths.chatInfo &&
        location != RoutePaths.editProfile &&
        location != RoutePaths.settings;
  }

  bool _onScrollNotification(ScrollNotification notification) {
    if (notification is ScrollUpdateNotification) {
      final shouldShowShadow = notification.metrics.pixels > 0;
      if (shouldShowShadow != _isScrolled) {
        setState(() {
          _isScrolled = shouldShowShadow;
        });
      }
    }
    return false;
  }

  @override
  Widget build(BuildContext context) {
    final location = GoRouterState.of(context).uri.toString();
    final currentIndex = _getCurrentIndex(location);
    final showBottomNav = _shouldShowBottomNav(location);

    return Scaffold(
      body: NotificationListener<ScrollNotification>(
        onNotification: _onScrollNotification,
        child: widget.child,
      ),
      bottomNavigationBar: showBottomNav
          ? Container(
              decoration: BoxDecoration(
                boxShadow: _isScrolled
                    ? [
                        BoxShadow(
                          color: Colors.black.withValues(alpha: 0.08),
                          blurRadius: 8,
                          offset: const Offset(0, -2),
                        ),
                      ]
                    : null,
              ),
              child: NavigationBar(
                selectedIndex: currentIndex,
                onDestinationSelected: (index) {
                  context.go(_navRoutes[index]);
                },
                destinations: _navigationDestinations,
              ),
            )
          : null,
    );
  }
}

================================================================
FILE: lib/core/services/screen_reader_service.dart
================================================================
import 'package:flutter/material.dart';
import 'package:flutter/semantics.dart' as semantics;
class ScreenReaderService {
  static void announce(BuildContext context, String message, {Assertiveness assertiveness = Assertiveness.polite}) {
    if (!context.mounted) return;

    final view = View.of(context);
    semantics.SemanticsService.sendAnnouncement(view, message, TextDirection.ltr);
  }
  static void announceNewMessage(
    BuildContext context, {
    required String senderName,
    required String conversationName,
    bool isGroup = false,
  }) {
    final message = isGroup ? 'New message from $senderName in $conversationName' : 'New message from $senderName';

    announce(context, message, assertiveness: Assertiveness.polite);
  }
  static void announceConversationUpdate(BuildContext context, {required String conversationName}) {
    announce(context, 'Conversation $conversationName updated', assertiveness: Assertiveness.polite);
  }
  static void announceFilterChange(BuildContext context, {required String filterName, required int conversationCount}) {
    final message =
        '$filterName filter selected. '
        'Showing $conversationCount ${conversationCount == 1 ? 'conversation' : 'conversations'}.';

    announce(context, message, assertiveness: Assertiveness.polite);
  }
  static void announceUserStatusChange(BuildContext context, {required String userName, required bool isOnline}) {
    final message = isOnline ? '$userName is now online' : '$userName is now offline';

    announce(context, message, assertiveness: Assertiveness.polite);
  }
  static void announceTyping(BuildContext context, {required String userName, required String conversationName}) {
    announce(context, '$userName is typing in $conversationName', assertiveness: Assertiveness.polite);
  }
}
enum Assertiveness {
  polite,
  assertive,
}

================================================================
FILE: lib/core/services/token_cache_service.dart
================================================================
import 'package:chattrix_ui/core/constants/app_constants.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class TokenCacheService {
  final FlutterSecureStorage _secureStorage;

  TokenCacheService(this._secureStorage);

  Future<String?> getAccessToken() async {
    try {
      return await _secureStorage.read(key: AppConstants.accessTokenKey);
    } catch (e) {
      debugPrint('‚ö†Ô∏è [TokenCache] Storage corrupted. Resetting... Error: $e');
      await clearTokens();
      return null;
    }
  }

  Future<String?> getRefreshToken() async {
    try {
      return await _secureStorage.read(key: AppConstants.refreshTokenKey);
    } catch (e) {
      debugPrint('‚ö†Ô∏è [TokenCache] Refresh token corrupted: $e');
      return null;
    }
  }

  Future<void> setTokens(String accessToken, String refreshToken) async {
    debugPrint('üîÑ [TokenCache] Updating tokens...');
    try {
      await Future.wait([
        _secureStorage.write(key: AppConstants.accessTokenKey, value: accessToken),
        _secureStorage.write(key: AppConstants.refreshTokenKey, value: refreshToken),
      ]);
    } catch (e) {
      debugPrint('‚ùå [TokenCache] Failed to write tokens: $e');
    }
  }

  Future<void> clearTokens() async {
    debugPrint('üßπ [TokenCache] Clearing tokens...');
    try {
      await Future.wait([
        _secureStorage.delete(key: AppConstants.accessTokenKey),
        _secureStorage.delete(key: AppConstants.refreshTokenKey),
      ]);
    } catch (e) {
      debugPrint('‚ö†Ô∏è [TokenCache] Failed to clear storage (might be already empty): $e');
    }
  }
}

================================================================
FILE: lib/core/theme/app_theme.dart
================================================================
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class AppTheme {
  static const _lightPrimaryColor = Colors.black;
  static const _lightOnPrimaryColor = Colors.white;
  static const _lightBackgroundColor = Colors.white;
  static const _lightSurfaceColor = Colors.white;
  static const _lightOnSurfaceColor = Colors.black;
  static const _lightBorderColor = Colors.grey;

  static const _darkPrimaryColor = Colors.white;
  static const _darkOnPrimaryColor = Colors.black;
  static const _darkBackgroundColor = Colors.black;
  static const _darkSurfaceColor = Colors.black;
  static const _darkOnSurfaceColor = Colors.white;
  static const _darkBorderColor = Colors.grey;

  static final ThemeData lightTheme = ThemeData(
    brightness: Brightness.light,
    primaryColor: _lightPrimaryColor,
    scaffoldBackgroundColor: _lightBackgroundColor,
    textTheme: GoogleFonts.interTextTheme().apply(bodyColor: _lightOnSurfaceColor),
    colorScheme: const ColorScheme.light(
      primary: _lightPrimaryColor,
      onPrimary: _lightOnPrimaryColor,
      surface: _lightSurfaceColor,
      onSurface: _lightOnSurfaceColor,
    ),
    inputDecorationTheme: _inputDecorationTheme(borderColor: _lightBorderColor),
    elevatedButtonTheme: _elevatedButtonTheme(
      backgroundColor: _lightPrimaryColor,
      foregroundColor: _lightOnPrimaryColor,
    ),
    outlinedButtonTheme: _outlinedButtonTheme(foregroundColor: _lightOnSurfaceColor, borderColor: _lightBorderColor),
    textButtonTheme: _textButtonTheme(primaryColor: _lightPrimaryColor),
  );

  static final ThemeData darkTheme = ThemeData(
    brightness: Brightness.dark,
    primaryColor: _darkPrimaryColor,
    scaffoldBackgroundColor: _darkBackgroundColor,
    textTheme: GoogleFonts.interTextTheme().apply(bodyColor: _darkOnSurfaceColor),
    colorScheme: const ColorScheme.dark(
      primary: _darkPrimaryColor,
      onPrimary: _darkOnPrimaryColor,
      surface: _darkSurfaceColor,
      onSurface: _darkOnSurfaceColor,
    ),
    inputDecorationTheme: _inputDecorationTheme(borderColor: _darkBorderColor),
    elevatedButtonTheme: _elevatedButtonTheme(backgroundColor: _darkPrimaryColor, foregroundColor: _darkOnPrimaryColor),
    outlinedButtonTheme: _outlinedButtonTheme(foregroundColor: _darkOnSurfaceColor, borderColor: _darkBorderColor),
    textButtonTheme: _textButtonTheme(primaryColor: _darkPrimaryColor),
  );

  static InputDecorationTheme _inputDecorationTheme({required Color borderColor}) {
    return InputDecorationTheme(
      labelStyle: TextStyle(color: borderColor),
      floatingLabelStyle: TextStyle(color: borderColor.withValues(alpha: 0.8)),
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(8.0),
        borderSide: BorderSide(color: borderColor),
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(8.0),
        borderSide: BorderSide(color: borderColor.withValues(alpha: 0.5)),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(8.0),
        borderSide: BorderSide(color: borderColor, width: 1.5),
      ),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
    );
  }

  static ElevatedButtonThemeData _elevatedButtonTheme({
    required Color backgroundColor,
    required Color foregroundColor,
  }) {
    return ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: backgroundColor,
        foregroundColor: foregroundColor,
        minimumSize: const Size(double.infinity, 50),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0)),
        elevation: 0,
        textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
      ),
    );
  }

  static OutlinedButtonThemeData _outlinedButtonTheme({required Color foregroundColor, required Color borderColor}) {
    return OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        foregroundColor: foregroundColor,
        minimumSize: const Size(double.infinity, 50),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0)),
        side: BorderSide(color: borderColor.withValues(alpha: 0.5)),
        textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
      ),
    );
  }

  static TextButtonThemeData _textButtonTheme({required Color primaryColor}) {
    return TextButtonThemeData(
      style: TextButton.styleFrom(
        foregroundColor: primaryColor,
        textStyle: const TextStyle(fontWeight: FontWeight.w600),
      ),
    );
  }
}

================================================================
FILE: lib/core/toast/toast_controller.dart
================================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:hooks_riverpod/legacy.dart';

import 'toast_type.dart';

class ToastEntry {
  ToastEntry({required this.id, required this.title, this.description, required this.type, required this.duration});

  final String id;
  final String title;
  final String? description;
  final ToastType type;
  final Duration duration;

  bool dismissed = false;
  DateTime createdAt = DateTime.now();
}

class ToastController extends ChangeNotifier {
  ToastController({this.maxVisible = 3});

  final int maxVisible;
  final List<ToastEntry> _toasts = <ToastEntry>[];
  final Map<String, Timer> _timers = <String, Timer>{};

  List<ToastEntry> get toasts => List.unmodifiable(_toasts);

  String show({required String title, String? description, ToastType type = ToastType.info, Duration? duration}) {
    final entry = ToastEntry(
      id: UniqueKey().toString(),
      title: title,
      description: description,
      type: type,
      duration: duration ?? const Duration(milliseconds: 3400),
    );

    _toasts.add(entry);

    while (_toasts.length > maxVisible) {
      final removed = _toasts.removeAt(0);
      _cancelTimer(removed.id);
    }

    _startAutoDismiss(entry);

    notifyListeners();
    return entry.id;
  }

  void dismiss(String id) {
    final idx = _toasts.indexWhere((e) => e.id == id);
    if (idx != -1) {
      _toasts[idx].dismissed = true;
      notifyListeners();
      Future.delayed(const Duration(milliseconds: 320), () {
        _removeById(id);
      });
    }
  }

  void _removeById(String id) {
    _cancelTimer(id);
    _toasts.removeWhere((e) => e.id == id);
    notifyListeners();
  }

  void _startAutoDismiss(ToastEntry e) {
    _cancelTimer(e.id);
    _timers[e.id] = Timer(e.duration, () => dismiss(e.id));
  }

  void _cancelTimer(String id) {
    _timers.remove(id)?.cancel();
  }

  @override
  void dispose() {
    for (final t in _timers.values) {
      t.cancel();
    }
    _timers.clear();
    super.dispose();
  }
}

final toastControllerProvider = ChangeNotifierProvider<ToastController>((ref) {
  return ToastController();
});
class Toasts {
  static String show(
    BuildContext context, {
    required String title,
    String? description,
    ToastType type = ToastType.info,
    Duration? duration,
  }) {
    final container = ProviderScope.containerOf(context, listen: false);
    final controller = container.read(toastControllerProvider);
    return controller.show(title: title, description: description, type: type, duration: duration);
  }

  static String success(BuildContext context, {required String title, String? description, Duration? duration}) =>
      show(context, title: title, description: description, type: ToastType.success, duration: duration);

  static String error(BuildContext context, {required String title, String? description, Duration? duration}) =>
      show(context, title: title, description: description, type: ToastType.error, duration: duration);

  static String warning(BuildContext context, {required String title, String? description, Duration? duration}) =>
      show(context, title: title, description: description, type: ToastType.warning, duration: duration);

  static String info(BuildContext context, {required String title, String? description, Duration? duration}) =>
      show(context, title: title, description: description, type: ToastType.info, duration: duration);

  static String loading(BuildContext context, {required String title, String? description, Duration? duration}) => show(
    context,
    title: title,
    description: description,
    type: ToastType.loading,
    duration: duration ?? const Duration(milliseconds: 1600),
  );
}

================================================================
FILE: lib/core/toast/toast_overlay.dart
================================================================
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import 'toast_controller.dart';
import 'toast_type.dart';

enum ToastPosition { topLeft, topCenter, topRight, bottomLeft, bottomCenter, bottomRight }

class ToastOverlay extends StatelessWidget {
  const ToastOverlay({
    super.key,
    required this.child,
    this.position = ToastPosition.bottomRight,
    this.margin = const EdgeInsets.all(12),
  });

  final Widget child;
  final ToastPosition position;
  final EdgeInsets margin;

  @override
  Widget build(BuildContext context) {
    return Stack(
      fit: StackFit.expand,
      children: [
        child,
        _ToastViewport(position: position, margin: margin),
      ],
    );
  }
}

class _ToastViewport extends ConsumerWidget {
  const _ToastViewport({required this.position, required this.margin});

  final ToastPosition position;
  final EdgeInsets margin;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final controller = ref.watch(toastControllerProvider);

    if (controller.toasts.isEmpty) return const SizedBox.shrink();

    Alignment alignmentFor(ToastPosition pos) {
      switch (pos) {
        case ToastPosition.topLeft:
          return Alignment.topLeft;
        case ToastPosition.topCenter:
          return Alignment.topCenter;
        case ToastPosition.topRight:
          return Alignment.topRight;
        case ToastPosition.bottomLeft:
          return Alignment.bottomLeft;
        case ToastPosition.bottomCenter:
          return Alignment.bottomCenter;
        case ToastPosition.bottomRight:
          return Alignment.bottomRight;
      }
    }

    EdgeInsets paddingFor(ToastPosition pos, EdgeInsets base) {
      final lr = EdgeInsets.only(left: base.left, right: base.right);
      if (pos == ToastPosition.topLeft || pos == ToastPosition.topCenter || pos == ToastPosition.topRight) {
        return lr.copyWith(top: base.top);
      } else {
        return lr.copyWith(bottom: base.bottom);
      }
    }

    return IgnorePointer(
      ignoring: false,
      child: SafeArea(
        child: Align(
          alignment: alignmentFor(position),
          child: Padding(
            padding: paddingFor(position, margin),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 420),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  for (final e in controller.toasts)
                    _ToastItem(
                      key: ValueKey(e.id),
                      entry: e,
                      onClose: () => ref.read(toastControllerProvider).dismiss(e.id),
                    ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _ToastItem extends StatefulWidget {
  const _ToastItem({super.key, required this.entry, required this.onClose});

  final ToastEntry entry;
  final VoidCallback onClose;

  @override
  State<_ToastItem> createState() => _ToastItemState();
}

class _ToastItemState extends State<_ToastItem> with SingleTickerProviderStateMixin {
  late final AnimationController _controller;
  late final Animation<Offset> _slide;
  late final Animation<double> _fade;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(vsync: this, duration: const Duration(milliseconds: 220));
    _slide = Tween<Offset>(
      begin: const Offset(0.08, -0.06),
      end: Offset.zero,
    ).animate(CurvedAnimation(parent: _controller, curve: Curves.easeOutCubic));
    _fade = CurvedAnimation(parent: _controller, curve: Curves.easeOut);
    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final brightness = theme.brightness;
    final isDark = brightness == Brightness.dark;

    final accent = toastAccentColor(widget.entry.type, brightness);

    final bg = isDark ? const Color(0xFF0B0B0B) : Colors.white;
    final onBg = isDark ? Colors.white : Colors.black;
    final border = isDark ? const Color(0x1FFFFFFF) : const Color(0x14000000);

    final iconBg = Color.alphaBlend(accent.withValues(alpha: isDark ? 0.18 : 0.10), bg);

    return AnimatedSlide(
      duration: const Duration(milliseconds: 280),
      curve: Curves.easeInOutCubic,
      offset: widget.entry.dismissed ? const Offset(0.06, -0.04) : Offset.zero,
      child: AnimatedOpacity(
        duration: const Duration(milliseconds: 280),
        curve: Curves.easeOutCubic,
        opacity: widget.entry.dismissed ? 0.0 : 1.0,
        child: FadeTransition(
          opacity: _fade,
          child: SlideTransition(
            position: _slide,
            child: Padding(
              padding: const EdgeInsets.only(bottom: 10),
              child: DecoratedBox(
                decoration: ShapeDecoration(
                  color: bg,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                    side: BorderSide(color: border),
                  ),
                  shadows: [
                    BoxShadow(
                      color: isDark ? Colors.black.withValues(alpha: 0.5) : Colors.black.withValues(alpha: 0.06),
                      blurRadius: 24,
                      spreadRadius: 0,
                      offset: const Offset(0, 10),
                    ),
                  ],
                ),
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(12),
                  child: Stack(
                    children: [
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 12),
                        child: Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Container(
                              height: 36,
                              width: 36,
                              decoration: BoxDecoration(
                                color: iconBg,
                                borderRadius: BorderRadius.circular(8),
                                border: Border.all(color: accent.withValues(alpha: 0.28)),
                              ),
                              child: Icon(toastIcon(widget.entry.type), color: accent, size: 20),
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Text(
                                    widget.entry.title,
                                    style: theme.textTheme.bodyLarge?.copyWith(
                                      fontWeight: FontWeight.w700,
                                      color: onBg,
                                    ),
                                  ),
                                  if (widget.entry.description != null) ...[
                                    const SizedBox(height: 4),
                                    Text(
                                      widget.entry.description!,
                                      style: theme.textTheme.bodyMedium?.copyWith(
                                        height: 1.25,
                                        color: onBg.withValues(alpha: 0.8),
                                      ),
                                    ),
                                  ],
                                ],
                              ),
                            ),
                            const SizedBox(width: 8),
                            Material(
                              type: MaterialType.transparency,
                              child: InkResponse(
                                onTap: widget.onClose,
                                radius: 18,
                                child: Icon(Icons.close_rounded, size: 18, color: onBg.withValues(alpha: 0.7)),
                              ),
                            ),
                          ],
                        ),
                      ),
                      Positioned(
                        left: 0,
                        right: 0,
                        bottom: 0,
                        child: _ProgressBar(
                          color: accent,
                          startedAt: widget.entry.createdAt,
                          duration: widget.entry.duration,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _ProgressBar extends StatefulWidget {
  const _ProgressBar({required this.color, required this.startedAt, required this.duration});

  final Color color;
  final DateTime startedAt;
  final Duration duration;

  @override
  State<_ProgressBar> createState() => _ProgressBarState();
}

class _ProgressBarState extends State<_ProgressBar> with SingleTickerProviderStateMixin {
  late final AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(vsync: this, duration: widget.duration)..forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    return SizedBox(
      height: 3,
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, _) {
          final value = 1.0 - _controller.value;
          return FractionallySizedBox(
            alignment: Alignment.centerLeft,
            widthFactor: value.clamp(0.0, 1.0),
            child: Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: [
                    widget.color.withValues(alpha: isDark ? 0.9 : 0.85),
                    widget.color.withValues(alpha: isDark ? 0.55 : 0.4),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

================================================================
FILE: lib/core/toast/toast_type.dart
================================================================
import 'package:flutter/material.dart';

enum ToastType { info, success, warning, error, loading }

IconData toastIcon(ToastType type) {
  switch (type) {
    case ToastType.success:
      return Icons.check_circle_rounded;
    case ToastType.warning:
      return Icons.warning_amber_rounded;
    case ToastType.error:
      return Icons.error_rounded;
    case ToastType.loading:
      return Icons.hourglass_bottom_rounded;
    case ToastType.info:
      return Icons.info_rounded;
  }
}

Color toastAccentColor(ToastType type, Brightness brightness) {
  final bool dark = brightness == Brightness.dark;
  switch (type) {
    case ToastType.success:
      return dark ? const Color(0xFF22C55E) : const Color(0xFF16A34A);
    case ToastType.warning:
      return dark ? const Color(0xFFF59E0B) : const Color(0xFFD97706);
    case ToastType.error:
      return dark ? const Color(0xFFEF4444) : const Color(0xFFDC2626);
    case ToastType.loading:
      return dark ? const Color(0xFF60A5FA) : const Color(0xFF2563EB);
    case ToastType.info:
      return dark ? const Color(0xFF38BDF8) : const Color(0xFF0284C7);
  }
}

================================================================
FILE: lib/core/utils/app_logger.dart
================================================================
import 'package:flutter/foundation.dart';
import 'package:logger/logger.dart';

class AppLogger {
  static final _logger = Logger(
    filter: _ProductionFilter(),
    printer: PrettyPrinter(
      methodCount: 0,
      errorMethodCount: 5,
      lineLength: 100,
      colors: true,
      printEmojis: true,
      dateTimeFormat: DateTimeFormat.onlyTimeAndSinceStart,
    ),
  );
  static const bool enableWebSocketDebugLogs = false;

  static const String _debugEmoji = 'üîç';
  static const String _infoEmoji = '‚ÑπÔ∏è';
  static const String _warningEmoji = '‚ö†Ô∏è';
  static const String _errorEmoji = '‚ùå';
  static const String _successEmoji = '‚úÖ';

  static void debug(String message, {String? tag}) {
    if (kDebugMode) {
      _logger.d('$_debugEmoji [${tag ?? 'App'}] $message');
    }
  }

  static void info(String message, {String? tag}) {
    _logger.i('$_infoEmoji [${tag ?? 'App'}] $message');
  }

  static void success(String message, {String? tag}) {
    _logger.i('$_successEmoji [${tag ?? 'App'}] $message');
  }

  static void warning(String message, {String? tag}) {
    _logger.w('$_warningEmoji [${tag ?? 'App'}] $message');
  }

  static void error(String message, {Object? error, StackTrace? stackTrace, String? tag}) {
    _logger.e('$_errorEmoji [${tag ?? 'App'}] $message', error: error, stackTrace: stackTrace);
  }

  static void websocket(String message, {bool isError = false}) {
    if (isError) {
      error(message, tag: 'WebSocket');
    } else if (enableWebSocketDebugLogs) {
      debug(message, tag: 'WebSocket');
    }
  }

  static void call(String message, {bool isError = false}) {
    if (isError) {
      error(message, tag: 'Call');
    } else {
      debug(message, tag: 'Call');
    }
  }

  static void chat(String message, {bool isError = false}) {
    if (isError) {
      error(message, tag: 'Chat');
    } else {
      debug(message, tag: 'Chat');
    }
  }

  static void auth(String message, {bool isError = false}) {
    if (isError) {
      error(message, tag: 'Auth');
    } else {
      debug(message, tag: 'Auth');
    }
  }

  static void media(String message, {bool isError = false}) {
    if (isError) {
      error(message, tag: 'Media');
    } else {
      debug(message, tag: 'Media');
    }
  }
}

class _ProductionFilter extends LogFilter {
  @override
  bool shouldLog(LogEvent event) {
    return kDebugMode;
  }
}

================================================================
FILE: lib/core/utils/avatar_generator.dart
================================================================
import 'dart:io';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
class AvatarGenerator {
  static final List<Color> _colorPalette = [
    const Color(0xFFEF5350), // Red
    const Color(0xFFEC407A), // Pink
    const Color(0xFFAB47BC), // Purple
    const Color(0xFF7E57C2), // Deep Purple
    const Color(0xFF5C6BC0), // Indigo
    const Color(0xFF42A5F5), // Blue
    const Color(0xFF29B6F6), // Light Blue
    const Color(0xFF26C6DA), // Cyan
    const Color(0xFF26A69A), // Teal
    const Color(0xFF66BB6A), // Green
    const Color(0xFF9CCC65), // Light Green
    const Color(0xFFD4E157), // Lime
    const Color(0xFFFFEE58), // Yellow
    const Color(0xFFFFCA28), // Amber
    const Color(0xFFFFA726), // Orange
    const Color(0xFFFF7043), // Deep Orange
    const Color(0xFF8D6E63), // Brown
    const Color(0xFFBDBDBD), // Grey
    const Color(0xFF78909C), // Blue Grey
  ];
  static Color generateColor(String seed) {
    if (seed.isEmpty) return _colorPalette[0];
    final hash = seed.hashCode.abs();
    return _colorPalette[hash % _colorPalette.length];
  }
  static String getInitials(String name) {
    if (name.isEmpty) return '?';

    final words = name.trim().split(RegExp(r'\s+'));
    if (words.length == 1) {
      return words[0].substring(0, 1).toUpperCase();
    } else {
      return (words[0].substring(0, 1) + words[1].substring(0, 1)).toUpperCase();
    }
  }
  static Future<File> generateAvatarImage({
    required String name,
    int size = 400,
    String? seed,
  }) async {
    final initials = getInitials(name);
    final backgroundColor = generateColor(seed ?? name);
    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);
    final paint = Paint()
      ..color = backgroundColor
      ..style = PaintingStyle.fill;

    canvas.drawCircle(
      Offset(size / 2, size / 2),
      size / 2,
      paint,
    );
    final textPainter = TextPainter(
      text: TextSpan(
        text: initials,
        style: TextStyle(
          color: Colors.white,
          fontSize: size * 0.4,
          fontWeight: FontWeight.w600,
          fontFamily: 'Roboto',
        ),
      ),
      textDirection: ui.TextDirection.ltr,
    );

    textPainter.layout();

    final textOffset = Offset(
      (size - textPainter.width) / 2,
      (size - textPainter.height) / 2,
    );

    textPainter.paint(canvas, textOffset);
    final picture = recorder.endRecording();
    final image = await picture.toImage(size, size);
    final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
    final buffer = byteData!.buffer.asUint8List();
    final tempDir = await getTemporaryDirectory();
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final file = File('${tempDir.path}/avatar_$timestamp.png');
    await file.writeAsBytes(buffer);

    return file;
  }
  static Future<List<int>> generateAvatarBytes({
    required String name,
    int size = 400,
    String? seed,
  }) async {
    final file = await generateAvatarImage(name: name, size: size, seed: seed);
    final bytes = await file.readAsBytes();
    await file.delete(); // Clean up temp file
    return bytes;
  }
}

================================================================
FILE: lib/core/utils/retry_helper.dart
================================================================
import 'dart:async';
import 'package:flutter/foundation.dart';
class RetryHelper {
  static Future<T> retry<T>({
    required Future<T> Function() operation,
    int maxAttempts = 3,
    Duration initialDelay = const Duration(seconds: 1),
    Duration maxDelay = const Duration(seconds: 10),
    bool Function(Object error)? shouldRetry,
  }) async {
    int attempt = 0;
    Duration delay = initialDelay;

    while (true) {
      try {
        attempt++;
        debugPrint('üîÑ Retry attempt $attempt/$maxAttempts');
        return await operation();
      } catch (error) {
        if (shouldRetry != null && !shouldRetry(error)) {
          debugPrint('‚ùå Error not retryable: $error');
          rethrow;
        }
        if (attempt >= maxAttempts) {
          debugPrint('‚ùå All retry attempts exhausted ($maxAttempts)');
          rethrow;
        }
        debugPrint('‚è≥ Waiting ${delay.inSeconds}s before retry...');
        await Future.delayed(delay);
        delay = Duration(
          milliseconds: (delay.inMilliseconds * 2).clamp(initialDelay.inMilliseconds, maxDelay.inMilliseconds),
        );
      }
    }
  }
  static bool isNetworkError(Object error) {
    final errorString = error.toString().toLowerCase();
    return errorString.contains('timeout') ||
        errorString.contains('connection') ||
        errorString.contains('network') ||
        errorString.contains('no_connection');
  }
}

================================================================
FILE: lib/core/utils/riverpod_logger.dart
================================================================
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:chattrix_ui/core/utils/app_logger.dart';

final class RiverpodLogger extends ProviderObserver {

  @override
  void didUpdateProvider(
      ProviderObserverContext context,
      Object? previousValue,
      Object? newValue,
      ) {
    final provider = context.provider;
    final providerName = provider.name ?? provider.runtimeType.toString();

    AppLogger.debug(
      'State Updated: $previousValue -> $newValue',
      tag: 'Riverpod: $providerName',
    );
  }

  @override
  void didAddProvider(
      ProviderObserverContext context,
      Object? value,
      ) {
    final provider = context.provider;
    final providerName = provider.name ?? provider.runtimeType.toString();

    AppLogger.info(
      'Initialized with value: $value',
      tag: 'Riverpod: $providerName',
    );
  }

  @override
  void didDisposeProvider(
      ProviderObserverContext context,
      ) {
    final provider = context.provider;
    final providerName = provider.name ?? provider.runtimeType.toString();

    AppLogger.warning(
      'Disposed',
      tag: 'Riverpod: $providerName',
    );
  }
}

================================================================
FILE: lib/core/widgets/app_input_field.dart
================================================================
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';

class AppInputField extends HookWidget {
  final String labelText;
  final String? hintText;
  final bool isPassword;
  final TextEditingController? controller;
  final TextInputType? keyboardType;
  final String? Function(String?)? validator;

  const AppInputField({
    super.key,
    required this.labelText,
    this.hintText,
    this.isPassword = false,
    this.controller,
    this.keyboardType,
    this.validator,
  });

  @override
  Widget build(BuildContext context) {
    final obscureText = useState(isPassword);

    return TextFormField(
      controller: controller,
      obscureText: obscureText.value,
      keyboardType: keyboardType,
      validator: validator,
      decoration: InputDecoration(
        labelText: labelText,
        hintText: hintText,
        suffixIcon: isPassword
            ? IconButton(
                icon: Icon(
                  obscureText.value ? Icons.visibility_off_outlined : Icons.visibility_outlined,
                  color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.5),
                ),
                onPressed: () {
                  obscureText.value = !obscureText.value;
                },
              )
            : null,
      ),
    );
  }
}

================================================================
FILE: lib/core/widgets/primary_button.dart
================================================================
import 'package:flutter/material.dart';

class PrimaryButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;
  final bool isLoading;

  const PrimaryButton({super.key, required this.text, required this.onPressed, this.isLoading = false});

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: isLoading ? null : onPressed,
      child: isLoading
          ? SizedBox(
              height: 20,
              width: 20,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(Theme.of(context).colorScheme.onPrimary),
              ),
            )
          : Text(text),
    );
  }
}

================================================================
FILE: lib/core/widgets/user_avatar.dart
================================================================
import 'dart:io';
import 'package:chattrix_ui/core/utils/avatar_generator.dart';
import 'package:flutter/material.dart';
class UserAvatar extends StatelessWidget {
  final String? avatarUrl;
  final String? localAvatarPath;
  final String displayName;
  final double radius;
  final Color? backgroundColor;
  final bool showBorder;
  final Color? borderColor;
  final double borderWidth;

  const UserAvatar({
    super.key,
    this.avatarUrl,
    this.localAvatarPath,
    required this.displayName,
    this.radius = 20,
    this.backgroundColor,
    this.showBorder = false,
    this.borderColor,
    this.borderWidth = 2,
  });

  @override
  Widget build(BuildContext context) {
    final initials = AvatarGenerator.getInitials(displayName);
    final bgColor = backgroundColor ?? AvatarGenerator.generateColor(displayName);

    Widget avatar = CircleAvatar(
      radius: radius,
      backgroundColor: bgColor,
      backgroundImage: _getImageProvider(),
      child: _getImageProvider() == null
          ? Text(
              initials,
              style: TextStyle(
                color: Colors.white,
                fontSize: radius * 0.6,
                fontWeight: FontWeight.w600,
              ),
            )
          : null,
    );

    if (showBorder) {
      avatar = Container(
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          border: Border.all(
            color: borderColor ?? Theme.of(context).colorScheme.primary,
            width: borderWidth,
          ),
        ),
        child: avatar,
      );
    }

    return avatar;
  }

  ImageProvider? _getImageProvider() {
    if (localAvatarPath != null && localAvatarPath!.isNotEmpty) {
      return FileImage(File(localAvatarPath!));
    }

    if (avatarUrl != null && avatarUrl!.isNotEmpty) {
      return NetworkImage(avatarUrl!);
    }

    return null;
  }
}

================================================================
FILE: lib/features/auth/data/datasources/auth_local_datasource_impl.dart
================================================================
import 'package:chattrix_ui/core/services/token_cache_service.dart';
import 'package:chattrix_ui/features/auth/domain/datasources/auth_local_datasource.dart';

class AuthLocalDataSourceImpl implements AuthLocalDataSource {
  final TokenCacheService tokenCacheService;

  AuthLocalDataSourceImpl({required this.tokenCacheService});

  @override
  Future<void> saveTokens({required String accessToken, required String refreshToken}) async {
    await tokenCacheService.setTokens(accessToken, refreshToken);
  }

  @override
  Future<String?> getAccessToken() async {
    return await tokenCacheService.getAccessToken();
  }

  @override
  Future<String?> getRefreshToken() async {
    return await tokenCacheService.getRefreshToken();
  }

  @override
  Future<void> deleteTokens() async {
    await tokenCacheService.clearTokens();
  }
}

================================================================
FILE: lib/features/auth/data/datasources/auth_remote_datasource_impl.dart
================================================================
import 'package:chattrix_ui/core/constants/api_constants.dart';
import 'package:chattrix_ui/core/network/models/api_response.dart';
import 'package:chattrix_ui/core/network/models/api_response_extensions.dart';
import 'package:chattrix_ui/features/auth/data/models/auth_tokens_dto.dart';
import 'package:chattrix_ui/features/auth/data/models/user_dto.dart';
import 'package:chattrix_ui/features/auth/domain/datasources/auth_remote_datasource.dart';
import 'package:dio/dio.dart';

class AuthRemoteDataSourceImpl implements AuthRemoteDataSource {
  final Dio dio;

  AuthRemoteDataSourceImpl({required this.dio});

  @override
  Future<void> register({
    required String username,
    required String email,
    required String password,
    required String fullName,
  }) async {
    final response = await dio.post(
      ApiConstants.register,
      data: {'username': username, 'email': email, 'password': password, 'fullName': fullName},
    );
    final apiResponse = ApiResponse<void>.fromJson(response.data, (data) => null);
    apiResponse.getDataOrThrow();
  }

  @override
  Future<void> verifyEmail({required String email, required String otp}) async {
    final response = await dio.post(ApiConstants.verifyEmail, data: {'email': email, 'otp': otp});
    final apiResponse = ApiResponse<void>.fromJson(response.data, (data) => null);
    apiResponse.getDataOrThrow();
  }

  @override
  Future<void> resendVerification({required String email}) async {
    final response = await dio.post(ApiConstants.resendVerification, data: {'email': email});
    final apiResponse = ApiResponse<void>.fromJson(response.data, (data) => null);
    apiResponse.getDataOrThrow();
  }

  @override
  Future<AuthTokensDto> login({required String usernameOrEmail, required String password}) async {
    final response = await dio.post(
      ApiConstants.login,
      data: {'usernameOrEmail': usernameOrEmail, 'password': password},
    );
    final apiResponse = ApiResponse<AuthTokensDto>.fromJson(
      response.data,
      (data) => AuthTokensDto.fromJson(data as Map<String, dynamic>),
    );
    return apiResponse.getDataOrThrow();
  }

  @override
  Future<UserDto> getCurrentUser(String accessToken) async {
    final response = await dio.get(ApiConstants.me);
    final apiResponse = ApiResponse<UserDto>.fromJson(
      response.data,
      (data) => UserDto.fromJson(data as Map<String, dynamic>),
    );
    return apiResponse.getDataOrThrow();
  }

  @override
  Future<AuthTokensDto> refreshToken(String refreshToken) async {
    final response = await dio.post(ApiConstants.refresh, data: {'refreshToken': refreshToken});
    final apiResponse = ApiResponse<AuthTokensDto>.fromJson(
      response.data,
      (data) => AuthTokensDto.fromJson(data as Map<String, dynamic>),
    );
    return apiResponse.getDataOrThrow();
  }

  @override
  Future<void> changePassword({
    required String accessToken,
    required String currentPassword,
    required String newPassword,
  }) async {
    final response = await dio.put(
      ApiConstants.changePassword,
      data: {'currentPassword': currentPassword, 'newPassword': newPassword},
    );
    final apiResponse = ApiResponse<void>.fromJson(response.data, (data) => null);
    apiResponse.getDataOrThrow();
  }

  @override
  Future<void> forgotPassword({required String email}) async {
    final response = await dio.post(ApiConstants.forgotPassword, data: {'email': email});
    final apiResponse = ApiResponse<void>.fromJson(response.data, (data) => null);
    apiResponse.getDataOrThrow();
  }

  @override
  Future<void> resetPassword({required String email, required String otp, required String newPassword}) async {
    final response = await dio.post(
      ApiConstants.resetPassword,
      data: {'email': email, 'otp': otp, 'newPassword': newPassword},
    );
    final apiResponse = ApiResponse<void>.fromJson(response.data, (data) => null);
    apiResponse.getDataOrThrow();
  }

  @override
  Future<void> logout(String accessToken) async {
    final response = await dio.post(ApiConstants.logout);
    final apiResponse = ApiResponse<void>.fromJson(response.data, (data) => null);
    apiResponse.getDataOrThrow();
  }

  @override
  Future<void> logoutAll(String accessToken) async {
    final response = await dio.post(ApiConstants.logoutAll);
    final apiResponse = ApiResponse<void>.fromJson(response.data, (data) => null);
    apiResponse.getDataOrThrow();
  }
}

================================================================
FILE: lib/features/auth/data/mappers/auth_tokens_mapper.dart
================================================================
import '../models/auth_tokens_dto.dart';
import '../../domain/entities/auth_tokens.dart';

extension AuthTokensDtoMapper on AuthTokensDto {
  AuthTokens toEntity() {
    return AuthTokens(accessToken: accessToken, refreshToken: refreshToken, tokenType: tokenType, expiresIn: expiresIn);
  }
}

extension AuthTokensEntityMapper on AuthTokens {
  AuthTokensDto toDto() {
    return AuthTokensDto(
      accessToken: accessToken,
      refreshToken: refreshToken,
      tokenType: tokenType,
      expiresIn: expiresIn,
    );
  }
}

================================================================
FILE: lib/features/auth/data/mappers/user_mapper.dart
================================================================
import '../models/user_dto.dart';
import '../../domain/entities/user.dart';
import '../../../../core/domain/enums/enums.dart';

extension UserDtoMapper on UserDto {
  User toEntity() {
    return User(
      id: id,
      username: username,
      email: email,
      emailVerified: emailVerified,
      phone: phone,
      fullName: fullName,
      avatarUrl: avatarUrl,
      bio: bio,
      gender: _parseGender(gender),
      dateOfBirth: dateOfBirth != null ? DateTime.tryParse(dateOfBirth!) : null,
      location: location,
      profileVisibility: _parseProfileVisibility(profileVisibility),
      online: online,
      lastSeen: lastSeen != null ? DateTime.tryParse(lastSeen!) : null,
      createdAt: DateTime.parse(createdAt),
      updatedAt: updatedAt != null ? DateTime.tryParse(updatedAt!) : null,
    );
  }

  Gender? _parseGender(String? value) {
    if (value == null) return null;
    switch (value.toUpperCase()) {
      case 'MALE':
        return Gender.male;
      case 'FEMALE':
        return Gender.female;
      case 'OTHER':
        return Gender.other;
      default:
        return Gender.other;
    }
  }

  ProfileVisibility? _parseProfileVisibility(String? value) {
    if (value == null) return null;
    switch (value.toUpperCase()) {
      case 'PUBLIC':
        return ProfileVisibility.public;
      case 'FRIENDS_ONLY':
        return ProfileVisibility.friendsOnly;
      case 'PRIVATE':
        return ProfileVisibility.private;
      default:
        return ProfileVisibility.public;
    }
  }
}

extension UserEntityMapper on User {
  UserDto toDto() {
    return UserDto(
      id: id,
      username: username,
      email: email,
      emailVerified: emailVerified,
      phone: phone,
      fullName: fullName,
      avatarUrl: avatarUrl,
      bio: bio,
      gender: gender?.name.toUpperCase(),
      dateOfBirth: dateOfBirth?.toIso8601String(),
      location: location,
      profileVisibility: profileVisibility?.name.toUpperCase(),
      online: online,
      lastSeen: lastSeen?.toIso8601String(),
      createdAt: createdAt.toIso8601String(),
      updatedAt: updatedAt?.toIso8601String(),
    );
  }
}

================================================================
FILE: lib/features/auth/data/models/auth_tokens_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'auth_tokens_dto.freezed.dart';
part 'auth_tokens_dto.g.dart';

@freezed
abstract class AuthTokensDto with _$AuthTokensDto {
  const factory AuthTokensDto({
    required String accessToken,
    required String refreshToken,
    required String tokenType,
    required int expiresIn,
  }) = _AuthTokensDto;

  factory AuthTokensDto.fromJson(Map<String, dynamic> json) => _$AuthTokensDtoFromJson(json);
}

================================================================
FILE: lib/features/auth/data/models/change_password_request.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'change_password_request.freezed.dart';
part 'change_password_request.g.dart';

@freezed
abstract class ChangePasswordRequest with _$ChangePasswordRequest {
  const factory ChangePasswordRequest({required String currentPassword, required String newPassword}) =
      _ChangePasswordRequest;

  factory ChangePasswordRequest.fromJson(Map<String, dynamic> json) => _$ChangePasswordRequestFromJson(json);
}

================================================================
FILE: lib/features/auth/data/models/forgot_password_request.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'forgot_password_request.freezed.dart';
part 'forgot_password_request.g.dart';

@freezed
abstract class ForgotPasswordRequest with _$ForgotPasswordRequest {
  const factory ForgotPasswordRequest({required String email}) = _ForgotPasswordRequest;

  factory ForgotPasswordRequest.fromJson(Map<String, dynamic> json) => _$ForgotPasswordRequestFromJson(json);
}

================================================================
FILE: lib/features/auth/data/models/reset_password_request.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'reset_password_request.freezed.dart';
part 'reset_password_request.g.dart';

@freezed
abstract class ResetPasswordRequest with _$ResetPasswordRequest {
  const factory ResetPasswordRequest({
    required String email,
    required String otp, // 6-digit OTP
    required String newPassword,
  }) = _ResetPasswordRequest;

  factory ResetPasswordRequest.fromJson(Map<String, dynamic> json) => _$ResetPasswordRequestFromJson(json);
}

================================================================
FILE: lib/features/auth/data/models/user_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_dto.freezed.dart';
part 'user_dto.g.dart';

@freezed
abstract class UserDto with _$UserDto {
  const factory UserDto({
    required int id,
    required String username,
    required String email,
    required bool emailVerified,
    String? phone,
    required String fullName,
    String? avatarUrl,
    String? bio,
    String? gender,
    String? dateOfBirth,
    String? location,
    String? profileVisibility,
    required bool online,
    String? lastSeen,
    required String createdAt,
    String? updatedAt,
  }) = _UserDto;

  factory UserDto.fromJson(Map<String, dynamic> json) => _$UserDtoFromJson(json);
}

================================================================
FILE: lib/features/auth/data/models/verify_email_request.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'verify_email_request.freezed.dart';
part 'verify_email_request.g.dart';

@freezed
abstract class VerifyEmailRequest with _$VerifyEmailRequest {
  const factory VerifyEmailRequest({
    required String email,
    required String otp, // 6-digit OTP
  }) = _VerifyEmailRequest;

  factory VerifyEmailRequest.fromJson(Map<String, dynamic> json) => _$VerifyEmailRequestFromJson(json);
}

================================================================
FILE: lib/features/auth/data/repositories/auth_repository_impl.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/core/repositories/base_repository.dart';
import 'package:chattrix_ui/features/auth/domain/datasources/auth_local_datasource.dart';
import 'package:chattrix_ui/features/auth/domain/datasources/auth_remote_datasource.dart';
import 'package:chattrix_ui/features/auth/domain/entities/auth_tokens.dart';
import 'package:chattrix_ui/features/auth/domain/entities/user.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:fpdart/fpdart.dart';
import '../mappers/auth_tokens_mapper.dart';
import '../mappers/user_mapper.dart';

class AuthRepositoryImpl extends BaseRepository implements AuthRepository {
  final AuthRemoteDataSource remoteDataSource;
  final AuthLocalDataSource localDataSource;

  AuthRepositoryImpl({required this.remoteDataSource, required this.localDataSource});

  @override
  Future<Either<Failure, void>> register({
    required String username,
    required String email,
    required String password,
    required String fullName,
  }) async {
    return executeApiCall(() async {
      await remoteDataSource.register(username: username, email: email, password: password, fullName: fullName);
    });
  }

  @override
  Future<Either<Failure, void>> verifyEmail({required String email, required String otp}) async {
    return executeApiCall(() async {
      await remoteDataSource.verifyEmail(email: email, otp: otp);
    });
  }

  @override
  Future<Either<Failure, void>> resendVerification({required String email}) async {
    return executeApiCall(() async {
      await remoteDataSource.resendVerification(email: email);
    });
  }

  @override
  Future<Either<Failure, AuthTokens>> login({required String usernameOrEmail, required String password}) async {
    return executeApiCall(() async {
      final tokensDto = await remoteDataSource.login(usernameOrEmail: usernameOrEmail, password: password);
      await localDataSource.saveTokens(accessToken: tokensDto.accessToken, refreshToken: tokensDto.refreshToken);

      return tokensDto.toEntity();
    });
  }

  @override
  Future<Either<Failure, User>> getCurrentUser() async {
    return executeApiCall(() async {
      final userDto = await remoteDataSource.getCurrentUser('');
      return userDto.toEntity();
    });
  }

  @override
  Future<Either<Failure, AuthTokens>> refreshToken() async {
    return executeApiCall(() async {
      final refreshToken = await localDataSource.getRefreshToken();
      if (refreshToken == null) {
        throw Exception('No refresh token available');
      }

      final tokensDto = await remoteDataSource.refreshToken(refreshToken);
      await localDataSource.saveTokens(accessToken: tokensDto.accessToken, refreshToken: tokensDto.refreshToken);

      return tokensDto.toEntity();
    });
  }

  @override
  Future<Either<Failure, void>> changePassword({required String currentPassword, required String newPassword}) async {
    return executeApiCall(() async {
      await remoteDataSource.changePassword(
        accessToken: '',
        currentPassword: currentPassword,
        newPassword: newPassword,
      );
    });
  }

  @override
  Future<Either<Failure, void>> forgotPassword({required String email}) async {
    return executeApiCall(() async {
      await remoteDataSource.forgotPassword(email: email);
    });
  }

  @override
  Future<Either<Failure, void>> resetPassword({
    required String email,
    required String otp,
    required String newPassword,
  }) async {
    return executeApiCall(() async {
      await remoteDataSource.resetPassword(email: email, otp: otp, newPassword: newPassword);
    });
  }

  @override
  Future<Either<Failure, void>> logout() async {
    return executeApiCall(() async {
      try {
        await remoteDataSource.logout('');
      } finally {
        await localDataSource.deleteTokens();
      }
    });
  }

  @override
  Future<Either<Failure, void>> logoutAll() async {
    return executeApiCall(() async {
      try {
        await remoteDataSource.logoutAll('');
      } finally {
        await localDataSource.deleteTokens();
      }
    });
  }

  @override
  Future<bool> isLoggedIn() async {
    final accessToken = await localDataSource.getAccessToken();
    return accessToken != null;
  }
}

================================================================
FILE: lib/features/auth/domain/datasources/auth_local_datasource.dart
================================================================
abstract class AuthLocalDataSource {
  Future<void> saveTokens({required String accessToken, required String refreshToken});

  Future<String?> getAccessToken();

  Future<String?> getRefreshToken();

  Future<void> deleteTokens();
}

================================================================
FILE: lib/features/auth/domain/datasources/auth_remote_datasource.dart
================================================================
import 'package:chattrix_ui/features/auth/data/models/auth_tokens_dto.dart';
import 'package:chattrix_ui/features/auth/data/models/user_dto.dart';

abstract class AuthRemoteDataSource {
  Future<void> register({
    required String username,
    required String email,
    required String password,
    required String fullName,
  });

  Future<void> verifyEmail({required String email, required String otp});

  Future<void> resendVerification({required String email});

  Future<AuthTokensDto> login({required String usernameOrEmail, required String password});

  Future<UserDto> getCurrentUser(String accessToken);

  Future<AuthTokensDto> refreshToken(String refreshToken);

  Future<void> changePassword({
    required String accessToken,
    required String currentPassword,
    required String newPassword,
  });

  Future<void> forgotPassword({required String email});

  Future<void> resetPassword({required String email, required String otp, required String newPassword});

  Future<void> logout(String accessToken);

  Future<void> logoutAll(String accessToken);
}

================================================================
FILE: lib/features/auth/domain/entities/auth_tokens.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'auth_tokens.freezed.dart';

@freezed
abstract class AuthTokens with _$AuthTokens {
  const factory AuthTokens({
    required String accessToken,
    required String refreshToken,
    required String tokenType,
    required int expiresIn,
  }) = _AuthTokens;
}

================================================================
FILE: lib/features/auth/domain/entities/user.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/enums.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user.freezed.dart';

@freezed
abstract class User with _$User {
  const factory User({
    required int id,
    required String username,
    required String email,
    required bool emailVerified,
    String? phone,
    required String fullName,
    String? avatarUrl,
    String? bio,
    Gender? gender,
    DateTime? dateOfBirth,
    String? location,
    ProfileVisibility? profileVisibility,
    required bool online,
    DateTime? lastSeen,
    required DateTime createdAt,
    DateTime? updatedAt,
  }) = _User;
}

================================================================
FILE: lib/features/auth/domain/repositories/auth_repository.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/entities/auth_tokens.dart';
import 'package:chattrix_ui/features/auth/domain/entities/user.dart';
import 'package:fpdart/fpdart.dart';

abstract class AuthRepository {
  Future<Either<Failure, void>> register({
    required String username,
    required String email,
    required String password,
    required String fullName,
  });

  Future<Either<Failure, void>> verifyEmail({required String email, required String otp});

  Future<Either<Failure, void>> resendVerification({required String email});

  Future<Either<Failure, AuthTokens>> login({required String usernameOrEmail, required String password});

  Future<Either<Failure, User>> getCurrentUser();

  Future<Either<Failure, AuthTokens>> refreshToken();

  Future<Either<Failure, void>> changePassword({required String currentPassword, required String newPassword});

  Future<Either<Failure, void>> forgotPassword({required String email});

  Future<Either<Failure, void>> resetPassword({
    required String email,
    required String otp,
    required String newPassword,
  });

  Future<Either<Failure, void>> logout();

  Future<Either<Failure, void>> logoutAll();

  Future<bool> isLoggedIn();
}

================================================================
FILE: lib/features/auth/domain/usecases/change_password_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:fpdart/fpdart.dart';

class ChangePasswordUseCase {
  final AuthRepository repository;

  ChangePasswordUseCase(this.repository);

  Future<Either<Failure, void>> call({required String currentPassword, required String newPassword}) async {
    return await repository.changePassword(currentPassword: currentPassword, newPassword: newPassword);
  }
}

================================================================
FILE: lib/features/auth/domain/usecases/forgot_password_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:fpdart/fpdart.dart';

class ForgotPasswordUseCase {
  final AuthRepository repository;

  ForgotPasswordUseCase(this.repository);

  Future<Either<Failure, void>> call({required String email}) async {
    return await repository.forgotPassword(email: email);
  }
}

================================================================
FILE: lib/features/auth/domain/usecases/get_current_user_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/entities/user.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:fpdart/fpdart.dart';

class GetCurrentUserUseCase {
  final AuthRepository repository;

  GetCurrentUserUseCase(this.repository);

  Future<Either<Failure, User>> call() async {
    return await repository.getCurrentUser();
  }
}

================================================================
FILE: lib/features/auth/domain/usecases/is_logged_in_usecase.dart
================================================================
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';

class IsLoggedInUseCase {
  final AuthRepository repository;

  IsLoggedInUseCase(this.repository);

  Future<bool> call() async {
    return await repository.isLoggedIn();
  }
}

================================================================
FILE: lib/features/auth/domain/usecases/login_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/entities/auth_tokens.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:fpdart/fpdart.dart';

class LoginUseCase {
  final AuthRepository repository;

  LoginUseCase(this.repository);

  Future<Either<Failure, AuthTokens>> call({required String usernameOrEmail, required String password}) async {
    return await repository.login(usernameOrEmail: usernameOrEmail, password: password);
  }
}

================================================================
FILE: lib/features/auth/domain/usecases/logout_all_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:fpdart/fpdart.dart';

class LogoutAllUseCase {
  final AuthRepository repository;

  LogoutAllUseCase(this.repository);

  Future<Either<Failure, void>> call() async {
    return await repository.logoutAll();
  }
}

================================================================
FILE: lib/features/auth/domain/usecases/logout_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:fpdart/fpdart.dart';

class LogoutUseCase {
  final AuthRepository repository;

  LogoutUseCase(this.repository);

  Future<Either<Failure, void>> call() async {
    return await repository.logout();
  }
}

================================================================
FILE: lib/features/auth/domain/usecases/refresh_token_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/entities/auth_tokens.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:fpdart/fpdart.dart';

class RefreshTokenUseCase {
  final AuthRepository repository;

  RefreshTokenUseCase(this.repository);

  Future<Either<Failure, AuthTokens>> call() async {
    return await repository.refreshToken();
  }
}

================================================================
FILE: lib/features/auth/domain/usecases/register_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:fpdart/fpdart.dart';

class RegisterUseCase {
  final AuthRepository repository;

  RegisterUseCase(this.repository);

  Future<Either<Failure, void>> call({
    required String username,
    required String email,
    required String password,
    required String fullName,
  }) async {
    return await repository.register(username: username, email: email, password: password, fullName: fullName);
  }
}

================================================================
FILE: lib/features/auth/domain/usecases/resend_verification_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:fpdart/fpdart.dart';

class ResendVerificationUseCase {
  final AuthRepository repository;

  ResendVerificationUseCase(this.repository);

  Future<Either<Failure, void>> call({required String email}) async {
    return await repository.resendVerification(email: email);
  }
}

================================================================
FILE: lib/features/auth/domain/usecases/reset_password_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:fpdart/fpdart.dart';

class ResetPasswordUseCase {
  final AuthRepository repository;

  ResetPasswordUseCase(this.repository);

  Future<Either<Failure, void>> call({required String email, required String otp, required String newPassword}) async {
    return await repository.resetPassword(email: email, otp: otp, newPassword: newPassword);
  }
}

================================================================
FILE: lib/features/auth/domain/usecases/verify_email_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:fpdart/fpdart.dart';

class VerifyEmailUseCase {
  final AuthRepository repository;

  VerifyEmailUseCase(this.repository);

  Future<Either<Failure, void>> call({required String email, required String otp}) async {
    return await repository.verifyEmail(email: email, otp: otp);
  }
}

================================================================
FILE: lib/features/auth/presentation/pages/forgot_password_screen.dart
================================================================
import 'package:chattrix_ui/core/router/app_router.dart';
import 'package:chattrix_ui/core/toast/toast_controller.dart';
import 'package:chattrix_ui/core/widgets/app_input_field.dart';
import 'package:chattrix_ui/core/widgets/primary_button.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class ForgotPasswordScreen extends HookConsumerWidget {
  const ForgotPasswordScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final emailController = useTextEditingController();
    final isLoading = ref.watch(isLoadingProvider);

    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: Icon(Icons.arrow_back, color: Theme.of(context).colorScheme.onSurface),
          onPressed: () => context.go(AppRouter.loginPath),
        ),
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 60),
              Text(
                'Forgot Password',
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              Text(
                'Enter the email associated with your account and we\'ll send an email with instructions to reset your password.',
                style: Theme.of(
                  context,
                ).textTheme.bodyLarge?.copyWith(color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)),
              ),
              const SizedBox(height: 40),
              AppInputField(labelText: 'Email', controller: emailController),
              const SizedBox(height: 30),
              PrimaryButton(
                text: 'Send Reset Link',
                isLoading: isLoading,
                onPressed: () async {
                  final email = emailController.text.trim();
                  if (email.isEmpty) {
                    Toasts.error(context, title: 'Error', description: 'Please enter your email');
                    return;
                  }

                  if (!email.contains('@')) {
                    Toasts.error(context, title: 'Error', description: 'Invalid email address');
                    return;
                  }
                  final success = await ref.read(authNotifierProvider.notifier).forgotPassword(email: email);

                  if (!context.mounted) return;

                  if (success) {
                    Toasts.success(
                      context,
                      title: 'Success',
                      description: 'A password reset email has been sent. Please check your inbox.',
                    );
                    context.push(AppRouter.otpVerificationPath, extra: {'email': email, 'isPasswordReset': true});
                  } else {
                    final error = ref.read(authErrorProvider);
                    Toasts.error(context, title: 'Failed to Send Email', description: error ?? 'An error occurred');
                  }
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/auth/presentation/pages/login_screen.dart
================================================================
import 'package:chattrix_ui/core/router/app_router.dart';
import 'package:chattrix_ui/core/toast/toast_controller.dart';
import 'package:chattrix_ui/core/widgets/app_input_field.dart';
import 'package:chattrix_ui/core/widgets/primary_button.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/auth/presentation/widgets/social_login_button.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class LoginScreen extends HookConsumerWidget {
  const LoginScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final emailController = useTextEditingController();
    final passwordController = useTextEditingController();
    final isLoading = ref.watch(isLoadingProvider);

    return Scaffold(
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.symmetric(horizontal: 24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 80),
              Text(
                'Welcome Back',
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              Text(
                'Enter your credentials to continue',
                style: Theme.of(
                  context,
                ).textTheme.bodyLarge?.copyWith(color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)),
              ),
              const SizedBox(height: 40),

              AppInputField(labelText: 'Email or Username', controller: emailController),
              const SizedBox(height: 20),
              AppInputField(labelText: 'Password', isPassword: true, controller: passwordController),
              const SizedBox(height: 12),

              Align(
                alignment: Alignment.centerRight,
                child: TextButton(
                  onPressed: () => context.push(AppRouter.forgotPasswordPath),
                  child: const Text('Forgot Password?'),
                ),
              ),
              const SizedBox(height: 20),

              PrimaryButton(
                text: 'Login',
                isLoading: isLoading,
                onPressed: () async {
                  final email = emailController.text.trim();
                  final password = passwordController.text;

                  if (email.isEmpty || password.isEmpty) {
                    Toasts.error(context, title: 'Error', description: 'Please fill in all fields');
                    return;
                  }

                  final success = await ref
                      .read(authNotifierProvider.notifier)
                      .login(usernameOrEmail: email, password: password);

                  if (!context.mounted) return;

                  if (success) {
                    Toasts.success(context, title: 'Success', description: 'Login successful!');
                    context.go('/');
                  } else {
                    final error = ref.read(authErrorProvider);
                    if (error != null && error.contains('Email not verified')) {
                      Toasts.error(context, title: 'Email Not Verified', description: error);
                      context.push(AppRouter.otpVerificationPath, extra: email);
                    } else {
                      Toasts.error(context, title: 'Login Failed', description: error ?? 'An error occurred');
                    }
                  }
                },
              ),
              const SizedBox(height: 40),

              const _OrDivider(),
              const SizedBox(height: 30),

              SocialLoginButton(icon: FontAwesomeIcons.google, text: 'Continue with Google', onPressed: () {}),
              const SizedBox(height: 16),
              SocialLoginButton(icon: FontAwesomeIcons.apple, text: 'Continue with Apple', onPressed: () {}),
              const SizedBox(height: 16),
              SocialLoginButton(icon: FontAwesomeIcons.facebook, text: 'Continue with Facebook', onPressed: () {}),
              const SizedBox(height: 40),

              _buildSignUpLink(context),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSignUpLink(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(
          "Don't have an account? ",
          style: TextStyle(color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)),
        ),
        TextButton(
          onPressed: () => context.go(AppRouter.registerPath),
          style: TextButton.styleFrom(padding: EdgeInsets.zero),
          child: const Text('Sign Up'),
        ),
      ],
    );
  }
}

class _OrDivider extends StatelessWidget {
  const _OrDivider();

  @override
  Widget build(BuildContext context) {
    final dividerColor = Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.2);
    return Row(
      children: [
        Expanded(child: Divider(color: dividerColor)),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0),
          child: Text('OR', style: TextStyle(color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6))),
        ),
        Expanded(child: Divider(color: dividerColor)),
      ],
    );
  }
}

================================================================
FILE: lib/features/auth/presentation/pages/login_screen_modern.dart
================================================================
import 'package:chattrix_ui/core/router/app_router.dart';
import 'package:chattrix_ui/core/toast/toast_controller.dart';
import 'package:chattrix_ui/core/widgets/app_input_field.dart';
import 'package:chattrix_ui/core/widgets/primary_button.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_state_provider.dart';
import 'package:chattrix_ui/features/auth/presentation/widgets/social_login_button.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
class LoginScreenModern extends HookConsumerWidget {
  const LoginScreenModern({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final emailController = useTextEditingController();
    final passwordController = useTextEditingController();
    final authAsync = ref.watch(authProvider);

    return Scaffold(
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.symmetric(horizontal: 24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 80),
              Text(
                'Welcome Back',
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              Text(
                'Enter your credentials to continue',
                style: Theme.of(
                  context,
                ).textTheme.bodyLarge?.copyWith(color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)),
              ),
              const SizedBox(height: 40),
              authAsync.whenOrNull(
                    error: (error, stack) => Padding(
                      padding: const EdgeInsets.only(bottom: 16),
                      child: Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.errorContainer,
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: Row(
                          children: [
                            Icon(Icons.error_outline, color: Theme.of(context).colorScheme.error),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                error.toString(),
                                style: TextStyle(color: Theme.of(context).colorScheme.error),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ) ??
                  const SizedBox.shrink(),
              AppInputField(labelText: 'Email or Username', controller: emailController),
              const SizedBox(height: 20),

              AppInputField(labelText: 'Password', isPassword: true, controller: passwordController),
              const SizedBox(height: 12),
              Align(
                alignment: Alignment.centerRight,
                child: TextButton(
                  onPressed: authAsync.isLoading ? null : () => context.push(AppRouter.forgotPasswordPath),
                  child: const Text('Forgot Password?'),
                ),
              ),
              const SizedBox(height: 20),
              PrimaryButton(
                text: 'Login',
                isLoading: authAsync.isLoading,
                onPressed: authAsync.isLoading
                    ? null
                    : () => _handleLogin(context, ref, emailController.text.trim(), passwordController.text),
              ),
              const SizedBox(height: 40),

              const _OrDivider(),
              const SizedBox(height: 30),
              SocialLoginButton(icon: FontAwesomeIcons.google, text: 'Continue with Google', onPressed: () {}),
              const SizedBox(height: 16),
              SocialLoginButton(icon: FontAwesomeIcons.apple, text: 'Continue with Apple', onPressed: () {}),
              const SizedBox(height: 16),
              SocialLoginButton(icon: FontAwesomeIcons.facebook, text: 'Continue with Facebook', onPressed: () {}),
              const SizedBox(height: 40),

              _buildSignUpLink(context, authAsync.isLoading),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
    );
  }
  Future<void> _handleLogin(BuildContext context, WidgetRef ref, String usernameOrEmail, String password) async {
    if (usernameOrEmail.isEmpty || password.isEmpty) {
      Toasts.error(context, title: 'Error', description: 'Please fill in all fields');
      return;
    }

    try {
      await ref.read(authProvider.notifier).login(usernameOrEmail: usernameOrEmail, password: password);
      if (!context.mounted) return;
      Toasts.success(context, title: 'Success', description: 'Login successful!');
      context.go('/');
    } catch (e) {
      if (!context.mounted) return;

      Toasts.error(context, title: 'Login Failed', description: e.toString());
    }
  }

  Widget _buildSignUpLink(BuildContext context, bool isLoading) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(
          "Don't have an account? ",
          style: TextStyle(color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)),
        ),
        TextButton(
          onPressed: isLoading ? null : () => context.go(AppRouter.registerPath),
          style: TextButton.styleFrom(padding: EdgeInsets.zero),
          child: const Text('Sign Up'),
        ),
      ],
    );
  }
}

class _OrDivider extends StatelessWidget {
  const _OrDivider();

  @override
  Widget build(BuildContext context) {
    final dividerColor = Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.2);
    return Row(
      children: [
        Expanded(child: Divider(color: dividerColor)),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0),
          child: Text('OR', style: TextStyle(color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6))),
        ),
        Expanded(child: Divider(color: dividerColor)),
      ],
    );
  }
}

================================================================
FILE: lib/features/auth/presentation/pages/otp_verification_screen.dart
================================================================
import 'package:chattrix_ui/core/router/app_router.dart';
import 'package:chattrix_ui/core/toast/toast_controller.dart';
import 'package:chattrix_ui/core/widgets/app_input_field.dart';
import 'package:chattrix_ui/core/widgets/primary_button.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class OtpVerificationScreen extends ConsumerStatefulWidget {
  final String? email;
  final bool isPasswordReset;

  const OtpVerificationScreen({super.key, this.email, this.isPasswordReset = false});

  @override
  ConsumerState<OtpVerificationScreen> createState() => _OtpVerificationScreenState();
}

class _OtpVerificationScreenState extends ConsumerState<OtpVerificationScreen> {
  late final List<FocusNode> _focusNodes;
  late final List<TextEditingController> _controllers;
  late final TextEditingController _newPasswordController;
  late String _email;

  @override
  void initState() {
    super.initState();
    _focusNodes = List.generate(6, (_) => FocusNode());
    _controllers = List.generate(6, (_) => TextEditingController());
    _newPasswordController = TextEditingController();
    _email = widget.email ?? '';
  }

  @override
  void dispose() {
    for (var node in _focusNodes) {
      node.dispose();
    }
    for (var controller in _controllers) {
      controller.dispose();
    }
    _newPasswordController.dispose();
    super.dispose();
  }

  String _getOtpCode() {
    return _controllers.map((c) => c.text).join();
  }

  Future<void> _verifyOtp() async {
    final otp = _getOtpCode();

    if (otp.length != 6) {
      Toasts.error(context, title: 'Error', description: 'Please enter the full 6-digit OTP');
      return;
    }

    if (_email.isEmpty) {
      Toasts.error(context, title: 'Error', description: 'Invalid email');
      return;
    }
    if (widget.isPasswordReset) {
      final newPassword = _newPasswordController.text;

      if (newPassword.isEmpty) {
        Toasts.error(context, title: 'Error', description: 'Please enter a new password');
        return;
      }

      if (newPassword.length < 6) {
        Toasts.error(context, title: 'Error', description: 'Password must be at least 6 characters long');
        return;
      }
      final success = await ref
          .read(authNotifierProvider.notifier)
          .resetPassword(email: _email, otp: otp, newPassword: newPassword);

      if (!mounted) return;

      if (success) {
        Toasts.success(context, title: 'Success', description: 'Password reset successful! Please log in.');
        context.go(AppRouter.loginPath);
      } else {
        final error = ref.read(authErrorProvider);
        Toasts.error(context, title: 'Password Reset Failed', description: error ?? 'Invalid or expired OTP code');
      }
    } else {
      final success = await ref.read(authNotifierProvider.notifier).verifyEmail(email: _email, otp: otp);

      if (!mounted) return;

      if (success) {
        Toasts.success(context, title: 'Success', description: 'Email verified successfully! Please log in.');
        context.go(AppRouter.loginPath);
      } else {
        final error = ref.read(authErrorProvider);
        Toasts.error(context, title: 'Verification Failed', description: error ?? 'Invalid OTP code');
      }
    }
  }

  Future<void> _resendOtp() async {
    if (_email.isEmpty) {
      Toasts.error(context, title: 'Error', description: 'Invalid email');
      return;
    }
    final success = widget.isPasswordReset
        ? await ref.read(authNotifierProvider.notifier).forgotPassword(email: _email)
        : await ref.read(authNotifierProvider.notifier).resendVerification(email: _email);

    if (!mounted) return;

    if (success) {
      Toasts.success(context, title: 'Success', description: 'A new OTP has been sent. Please check your email.');
    } else {
      final error = ref.read(authErrorProvider);
      Toasts.error(context, title: 'Resend Failed', description: error ?? 'An error occurred');
    }
  }

  @override
  Widget build(BuildContext context) {
    final isLoading = ref.watch(isLoadingProvider);

    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: Icon(Icons.arrow_back, color: Theme.of(context).colorScheme.onSurface),
          onPressed: () => context.go(AppRouter.loginPath),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.symmetric(horizontal: 24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              const SizedBox(height: 60),
              Text(
                widget.isPasswordReset ? 'Reset Password' : 'OTP Verification',
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(fontWeight: FontWeight.bold),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 8),
              Text(
                widget.isPasswordReset
                    ? 'Enter the 6-digit code sent to\n$_email\nand your new password'
                    : 'Enter the 6-digit code sent to\n$_email',
                style: Theme.of(
                  context,
                ).textTheme.bodyLarge?.copyWith(color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 40),
              _buildOtpInputFields(),
              const SizedBox(height: 30),
              if (widget.isPasswordReset) ...[
                AppInputField(labelText: 'New Password', isPassword: true, controller: _newPasswordController),
                const SizedBox(height: 30),
              ],
              PrimaryButton(
                text: widget.isPasswordReset ? 'Reset Password' : 'Verify',
                isLoading: isLoading,
                onPressed: _verifyOtp,
              ),
              const SizedBox(height: 20),
              TextButton(onPressed: isLoading ? null : _resendOtp, child: const Text('Resend Code')),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildOtpInputFields() {
    return Form(
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: List.generate(6, (index) {
          return SizedBox(
            width: 48,
            height: 52,
            child: TextFormField(
              controller: _controllers[index],
              focusNode: _focusNodes[index],
              onChanged: (text) {
                if (text.length == 1 && index < 5) {
                  _focusNodes[index + 1].requestFocus();
                }
                if (text.isEmpty && index > 0) {
                  _focusNodes[index - 1].requestFocus();
                }
              },
              style: Theme.of(context).textTheme.headlineSmall,
              keyboardType: TextInputType.number,
              textAlign: TextAlign.center,
              inputFormatters: [LengthLimitingTextInputFormatter(1), FilteringTextInputFormatter.digitsOnly],
              decoration: InputDecoration(
                contentPadding: const EdgeInsets.symmetric(vertical: 12),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                  borderSide: BorderSide(color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.3)),
                ),
                enabledBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                  borderSide: BorderSide(color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.3)),
                ),
              ),
            ),
          );
        }),
      ),
    );
  }
}

================================================================
FILE: lib/features/auth/presentation/pages/register_screen.dart
================================================================
import 'package:chattrix_ui/core/router/app_router.dart';
import 'package:chattrix_ui/core/toast/toast_controller.dart';
import 'package:chattrix_ui/core/widgets/app_input_field.dart';
import 'package:chattrix_ui/core/widgets/primary_button.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class RegisterScreen extends HookConsumerWidget {
  const RegisterScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final fullNameController = useTextEditingController();
    final usernameController = useTextEditingController();
    final emailController = useTextEditingController();
    final passwordController = useTextEditingController();
    final confirmPasswordController = useTextEditingController();
    final agreedToTerms = useState(false);
    final isLoading = ref.watch(isLoadingProvider);

    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: Icon(Icons.arrow_back, color: Theme.of(context).colorScheme.onSurface),
          onPressed: () => context.go(AppRouter.loginPath),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.symmetric(horizontal: 24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 20),
              Text(
                'Create Account',
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              Text(
                'Start your journey with us today',
                style: Theme.of(
                  context,
                ).textTheme.bodyLarge?.copyWith(color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)),
              ),
              const SizedBox(height: 40),
              AppInputField(labelText: 'Full Name', controller: fullNameController),
              const SizedBox(height: 20),
              AppInputField(labelText: 'Username', controller: usernameController),
              const SizedBox(height: 20),
              AppInputField(labelText: 'Email', controller: emailController),
              const SizedBox(height: 20),
              AppInputField(labelText: 'Password', isPassword: true, controller: passwordController),
              const SizedBox(height: 20),
              AppInputField(labelText: 'Confirm Password', isPassword: true, controller: confirmPasswordController),
              const SizedBox(height: 20),
              _buildTermsCheckbox(context, agreedToTerms),
              const SizedBox(height: 30),
              PrimaryButton(
                text: 'Register',
                isLoading: isLoading,
                onPressed: agreedToTerms.value
                    ? () async {
                        final fullName = fullNameController.text.trim();
                        final username = usernameController.text.trim();
                        final email = emailController.text.trim();
                        final password = passwordController.text;
                        final confirmPassword = confirmPasswordController.text;
                        if (fullName.isEmpty ||
                            username.isEmpty ||
                            email.isEmpty ||
                            password.isEmpty ||
                            confirmPassword.isEmpty) {
                          Toasts.error(context, title: 'Error', description: 'Please fill in all fields');
                          return;
                        }

                        if (!email.contains('@')) {
                          Toasts.error(context, title: 'Error', description: 'Invalid email address');
                          return;
                        }

                        if (password.length < 6) {
                          Toasts.error(
                            context,
                            title: 'Error',
                            description: 'Password must be at least 6 characters long',
                          );
                          return;
                        }

                        if (password != confirmPassword) {
                          Toasts.error(context, title: 'Error', description: 'Passwords do not match');
                          return;
                        }
                        final success = await ref
                            .read(authNotifierProvider.notifier)
                            .register(username: username, email: email, password: password, fullName: fullName);

                        if (!context.mounted) return;

                        if (success) {
                          Toasts.success(
                            context,
                            title: 'Success',
                            description: 'Registration successful! Please check your email to verify your account.',
                          );
                          context.push(AppRouter.otpVerificationPath, extra: {'email': email});
                        } else {
                          final error = ref.read(authErrorProvider);
                          Toasts.error(
                            context,
                            title: 'Registration Failed',
                            description: error ?? 'An error occurred',
                          );
                        }
                      }
                    : null,
              ),
              const SizedBox(height: 40),
              _buildLoginLink(context),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTermsCheckbox(BuildContext context, ValueNotifier<bool> agreedToTerms) {
    return Row(
      children: [
        SizedBox(
          width: 24,
          height: 24,
          child: Checkbox(
            value: agreedToTerms.value,
            onChanged: (bool? value) {
              agreedToTerms.value = value ?? false;
            },
            activeColor: Theme.of(context).primaryColor,
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: Text.rich(
            TextSpan(
              text: 'I agree to the ',
              style: TextStyle(color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)),
              children: [
                TextSpan(
                  text: 'Terms & Conditions',
                  style: TextStyle(
                    color: Theme.of(context).primaryColor,
                    fontWeight: FontWeight.bold,
                    decoration: TextDecoration.underline,
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildLoginLink(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(
          "Already have an account? ",
          style: TextStyle(color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)),
        ),
        TextButton(
          onPressed: () => context.go(AppRouter.loginPath),
          style: TextButton.styleFrom(padding: EdgeInsets.zero),
          child: const Text('Login'),
        ),
      ],
    );
  }
}

================================================================
FILE: lib/features/auth/presentation/providers/auth_providers.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/data/datasources/auth_local_datasource_impl.dart';
import 'package:chattrix_ui/features/auth/data/datasources/auth_remote_datasource_impl.dart';
import 'package:chattrix_ui/features/auth/data/repositories/auth_repository_impl.dart';
import 'package:chattrix_ui/features/auth/domain/datasources/auth_local_datasource.dart';
import 'package:chattrix_ui/features/auth/domain/datasources/auth_remote_datasource.dart';
import 'package:chattrix_ui/features/auth/domain/entities/user.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:chattrix_ui/features/auth/domain/usecases/change_password_usecase.dart';
import 'package:chattrix_ui/features/auth/domain/usecases/forgot_password_usecase.dart';
import 'package:chattrix_ui/features/auth/domain/usecases/get_current_user_usecase.dart';
import 'package:chattrix_ui/features/auth/domain/usecases/is_logged_in_usecase.dart';
import 'package:chattrix_ui/features/auth/domain/usecases/login_usecase.dart';
import 'package:chattrix_ui/features/auth/domain/usecases/logout_all_usecase.dart';
import 'package:chattrix_ui/features/auth/domain/usecases/logout_usecase.dart';
import 'package:chattrix_ui/features/auth/domain/usecases/refresh_token_usecase.dart';
import 'package:chattrix_ui/features/auth/domain/usecases/register_usecase.dart';
import 'package:chattrix_ui/features/auth/domain/usecases/resend_verification_usecase.dart';
import 'package:chattrix_ui/features/auth/domain/usecases/reset_password_usecase.dart';
import 'package:chattrix_ui/features/auth/domain/usecases/verify_email_usecase.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_repository_provider.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_providers.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
export 'auth_repository_provider.dart' show dioProvider, secureStorageProvider, tokenCacheServiceProvider;
final authRemoteDataSourceProvider = Provider<AuthRemoteDataSource>((ref) {
  return AuthRemoteDataSourceImpl(dio: ref.watch(dioProvider)) as AuthRemoteDataSource;
});

final authLocalDataSourceProvider = Provider<AuthLocalDataSource>((ref) {
  return AuthLocalDataSourceImpl(tokenCacheService: ref.watch(tokenCacheServiceProvider)) as AuthLocalDataSource;
});
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  return AuthRepositoryImpl(
    remoteDataSource: ref.watch(authRemoteDataSourceProvider),
    localDataSource: ref.watch(authLocalDataSourceProvider),
  );
});
final loginUseCaseProvider = Provider<LoginUseCase>((ref) {
  return LoginUseCase(ref.watch(authRepositoryProvider));
});

final registerUseCaseProvider = Provider<RegisterUseCase>((ref) {
  return RegisterUseCase(ref.watch(authRepositoryProvider));
});

final verifyEmailUseCaseProvider = Provider<VerifyEmailUseCase>((ref) {
  return VerifyEmailUseCase(ref.watch(authRepositoryProvider));
});

final resendVerificationUseCaseProvider = Provider<ResendVerificationUseCase>((ref) {
  return ResendVerificationUseCase(ref.watch(authRepositoryProvider));
});

final getCurrentUserUseCaseProvider = Provider<GetCurrentUserUseCase>((ref) {
  return GetCurrentUserUseCase(ref.watch(authRepositoryProvider));
});

final refreshTokenUseCaseProvider = Provider<RefreshTokenUseCase>((ref) {
  return RefreshTokenUseCase(ref.watch(authRepositoryProvider));
});

final changePasswordUseCaseProvider = Provider<ChangePasswordUseCase>((ref) {
  return ChangePasswordUseCase(ref.watch(authRepositoryProvider));
});

final forgotPasswordUseCaseProvider = Provider<ForgotPasswordUseCase>((ref) {
  return ForgotPasswordUseCase(ref.watch(authRepositoryProvider));
});

final resetPasswordUseCaseProvider = Provider<ResetPasswordUseCase>((ref) {
  return ResetPasswordUseCase(ref.watch(authRepositoryProvider));
});

final logoutUseCaseProvider = Provider<LogoutUseCase>((ref) {
  return LogoutUseCase(ref.watch(authRepositoryProvider));
});

final logoutAllUseCaseProvider = Provider<LogoutAllUseCase>((ref) {
  return LogoutAllUseCase(ref.watch(authRepositoryProvider));
});

final isLoggedInUseCaseProvider = Provider<IsLoggedInUseCase>((ref) {
  return IsLoggedInUseCase(ref.watch(authRepositoryProvider));
});
class AuthState {
  final User? user;
  final bool isLoading;
  final String? errorMessage;

  AuthState({this.user, this.isLoading = false, this.errorMessage});

  AuthState copyWith({
    User? user,
    bool? isLoading,
    String? errorMessage,
    bool clearUser = false,
    bool clearError = false,
  }) {
    return AuthState(
      user: clearUser ? null : (user ?? this.user),
      isLoading: isLoading ?? this.isLoading,
      errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
    );
  }
}
class AuthNotifier extends Notifier<AuthState> {
  @override
  AuthState build() {
    _checkAuthStatus();
    return AuthState();
  }

  Future<void> _checkAuthStatus() async {
    final isLoggedIn = await ref.read(isLoggedInUseCaseProvider)();
    if (isLoggedIn) {
      await loadCurrentUser();
    }
  }

  String _getFailureMessage(dynamic failure) {
    if (failure is Failure) {
      return failure.when(
        server: (message, code, requestId) => message,
        network: (message, code) => 'Kh√¥ng c√≥ k·∫øt n·ªëi m·∫°ng. Vui l√≤ng ki·ªÉm tra l·∫°i.',
        validation: (message, code, details, requestId) {
          if (details != null && details.isNotEmpty) {
            return details.values.join(', ');
          }
          return message;
        },
        auth: (message, code, requestId) {
          if (message.contains('Invalid or expired token') || message.contains('Token expired')) {
            _handleTokenExpired();
          }
          return message;
        },
        notFound: (message, code, requestId) => message,
        conflict: (message, code, requestId) => message,
        rateLimit: (message, code, requestId) => 'Qu√° nhi·ªÅu y√™u c·∫ßu. Vui l√≤ng th·ª≠ l·∫°i sau.',
      );
    }
    return 'C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.';
  }
  Future<void> _handleTokenExpired() async {
    try {
      final tokenCache = ref.read(tokenCacheServiceProvider);
      await tokenCache.clearTokens();
      await _clearAllState();
      state = AuthState();
    } catch (e) {
    }
  }

  Future<bool> login({required String usernameOrEmail, required String password}) async {
    state = state.copyWith(isLoading: true, clearError: true);

    final result = await ref.read(loginUseCaseProvider)(usernameOrEmail: usernameOrEmail, password: password);

    return result.fold(
      (failure) {
        state = state.copyWith(isLoading: false, errorMessage: _getFailureMessage(failure));
        return false;
      },
      (tokens) async {
        await loadCurrentUser();
        return true;
      },
    );
  }

  Future<bool> register({
    required String username,
    required String email,
    required String password,
    required String fullName,
  }) async {
    state = state.copyWith(isLoading: true, clearError: true);

    final result = await ref.read(registerUseCaseProvider)(
      username: username,
      email: email,
      password: password,
      fullName: fullName,
    );

    return result.fold(
      (failure) {
        state = state.copyWith(isLoading: false, errorMessage: _getFailureMessage(failure));
        return false;
      },
      (_) {
        state = state.copyWith(isLoading: false);
        return true;
      },
    );
  }

  Future<bool> verifyEmail({required String email, required String otp}) async {
    state = state.copyWith(isLoading: true, clearError: true);

    final result = await ref.read(verifyEmailUseCaseProvider)(email: email, otp: otp);

    return result.fold(
      (failure) {
        state = state.copyWith(isLoading: false, errorMessage: _getFailureMessage(failure));
        return false;
      },
      (_) {
        state = state.copyWith(isLoading: false);
        return true;
      },
    );
  }

  Future<bool> resendVerification({required String email}) async {
    state = state.copyWith(isLoading: true, clearError: true);

    final result = await ref.read(resendVerificationUseCaseProvider)(email: email);

    return result.fold(
      (failure) {
        state = state.copyWith(isLoading: false, errorMessage: _getFailureMessage(failure));
        return false;
      },
      (_) {
        state = state.copyWith(isLoading: false);
        return true;
      },
    );
  }

  Future<void> loadCurrentUser() async {
    state = state.copyWith(isLoading: true);

    final result = await ref.read(getCurrentUserUseCaseProvider)();

    result.fold(
      (failure) {
        final errorMessage = _getFailureMessage(failure);
        state = state.copyWith(isLoading: false, errorMessage: errorMessage);
      },
      (user) {
        state = state.copyWith(isLoading: false, user: user);
      },
    );
  }

  Future<bool> forgotPassword({required String email}) async {
    state = state.copyWith(isLoading: true, clearError: true);

    final result = await ref.read(forgotPasswordUseCaseProvider)(email: email);

    return result.fold(
      (failure) {
        state = state.copyWith(isLoading: false, errorMessage: _getFailureMessage(failure));
        return false;
      },
      (_) {
        state = state.copyWith(isLoading: false);
        return true;
      },
    );
  }

  Future<bool> resetPassword({required String email, required String otp, required String newPassword}) async {
    state = state.copyWith(isLoading: true, clearError: true);

    final result = await ref.read(resetPasswordUseCaseProvider)(email: email, otp: otp, newPassword: newPassword);

    return result.fold(
      (failure) {
        state = state.copyWith(isLoading: false, errorMessage: _getFailureMessage(failure));
        return false;
      },
      (_) {
        state = state.copyWith(isLoading: false);
        return true;
      },
    );
  }

  Future<bool> changePassword({required String currentPassword, required String newPassword}) async {
    state = state.copyWith(isLoading: true, clearError: true);

    final result = await ref.read(changePasswordUseCaseProvider)(
      currentPassword: currentPassword,
      newPassword: newPassword,
    );

    return result.fold(
      (failure) {
        state = state.copyWith(isLoading: false, errorMessage: _getFailureMessage(failure));
        return false;
      },
      (_) {
        state = state.copyWith(isLoading: false);
        return true;
      },
    );
  }

  Future<void> logout() async {
    state = state.copyWith(isLoading: true);
    await ref.read(logoutUseCaseProvider)();
    await _clearAllState();

    state = AuthState();
  }

  Future<void> logoutAll() async {
    state = state.copyWith(isLoading: true);
    await ref.read(logoutAllUseCaseProvider)();
    await _clearAllState();

    state = AuthState();
  }
  Future<void> _clearAllState() async {
    try {
      final wsNotifier = ref.read(webSocketConnectionProvider.notifier);
      await wsNotifier.disconnect();
      ref.invalidate(conversationsProvider);
      ref.invalidate(messagesProvider);
      ref.invalidate(onlineUsersProvider);
      ref.invalidate(userStatusProvider);
      ref.invalidate(webSocketConnectionProvider);
    } catch (e) {
    }
  }
}
final authNotifierProvider = NotifierProvider<AuthNotifier, AuthState>(() {
  return AuthNotifier();
});
final currentUserProvider = Provider<User?>((ref) {
  return ref.watch(authNotifierProvider).user;
});

final isLoadingProvider = Provider<bool>((ref) {
  return ref.watch(authNotifierProvider).isLoading;
});

final authErrorProvider = Provider<String?>((ref) {
  return ref.watch(authNotifierProvider).errorMessage;
});

================================================================
FILE: lib/features/auth/presentation/providers/auth_repository_provider.dart
================================================================
import 'package:chattrix_ui/core/network/auth_interceptor.dart';
import 'package:chattrix_ui/core/network/dio_client.dart';
import 'package:chattrix_ui/core/services/token_cache_service.dart';
import 'package:chattrix_ui/features/auth/data/datasources/auth_local_datasource_impl.dart';
import 'package:chattrix_ui/features/auth/data/datasources/auth_remote_datasource_impl.dart';
import 'package:chattrix_ui/features/auth/data/repositories/auth_repository_impl.dart';
import 'package:chattrix_ui/features/auth/domain/datasources/auth_local_datasource.dart';
import 'package:chattrix_ui/features/auth/domain/datasources/auth_remote_datasource.dart';
import 'package:chattrix_ui/features/auth/domain/repositories/auth_repository.dart';
import 'package:dio/dio.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'auth_repository_provider.g.dart';

@Riverpod(keepAlive: true)
FlutterSecureStorage secureStorage(Ref ref) {
  return const FlutterSecureStorage(
    aOptions: AndroidOptions(),

    webOptions: WebOptions(dbName: 'ChattrixDB'),

    wOptions: WindowsOptions(useBackwardCompatibility: false),
  );
}
@Riverpod(keepAlive: true)
TokenCacheService tokenCacheService(Ref ref) {
  return TokenCacheService(ref.watch(secureStorageProvider));
}
@Riverpod(keepAlive: true)
Dio dio(Ref ref) {
  final dio = DioClient.createDio();
  final tokenCache = ref.watch(tokenCacheServiceProvider);

  dio.interceptors.add(AuthInterceptor(dio: dio, tokenCacheService: tokenCache));

  return dio;
}

@Riverpod(keepAlive: true)
AuthRemoteDataSource authRemoteDataSource(Ref ref) {
  return AuthRemoteDataSourceImpl(dio: ref.watch(dioProvider));
}

@Riverpod(keepAlive: true)
AuthLocalDataSource authLocalDataSource(Ref ref) {
  return AuthLocalDataSourceImpl(tokenCacheService: ref.watch(tokenCacheServiceProvider));
}

@Riverpod(keepAlive: true)
AuthRepository authRepository(Ref ref) {
  return AuthRepositoryImpl(
    remoteDataSource: ref.watch(authRemoteDataSourceProvider),
    localDataSource: ref.watch(authLocalDataSourceProvider),
  );
}

================================================================
FILE: lib/features/auth/presentation/providers/auth_state_provider.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/entities/user.dart' as entities;
import 'package:chattrix_ui/features/auth/presentation/providers/auth_repository_provider.dart';
import 'package:chattrix_ui/features/auth/presentation/state/auth_state.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'auth_state_provider.g.dart';
@Riverpod(keepAlive: true)
class Auth extends _$Auth {
  @override
  Future<AuthState> build() async {
    final isLoggedIn = await ref.read(authRepositoryProvider).isLoggedIn();

    if (isLoggedIn) {
      final result = await ref.read(authRepositoryProvider).getCurrentUser();

      return result.fold(
        (failure) => const AuthState(isAuthenticated: false),
        (user) => AuthState(user: user, isAuthenticated: true),
      );
    }

    return const AuthState(isAuthenticated: false);
  }
  Future<void> login({required String usernameOrEmail, required String password}) async {
    state = const AsyncValue.loading();

    state = await AsyncValue.guard(() async {
      final repository = ref.read(authRepositoryProvider);
      final loginResult = await repository.login(usernameOrEmail: usernameOrEmail, password: password);
      loginResult.fold((failure) => throw _mapFailureToException(failure), (_) => null);
      final userResult = await repository.getCurrentUser();

      final user = userResult.fold((failure) => throw _mapFailureToException(failure), (user) => user);

      return AuthState(user: user, isAuthenticated: true);
    });
  }
  Future<void> register({
    required String username,
    required String email,
    required String password,
    required String fullName,
  }) async {
    state = const AsyncValue.loading();

    state = await AsyncValue.guard(() async {
      final repository = ref.read(authRepositoryProvider);

      final result = await repository.register(
        username: username,
        email: email,
        password: password,
        fullName: fullName,
      );

      result.fold((failure) => throw _mapFailureToException(failure), (_) => null);
      return const AuthState(isAuthenticated: false);
    });
  }
  Future<void> verifyEmail({required String email, required String otp}) async {
    final repository = ref.read(authRepositoryProvider);

    final result = await repository.verifyEmail(email: email, otp: otp);

    result.fold((failure) => throw _mapFailureToException(failure), (_) => null);
  }
  Future<void> resendVerification({required String email}) async {
    final repository = ref.read(authRepositoryProvider);

    final result = await repository.resendVerification(email: email);

    result.fold((failure) => throw _mapFailureToException(failure), (_) => null);
  }
  Future<void> changePassword({required String currentPassword, required String newPassword}) async {
    final repository = ref.read(authRepositoryProvider);

    final result = await repository.changePassword(currentPassword: currentPassword, newPassword: newPassword);

    result.fold((failure) => throw _mapFailureToException(failure), (_) => null);
  }
  Future<void> forgotPassword({required String email}) async {
    final repository = ref.read(authRepositoryProvider);

    final result = await repository.forgotPassword(email: email);

    result.fold((failure) => throw _mapFailureToException(failure), (_) => null);
  }
  Future<void> resetPassword({required String email, required String otp, required String newPassword}) async {
    final repository = ref.read(authRepositoryProvider);

    final result = await repository.resetPassword(email: email, otp: otp, newPassword: newPassword);

    result.fold((failure) => throw _mapFailureToException(failure), (_) => null);
  }
  Future<void> logout() async {
    state = const AsyncValue.loading();

    state = await AsyncValue.guard(() async {
      final repository = ref.read(authRepositoryProvider);

      final result = await repository.logout();

      result.fold((failure) => throw _mapFailureToException(failure), (_) => null);

      return const AuthState(isAuthenticated: false);
    });
  }
  Future<void> logoutAll() async {
    state = const AsyncValue.loading();

    state = await AsyncValue.guard(() async {
      final repository = ref.read(authRepositoryProvider);

      final result = await repository.logoutAll();

      result.fold((failure) => throw _mapFailureToException(failure), (_) => null);

      return const AuthState(isAuthenticated: false);
    });
  }
  Future<void> refreshUser() async {
    final repository = ref.read(authRepositoryProvider);

    final result = await repository.getCurrentUser();

    state = await AsyncValue.guard(() async {
      final user = result.fold((failure) => throw _mapFailureToException(failure), (user) => user);

      return AuthState(user: user, isAuthenticated: true);
    });
  }
  Exception _mapFailureToException(Failure failure) {
    return failure.when(
      server: (message, code, requestId) => ServerException(message, code),
      network: (message, code) => NetworkException(message),
      validation: (message, code, details, requestId) => ValidationException(message, details),
      auth: (message, code, requestId) => AuthException(message, code),
      notFound: (message, code, requestId) => NotFoundException(message, code),
      conflict: (message, code, requestId) => ConflictException(message, code),
      rateLimit: (message, code, requestId) => RateLimitException(message),
    );
  }
}
class ServerException implements Exception {
  final String message;
  final String? code;
  ServerException(this.message, [this.code]);

  @override
  String toString() => message;
}

class NetworkException implements Exception {
  final String message;
  NetworkException(this.message);

  @override
  String toString() => message;
}

class ValidationException implements Exception {
  final String message;
  final Map<String, String>? details;
  ValidationException(this.message, [this.details]);

  @override
  String toString() {
    if (details != null && details!.isNotEmpty) {
      return details!.values.join(', ');
    }
    return message;
  }
}

class AuthException implements Exception {
  final String message;
  final String? code;
  AuthException(this.message, [this.code]);

  @override
  String toString() => message;
}

class NotFoundException implements Exception {
  final String message;
  final String? code;
  NotFoundException(this.message, [this.code]);

  @override
  String toString() => message;
}

class ConflictException implements Exception {
  final String message;
  final String? code;
  ConflictException(this.message, [this.code]);

  @override
  String toString() => message;
}

class RateLimitException implements Exception {
  final String message;
  RateLimitException(this.message);

  @override
  String toString() => message;
}
@riverpod
entities.User? currentUser(Ref ref) {
  final authState = ref.watch(authProvider);
  return authState.whenData((state) => state.user).value;
}
@riverpod
bool isAuthenticated(Ref ref) {
  final authState = ref.watch(authProvider);
  return authState.whenData((state) => state.isAuthenticated).value ?? false;
}
@riverpod
bool isLoggedIn(Ref ref) {
  final authState = ref.watch(authProvider);
  return authState.whenData((state) => state.isAuthenticated && state.user != null).value ?? false;
}

================================================================
FILE: lib/features/auth/presentation/state/auth_state.dart
================================================================
import 'package:chattrix_ui/features/auth/domain/entities/user.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'auth_state.freezed.dart';
@freezed
abstract class AuthState with _$AuthState {
  const factory AuthState({User? user, @Default(false) bool isAuthenticated}) = _AuthState;
}

================================================================
FILE: lib/features/auth/presentation/widgets/social_login_button.dart
================================================================
import 'package:flutter/material.dart';

class SocialLoginButton extends StatelessWidget {
  final IconData icon;
  final String text;
  final VoidCallback onPressed;

  const SocialLoginButton({super.key, required this.icon, required this.text, required this.onPressed});

  @override
  Widget build(BuildContext context) {
    return OutlinedButton.icon(icon: Icon(icon, size: 20), onPressed: onPressed, label: Text(text));
  }
}

================================================================
FILE: lib/features/call/data/datasources/call_remote_datasource_impl.dart
================================================================
import 'package:chattrix_ui/core/constants/api_constants.dart';
import 'package:chattrix_ui/core/errors/exceptions.dart';
import 'package:chattrix_ui/features/call/data/models/call_connection_model.dart';
import 'package:chattrix_ui/features/call/data/models/call_info_model.dart';
import 'package:chattrix_ui/features/call/domain/datasources/call_remote_datasource.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_end_reason.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_reject_reason.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';
import 'package:dio/dio.dart';

class CallRemoteDataSourceImpl implements CallRemoteDataSource {
  final Dio dio;

  CallRemoteDataSourceImpl({required this.dio});

  @override
  Future<CallConnectionModel> initiateCall({required int calleeId, required CallType callType}) async {
    try {
      final response = await dio.post(
        ApiConstants.initiateCall,
        data: {'calleeId': calleeId, 'callType': callType.name.toUpperCase()},
      );

      if (response.statusCode == 200 || response.statusCode == 201) {
        return CallConnectionModel.fromJson(response.data['data']);
      } else {
        throw ServerException(message: response.data['message'] ?? 'Failed to initiate call');
      }
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Network error occurred');
    }
  }

  @override
  Future<CallConnectionModel> acceptCall({required String callId}) async {
    try {
      final response = await dio.post(ApiConstants.acceptCall(callId));

      if (response.statusCode == 200) {
        return CallConnectionModel.fromJson(response.data['data']);
      } else {
        throw ServerException(message: response.data['message'] ?? 'Failed to accept call');
      }
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Network error occurred');
    }
  }

  @override
  Future<CallInfoModel> rejectCall({required String callId, required CallRejectReason reason}) async {
    try {
      final response = await dio.post(ApiConstants.rejectCall(callId), data: {'reason': reason.name});

      if (response.statusCode == 200) {
        return CallInfoModel.fromJson(response.data['data']);
      } else {
        throw ServerException(message: response.data['message'] ?? 'Failed to reject call');
      }
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Network error occurred');
    }
  }

  @override
  Future<CallInfoModel> endCall({required String callId, required CallEndReason reason}) async {
    try {
      final response = await dio.post(ApiConstants.endCall(callId), data: {'reason': reason.name});

      if (response.statusCode == 200) {
        return CallInfoModel.fromJson(response.data['data']);
      } else {
        throw ServerException(message: response.data['message'] ?? 'Failed to end call');
      }
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Network error occurred');
    }
  }
}

================================================================
FILE: lib/features/call/data/datasources/call_websocket_datasource_impl.dart
================================================================
import 'dart:async';

import 'package:chattrix_ui/core/network/websocket_service.dart';
import 'package:chattrix_ui/features/call/data/models/call_accept_model.dart';
import 'package:chattrix_ui/features/call/data/models/call_end_model.dart';
import 'package:chattrix_ui/features/call/data/models/call_invitation_model.dart';
import 'package:chattrix_ui/features/call/data/models/call_reject_model.dart';
import 'package:chattrix_ui/features/call/data/models/call_timeout_model.dart';
import 'package:chattrix_ui/features/call/domain/datasources/call_websocket_datasource.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_accept.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_end.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_invitation.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_reject.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_timeout.dart';

class _CallWebSocketEvent {
  static const String invite = 'call.invite';
  static const String accept = 'call.accept';
  static const String reject = 'call.reject';
  static const String end = 'call.end';
}

class _CallWebSocketResponse {
  static const String incoming = 'call.incoming';
  static const String accepted = 'call.accepted';
  static const String rejected = 'call.rejected';
  static const String ended = 'call.ended';
  static const String timeout = 'call.timeout';
}

class CallWebSocketDataSourceImpl implements CallWebSocketDataSource {
  final WebSocketService _webSocketService;
  StreamSubscription<Map<String, dynamic>>? _subscription;

  final _incomingCallController = StreamController<CallInvitation>.broadcast();
  final _callAcceptedController = StreamController<CallAccept>.broadcast();
  final _callRejectedController = StreamController<CallReject>.broadcast();
  final _callEndedController = StreamController<CallEnd>.broadcast();
  final _callTimeoutController = StreamController<CallTimeout>.broadcast();

  CallWebSocketDataSourceImpl({required WebSocketService webSocketService}) : _webSocketService = webSocketService {
    _startListening();
  }

  void _startListening() {
    final callMessageTypes = [
      _CallWebSocketResponse.incoming,
      _CallWebSocketResponse.accepted,
      _CallWebSocketResponse.rejected,
      _CallWebSocketResponse.ended,
      _CallWebSocketResponse.timeout,
    ];

    _subscription = _webSocketService.messageRouter.getStreamForTypes(callMessageTypes).listen(_handleMessage);
  }

  void _handleMessage(Map<String, dynamic> message) {
    final type = message['type'] as String?;
    if (type == null) {
      return;
    }

    final data = message['data'] as Map<String, dynamic>? ?? message['payload'] as Map<String, dynamic>?;

    if (data == null) {
      return;
    }

    switch (type) {
      case _CallWebSocketResponse.incoming:
        _handleIncomingCall(data);
        break;
      case _CallWebSocketResponse.accepted:
        _handleCallAccepted(data);
        break;
      case _CallWebSocketResponse.rejected:
        _handleCallRejected(data);
        break;
      case _CallWebSocketResponse.ended:
        _handleCallEnded(data);
        break;
      case _CallWebSocketResponse.timeout:
        _handleCallTimeout(data);
        break;
    }
  }

  void _handleIncomingCall(Map<String, dynamic> data) {
    final invitation = CallInvitationModel.fromJson(data).toEntity();
    _incomingCallController.add(invitation);
  }

  void _handleCallAccepted(Map<String, dynamic> data) {
    final accept = CallAcceptModel.fromJson(data).toEntity();
    _callAcceptedController.add(accept);
  }

  void _handleCallRejected(Map<String, dynamic> data) {
    final reject = CallRejectModel.fromJson(data).toEntity();
    _callRejectedController.add(reject);
  }

  void _handleCallEnded(Map<String, dynamic> data) {
    final end = CallEndModel.fromJson(data).toEntity();
    _callEndedController.add(end);
  }

  void _handleCallTimeout(Map<String, dynamic> data) {
    final timeout = CallTimeoutModel.fromJson(data).toEntity();
    _callTimeoutController.add(timeout);
  }

  @override
  void sendCallInvitation({required String receiverId, required String callType}) {
    final payload = {
      'type': _CallWebSocketEvent.invite,
      'payload': {'receiverId': receiverId, 'callType': callType},
    };

    _webSocketService.send(payload);
  }

  @override
  void sendCallAccept({required String callId, required String sdpAnswer}) {
    final payload = {
      'type': _CallWebSocketEvent.accept,
      'payload': {'callId': callId, 'sdpAnswer': sdpAnswer},
    };

    _webSocketService.send(payload);
  }

  @override
  void sendCallReject({required String callId, required String reason}) {
    final payload = {
      'type': _CallWebSocketEvent.reject,
      'payload': {'callId': callId, 'reason': reason},
    };

    _webSocketService.send(payload);
  }

  @override
  void sendCallEnd(String callId) {
    final payload = {
      'type': _CallWebSocketEvent.end,
      'payload': {'callId': callId},
    };

    _webSocketService.send(payload);
  }

  @override
  Stream<CallInvitation> get incomingCallStream => _incomingCallController.stream;

  @override
  Stream<CallAccept> get callAcceptedStream => _callAcceptedController.stream;

  @override
  Stream<CallReject> get callRejectedStream => _callRejectedController.stream;

  @override
  Stream<CallEnd> get callEndedStream => _callEndedController.stream;

  @override
  Stream<CallTimeout> get callTimeoutStream => _callTimeoutController.stream;

  @override
  void dispose() {
    _subscription?.cancel();
    _incomingCallController.close();
    _callAcceptedController.close();
    _callRejectedController.close();
    _callEndedController.close();
    _callTimeoutController.close();
  }
}

================================================================
FILE: lib/features/call/data/models/call_accept_model.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_accept.dart';

part 'call_accept_model.freezed.dart';
part 'call_accept_model.g.dart';

@freezed
abstract class CallAcceptModel with _$CallAcceptModel {
  const CallAcceptModel._();

  const factory CallAcceptModel({required String callId, required int acceptedBy}) = _CallAcceptModel;

  factory CallAcceptModel.fromJson(Map<String, dynamic> json) => _$CallAcceptModelFromJson(json);

  CallAccept toEntity() {
    return CallAccept(callId: callId, acceptedBy: acceptedBy);
  }
}

================================================================
FILE: lib/features/call/data/models/call_connection_model.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_connection.dart';
import 'call_info_model.dart';

part 'call_connection_model.freezed.dart';
part 'call_connection_model.g.dart';

@freezed
abstract class CallConnectionModel with _$CallConnectionModel {
  const CallConnectionModel._();

  const factory CallConnectionModel({required CallInfoModel callInfo, required String token}) = _CallConnectionModel;

  factory CallConnectionModel.fromJson(Map<String, dynamic> json) => _$CallConnectionModelFromJson(json);

  CallConnection toEntity() {
    return CallConnection(callInfo: callInfo.toEntity(), token: token);
  }
}

================================================================
FILE: lib/features/call/data/models/call_end_model.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_end.dart';

part 'call_end_model.freezed.dart';
part 'call_end_model.g.dart';

@freezed
abstract class CallEndModel with _$CallEndModel {
  const CallEndModel._();

  const factory CallEndModel({required String callId, required int endedBy, int? durationSeconds}) = _CallEndModel;

  factory CallEndModel.fromJson(Map<String, dynamic> json) => _$CallEndModelFromJson(json);

  CallEnd toEntity() {
    return CallEnd(callId: callId, endedBy: endedBy, durationSeconds: durationSeconds);
  }
}

================================================================
FILE: lib/features/call/data/models/call_info_model.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_info.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_status.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';

part 'call_info_model.freezed.dart';
part 'call_info_model.g.dart';

@freezed
abstract class CallInfoModel with _$CallInfoModel {
  const CallInfoModel._();

  const factory CallInfoModel({
    required String id,
    required String channelId,
    required CallStatus status,
    required CallType callType,
    required int callerId,
    required String callerName,
    String? callerAvatar,
    required int calleeId,
    required String calleeName,
    String? calleeAvatar,
    required String createdAt,
    int? durationSeconds,
  }) = _CallInfoModel;

  factory CallInfoModel.fromJson(Map<String, dynamic> json) => _$CallInfoModelFromJson(json);

  CallInfo toEntity() {
    return CallInfo(
      id: id,
      channelId: channelId,
      status: status,
      callType: callType,
      callerId: callerId,
      callerName: callerName,
      callerAvatar: callerAvatar,
      calleeId: calleeId,
      calleeName: calleeName,
      calleeAvatar: calleeAvatar,
      createdAt: DateTime.parse(createdAt),
      durationSeconds: durationSeconds,
    );
  }
}

================================================================
FILE: lib/features/call/data/models/call_invitation_model.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_invitation.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';

part 'call_invitation_model.freezed.dart';
part 'call_invitation_model.g.dart';

@freezed
abstract class CallInvitationModel with _$CallInvitationModel {
  const CallInvitationModel._();

  const factory CallInvitationModel({
    required String callId,
    required String channelId,
    required int callerId,
    required String callerName,
    String? callerAvatar,
    required CallType callType,
  }) = _CallInvitationModel;

  factory CallInvitationModel.fromJson(Map<String, dynamic> json) => _$CallInvitationModelFromJson(json);

  CallInvitation toEntity() {
    return CallInvitation(
      callId: callId,
      channelId: channelId,
      callerId: callerId,
      callerName: callerName,
      callerAvatar: callerAvatar,
      callType: callType,
    );
  }
}

================================================================
FILE: lib/features/call/data/models/call_reject_model.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_reject.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_reject_reason.dart';

part 'call_reject_model.freezed.dart';
part 'call_reject_model.g.dart';

@freezed
abstract class CallRejectModel with _$CallRejectModel {
  const CallRejectModel._();

  const factory CallRejectModel({required String callId, required int rejectedBy, required CallRejectReason reason}) =
      _CallRejectModel;

  factory CallRejectModel.fromJson(Map<String, dynamic> json) => _$CallRejectModelFromJson(json);

  CallReject toEntity() {
    return CallReject(callId: callId, rejectedBy: rejectedBy, reason: reason);
  }
}

================================================================
FILE: lib/features/call/data/models/call_timeout_model.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_timeout.dart';

part 'call_timeout_model.freezed.dart';
part 'call_timeout_model.g.dart';

@freezed
abstract class CallTimeoutModel with _$CallTimeoutModel {
  const CallTimeoutModel._();

  const factory CallTimeoutModel({required String callId, required String reason}) = _CallTimeoutModel;

  factory CallTimeoutModel.fromJson(Map<String, dynamic> json) => _$CallTimeoutModelFromJson(json);

  CallTimeout toEntity() {
    return CallTimeout(callId: callId, reason: reason);
  }
}

================================================================
FILE: lib/features/call/data/models/websocket/call_accept_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'call_accept_dto.freezed.dart';
part 'call_accept_dto.g.dart';
@freezed
abstract class CallAcceptDto with _$CallAcceptDto {
  const factory CallAcceptDto({required String callId, required int acceptedBy}) = _CallAcceptDto;

  factory CallAcceptDto.fromJson(Map<String, dynamic> json) => _$CallAcceptDtoFromJson(json);
}

================================================================
FILE: lib/features/call/data/models/websocket/call_end_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'call_end_dto.freezed.dart';
part 'call_end_dto.g.dart';
@freezed
abstract class CallEndDto with _$CallEndDto {
  const factory CallEndDto({required String callId, required int endedBy, required int durationSeconds}) = _CallEndDto;

  factory CallEndDto.fromJson(Map<String, dynamic> json) => _$CallEndDtoFromJson(json);
}

================================================================
FILE: lib/features/call/data/models/websocket/call_invitation_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'call_invitation_dto.freezed.dart';
part 'call_invitation_dto.g.dart';
@freezed
abstract class CallInvitationDto with _$CallInvitationDto {
  const factory CallInvitationDto({
    required String callId,
    required String channelId,
    required int callerId,
    required String callerName,
    String? callerAvatar,
    required String callType,
  }) = _CallInvitationDto;

  factory CallInvitationDto.fromJson(Map<String, dynamic> json) => _$CallInvitationDtoFromJson(json);
}

================================================================
FILE: lib/features/call/data/models/websocket/call_reject_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'call_reject_dto.freezed.dart';
part 'call_reject_dto.g.dart';
@freezed
abstract class CallRejectDto with _$CallRejectDto {
  const factory CallRejectDto({required String callId, required int rejectedBy, required String reason}) =
      _CallRejectDto;

  factory CallRejectDto.fromJson(Map<String, dynamic> json) => _$CallRejectDtoFromJson(json);
}

================================================================
FILE: lib/features/call/data/models/websocket/call_timeout_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'call_timeout_dto.freezed.dart';
part 'call_timeout_dto.g.dart';
@freezed
abstract class CallTimeoutDto with _$CallTimeoutDto {
  const factory CallTimeoutDto({required String callId, required String reason}) = _CallTimeoutDto;

  factory CallTimeoutDto.fromJson(Map<String, dynamic> json) => _$CallTimeoutDtoFromJson(json);
}

================================================================
FILE: lib/features/call/data/repositories/call_repository_impl.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/core/repositories/base_repository.dart';
import 'package:chattrix_ui/features/call/domain/datasources/call_remote_datasource.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_connection.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_end_reason.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_info.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_reject_reason.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';
import 'package:chattrix_ui/features/call/domain/repositories/call_repository.dart';
import 'package:fpdart/fpdart.dart';

class CallRepositoryImpl extends BaseRepository implements CallRepository {
  final CallRemoteDataSource remoteDataSource;

  CallRepositoryImpl({required this.remoteDataSource});

  @override
  Future<Either<Failure, CallConnection>> initiateCall({required int calleeId, required CallType callType}) async {
    return executeApiCall(() async {
      final result = await remoteDataSource.initiateCall(calleeId: calleeId, callType: callType);
      return result.toEntity();
    });
  }

  @override
  Future<Either<Failure, CallConnection>> acceptCall({required String callId}) async {
    return executeApiCall(() async {
      final result = await remoteDataSource.acceptCall(callId: callId);
      return result.toEntity();
    });
  }

  @override
  Future<Either<Failure, CallInfo>> rejectCall({required String callId, required CallRejectReason reason}) async {
    return executeApiCall(() async {
      final result = await remoteDataSource.rejectCall(callId: callId, reason: reason);
      return result.toEntity();
    });
  }

  @override
  Future<Either<Failure, CallInfo>> endCall({required String callId, required CallEndReason reason}) async {
    return executeApiCall(() async {
      final result = await remoteDataSource.endCall(callId: callId, reason: reason);
      return result.toEntity();
    });
  }
}

================================================================
FILE: lib/features/call/domain/datasources/call_remote_datasource.dart
================================================================
import 'package:chattrix_ui/features/call/data/models/call_connection_model.dart';
import 'package:chattrix_ui/features/call/data/models/call_info_model.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_end_reason.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_reject_reason.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';

abstract class CallRemoteDataSource {
  Future<CallConnectionModel> initiateCall({required int calleeId, required CallType callType});

  Future<CallConnectionModel> acceptCall({required String callId});

  Future<CallInfoModel> rejectCall({required String callId, required CallRejectReason reason});

  Future<CallInfoModel> endCall({required String callId, required CallEndReason reason});
}

================================================================
FILE: lib/features/call/domain/datasources/call_websocket_datasource.dart
================================================================
import 'package:chattrix_ui/features/call/domain/entities/call_accept.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_end.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_invitation.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_reject.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_timeout.dart';

abstract class CallWebSocketDataSource {
  void sendCallInvitation({required String receiverId, required String callType});

  void sendCallAccept({required String callId, required String sdpAnswer});

  void sendCallReject({required String callId, required String reason});

  void sendCallEnd(String callId);

  Stream<CallInvitation> get incomingCallStream;

  Stream<CallAccept> get callAcceptedStream;

  Stream<CallReject> get callRejectedStream;

  Stream<CallEnd> get callEndedStream;

  Stream<CallTimeout> get callTimeoutStream;

  void dispose();
}

================================================================
FILE: lib/features/call/domain/entities/call_accept.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'call_accept.freezed.dart';

@freezed
abstract class CallAccept with _$CallAccept {
  const factory CallAccept({required String callId, required int acceptedBy}) = _CallAccept;
}

================================================================
FILE: lib/features/call/domain/entities/call_connection.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';
import 'call_info.dart';

part 'call_connection.freezed.dart';

@freezed
abstract class CallConnection with _$CallConnection {
  const factory CallConnection({required CallInfo callInfo, required String token}) = _CallConnection;
}

================================================================
FILE: lib/features/call/domain/entities/call_end.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'call_end.freezed.dart';

@freezed
abstract class CallEnd with _$CallEnd {
  const factory CallEnd({required String callId, required int endedBy, int? durationSeconds}) = _CallEnd;
}

================================================================
FILE: lib/features/call/domain/entities/call_end_reason.dart
================================================================
import 'package:json_annotation/json_annotation.dart';

@JsonEnum()
enum CallEndReason {
  @JsonValue('hangup')
  hangup,
  @JsonValue('network error')
  networkError,
  @JsonValue('device error')
  deviceError,
  @JsonValue('timeout')
  timeout,
}

================================================================
FILE: lib/features/call/domain/entities/call_info.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';
import 'call_status.dart';
import 'call_type.dart';

part 'call_info.freezed.dart';

@freezed
abstract class CallInfo with _$CallInfo {
  const factory CallInfo({
    required String id,
    required String channelId,
    required CallStatus status,
    required CallType callType,
    required int callerId,
    required String callerName,
    String? callerAvatar,
    required int calleeId,
    required String calleeName,
    String? calleeAvatar,
    required DateTime createdAt,
    int? durationSeconds,
  }) = _CallInfo;
}

================================================================
FILE: lib/features/call/domain/entities/call_invitation.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';
import 'call_type.dart';

part 'call_invitation.freezed.dart';

@freezed
abstract class CallInvitation with _$CallInvitation {
  const factory CallInvitation({
    required String callId,
    required String channelId,
    required int callerId,
    required String callerName,
    String? callerAvatar,
    required CallType callType,
  }) = _CallInvitation;
}

================================================================
FILE: lib/features/call/domain/entities/call_reject.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';
import 'call_reject_reason.dart';

part 'call_reject.freezed.dart';

@freezed
abstract class CallReject with _$CallReject {
  const factory CallReject({required String callId, required int rejectedBy, required CallRejectReason reason}) =
      _CallReject;
}

================================================================
FILE: lib/features/call/domain/entities/call_reject_reason.dart
================================================================
import 'package:json_annotation/json_annotation.dart';

@JsonEnum()
enum CallRejectReason {
  @JsonValue('busy')
  busy,
  @JsonValue('declined')
  declined,
  @JsonValue('unavailable')
  unavailable,
}

================================================================
FILE: lib/features/call/domain/entities/call_status.dart
================================================================
import 'package:json_annotation/json_annotation.dart';

@JsonEnum()
enum CallStatus {
  @JsonValue('RINGING')
  ringing,
  @JsonValue('CONNECTING')
  connecting,
  @JsonValue('CONNECTED')
  connected,
  @JsonValue('REJECTED')
  rejected,
  @JsonValue('ENDED')
  ended,
  @JsonValue('INITIATING')
  initiating,
}

================================================================
FILE: lib/features/call/domain/entities/call_timeout.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'call_timeout.freezed.dart';

@freezed
abstract class CallTimeout with _$CallTimeout {
  const factory CallTimeout({required String callId, required String reason}) = _CallTimeout;
}

================================================================
FILE: lib/features/call/domain/entities/call_type.dart
================================================================
import 'package:json_annotation/json_annotation.dart';

@JsonEnum()
enum CallType {
  @JsonValue('AUDIO')
  audio,
  @JsonValue('VIDEO')
  video,
}

================================================================
FILE: lib/features/call/domain/repositories/call_repository.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_connection.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_end_reason.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_info.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_reject_reason.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';
import 'package:fpdart/fpdart.dart';

abstract class CallRepository {
  Future<Either<Failure, CallConnection>> initiateCall({required int calleeId, required CallType callType});

  Future<Either<Failure, CallConnection>> acceptCall({required String callId});

  Future<Either<Failure, CallInfo>> rejectCall({required String callId, required CallRejectReason reason});

  Future<Either<Failure, CallInfo>> endCall({required String callId, required CallEndReason reason});
}

================================================================
FILE: lib/features/call/domain/usecases/accept_call_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_connection.dart';
import 'package:chattrix_ui/features/call/domain/repositories/call_repository.dart';
import 'package:fpdart/fpdart.dart';

class AcceptCallUseCase {
  final CallRepository repository;

  AcceptCallUseCase(this.repository);

  Future<Either<Failure, CallConnection>> call({required String callId}) {
    return repository.acceptCall(callId: callId);
  }
}

================================================================
FILE: lib/features/call/domain/usecases/end_call_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_end_reason.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_info.dart';
import 'package:chattrix_ui/features/call/domain/repositories/call_repository.dart';
import 'package:fpdart/fpdart.dart';

class EndCallUseCase {
  final CallRepository repository;

  EndCallUseCase(this.repository);

  Future<Either<Failure, CallInfo>> call({required String callId, required CallEndReason reason}) {
    return repository.endCall(callId: callId, reason: reason);
  }
}

================================================================
FILE: lib/features/call/domain/usecases/initiate_call_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_connection.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';
import 'package:chattrix_ui/features/call/domain/repositories/call_repository.dart';
import 'package:fpdart/fpdart.dart';

class InitiateCallUseCase {
  final CallRepository repository;

  InitiateCallUseCase(this.repository);

  Future<Either<Failure, CallConnection>> call({required int calleeId, required CallType callType}) {
    return repository.initiateCall(calleeId: calleeId, callType: callType);
  }
}

================================================================
FILE: lib/features/call/domain/usecases/reject_call_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_info.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_reject_reason.dart';
import 'package:chattrix_ui/features/call/domain/repositories/call_repository.dart';
import 'package:fpdart/fpdart.dart';

class RejectCallUseCase {
  final CallRepository repository;

  RejectCallUseCase(this.repository);

  Future<Either<Failure, CallInfo>> call({required String callId, required CallRejectReason reason}) {
    return repository.rejectCall(callId: callId, reason: reason);
  }
}

================================================================
FILE: lib/features/call/presentation/pages/call_page.dart
================================================================
import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:chattrix_ui/core/widgets/user_avatar.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';
import 'package:chattrix_ui/features/call/presentation/providers/call_service_provider.dart';
import 'package:chattrix_ui/features/call/presentation/state/call_notifier.dart';
import 'package:chattrix_ui/features/call/presentation/state/call_state.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../widgets/call_controls_panel.dart';

class CallPage extends ConsumerWidget {
  const CallPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final callState = ref.watch(callProvider);

    return Scaffold(
      backgroundColor: Colors.white, // N·ªÅn s√°ng
      body: callState.when(
        idle: () => const Center(child: SizedBox()),
        initiating: (_, __) => const Center(child: CircularProgressIndicator()),
        ringing: (_) => const Center(child: CircularProgressIndicator()),
        connecting: (_, __, ___) => const Center(child: CircularProgressIndicator()),
        connected:
            (
              connection,
              callType,
              isOutgoing,
              isMuted,
              isVideoEnabled,
              isSpeakerEnabled,
              isFrontCamera,
              remoteUid,
              remoteIsMuted,
              remoteIsVideoEnabled,
            ) {
              final remoteName = isOutgoing ? connection.callInfo.calleeName : connection.callInfo.callerName;
              final remoteAvatar = isOutgoing ? connection.callInfo.calleeAvatar : connection.callInfo.callerAvatar;
              final isVideoCall = callType == CallType.video;

              return Stack(
                children: [
                  if (isVideoCall)
                    Positioned.fill(
                      child: remoteIsVideoEnabled
                          ? _buildVideoContent(ref, remoteUid, remoteName, remoteAvatar)
                          : _buildAudioContent(remoteName, remoteAvatar),
                    )
                  else
                    Positioned.fill(child: _buildAudioContent(remoteName, remoteAvatar)),
                  Positioned(
                    top: 0,
                    left: 0,
                    right: 0,
                    child: SafeArea(
                      child: Container(
                        padding: const EdgeInsets.symmetric(vertical: 16),
                        alignment: Alignment.center,
                        child: Column(
                          children: [
                            Row(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: [
                                Text(
                                  remoteName,
                                  style: GoogleFonts.inter(
                                    color: isVideoCall ? Colors.white : Colors.black87,
                                    fontSize: 20,
                                    fontWeight: FontWeight.w600,
                                    shadows: isVideoCall ? [const Shadow(blurRadius: 4, color: Colors.black54)] : null,
                                  ),
                                ),
                                if (remoteIsMuted) ...[
                                  const SizedBox(width: 8),
                                  Container(
                                    padding: const EdgeInsets.all(4),
                                    decoration: BoxDecoration(
                                      color: Colors.red.withOpacity(0.9),
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    child: const Icon(Icons.mic_off, size: 16, color: Colors.white),
                                  ),
                                ],
                              ],
                            ),
                            const SizedBox(height: 4),
                            Container(
                              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                              decoration: BoxDecoration(
                                color: isVideoCall ? Colors.black26 : Colors.grey[200],
                                borderRadius: BorderRadius.circular(16),
                              ),
                              child: Text(
                                "00:00", // C·∫ßn th√™m logic timer v√†o ƒë√¢y
                                style: GoogleFonts.inter(
                                  color: isVideoCall ? Colors.white : Colors.black54,
                                  fontSize: 12,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                  if (isVideoCall)
                    Positioned(
                      top: 100,
                      right: 16,
                      child: ClipRRect(
                        borderRadius: BorderRadius.circular(16),
                        child: SizedBox(
                          width: 100,
                          height: 150,
                          child: isVideoEnabled
                              ? const _LocalVideoPreview()
                              : Container(
                                  color: Colors.grey[300],
                                  child: const Icon(Icons.videocam_off, color: Colors.black54),
                                ),
                        ),
                      ),
                    ),
                  Positioned(bottom: 0, left: 0, right: 0, child: CallControlsPanel(callType: callType)),
                ],
              );
            },
        ended: (reason) => Center(child: Text("Ended: $reason")),
        error: (msg) => Center(child: Text(msg)),
      ),
    );
  }

  Widget _buildAudioContent(String name, String? avatar) {
    return Container(
      color: Colors.white,
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(4),
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: Colors.white,
                boxShadow: [BoxShadow(color: Colors.grey.withOpacity(0.1), blurRadius: 30, spreadRadius: 10)],
              ),
              child: UserAvatar(displayName: name, avatarUrl: avatar, radius: 80),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildVideoContent(WidgetRef ref, int? remoteUid, String name, String? avatar) {
    final agoraService = ref.watch(agoraServiceProvider);
    if (remoteUid != null && agoraService.engine != null) {
      return AgoraVideoView(
        controller: VideoViewController.remote(
          rtcEngine: agoraService.engine!,
          canvas: VideoCanvas(uid: remoteUid),
          connection: const RtcConnection(channelId: ''), // ƒêi·ªÅn channelId th·ª±c t·∫ø c·ªßa b·∫°n
        ),
      );
    }
    return Container(
      color: const Color(0xFF2C2C2E), // N·ªÅn t·ªëi khi ch·ªù video
      child: const Center(child: CircularProgressIndicator(color: Colors.white)),
    );
  }
}

class _LocalVideoPreview extends ConsumerWidget {
  const _LocalVideoPreview();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final agoraService = ref.watch(agoraServiceProvider);
    if (agoraService.engine == null) return const SizedBox();

    return AgoraVideoView(
      controller: VideoViewController(rtcEngine: agoraService.engine!, canvas: const VideoCanvas(uid: 0)),
    );
  }
}

================================================================
FILE: lib/features/call/presentation/pages/incoming_call_page.dart
================================================================
import 'package:chattrix_ui/core/widgets/user_avatar.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';
import 'package:chattrix_ui/features/call/presentation/state/call_notifier.dart';
import 'package:chattrix_ui/features/call/presentation/state/call_state.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class IncomingCallPage extends ConsumerWidget {
  const IncomingCallPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final callState = ref.watch(callProvider);

    return Scaffold(
      backgroundColor: Colors.white,
      body: callState.when(
        idle: () => const SizedBox(),
        initiating: (_, _) => const SizedBox(),
        ringing: (invitation) => _buildRingingView(
          context,
          ref,
          callerName: invitation.callerName,
          callerAvatar: invitation.callerAvatar,
          callType: invitation.callType,
        ),
        connecting: (_, _, _) => const SizedBox(),
        connected: (_, _, _, _, _, _, _, _, _, _) => const SizedBox(),
        ended: (_) => const SizedBox(),
        error: (message) => Center(child: Text(message)),
      ),
    );
  }

  Widget _buildRingingView(
    BuildContext context,
    WidgetRef ref, {
    required String callerName,
    String? callerAvatar,
    required CallType callType,
  }) {
    return Container(
      width: double.infinity, // FIX: ƒê·∫£m b·∫£o container n·ªÅn full width
      height: double.infinity, // FIX: ƒê·∫£m b·∫£o container n·ªÅn full height
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
          colors: [
            Color(0xFFFFFFFF), // Tr·∫Øng
            Color(0xFFEEF2F6), // X√°m xanh r·∫•t nh·∫°t
          ],
        ),
      ),
      child: SafeArea(
        child: SizedBox(
          width: double.infinity, // FIX: Quan tr·ªçng! √âp Column ph·∫£i r·ªông full m√†n h√¨nh
          child: Column(
            mainAxisAlignment: MainAxisAlignment.start,
            crossAxisAlignment: CrossAxisAlignment.center, // FIX: CƒÉn gi·ªØa c√°c widget con theo chi·ªÅu ngang
            children: [
              const Spacer(flex: 1),
              Container(
                padding: const EdgeInsets.all(4),
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: Colors.white,
                  boxShadow: [
                    BoxShadow(color: Colors.black.withValues(alpha: 0.08), blurRadius: 24, offset: const Offset(0, 12)),
                  ],
                ),
                child: UserAvatar(displayName: callerName, avatarUrl: callerAvatar, radius: 80),
              ),
              const SizedBox(height: 32),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 24.0),
                child: Text(
                  callerName,
                  textAlign: TextAlign.center, // CƒÉn gi·ªØa text n·∫øu t√™n qu√° d√†i xu·ªëng d√≤ng
                  style: GoogleFonts.inter(
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    color: Colors.black87,
                    letterSpacing: -0.5,
                  ),
                ),
              ),
              const SizedBox(height: 12),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                decoration: BoxDecoration(
                  color: Colors.blue.withValues(alpha: 0.08),
                  borderRadius: BorderRadius.circular(24),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      callType == CallType.video ? Icons.videocam_rounded : Icons.phone_in_talk_rounded,
                      color: Colors.blue[700],
                      size: 20,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      callType == CallType.video ? 'Incoming Video Call' : 'Incoming Audio Call',
                      style: GoogleFonts.inter(fontSize: 15, fontWeight: FontWeight.w600, color: Colors.blue[700]),
                    ),
                  ],
                ),
              ),

              const Spacer(flex: 2),
              Padding(
                padding: const EdgeInsets.only(bottom: 60, left: 40, right: 40),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceAround,
                  children: [
                    _ActionColumn(
                      icon: Icons.call_end,
                      label: "Decline",
                      color: const Color(0xFFFF3B30), // ƒê·ªè
                      onTap: () => ref.read(callProvider.notifier).rejectCall(),
                    ),
                    _ActionColumn(
                      icon: callType == CallType.video ? Icons.videocam : Icons.call,
                      label: "Accept",
                      color: const Color(0xFF34C759), // Xanh l√°
                      onTap: () => ref.read(callProvider.notifier).acceptCall(),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
class _ActionColumn extends StatelessWidget {
  final IconData icon;
  final String label;
  final Color color;
  final VoidCallback onTap;

  const _ActionColumn({required this.icon, required this.label, required this.color, required this.onTap});

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        GestureDetector(
          onTap: onTap,
          child: Container(
            width: 72,
            height: 72,
            decoration: BoxDecoration(
              color: color,
              shape: BoxShape.circle,
              boxShadow: [BoxShadow(color: color.withValues(alpha: 0.4), blurRadius: 16, offset: const Offset(0, 6))],
            ),
            child: Icon(icon, color: Colors.white, size: 32),
          ),
        ),
        const SizedBox(height: 12),
        Text(
          label,
          style: GoogleFonts.inter(color: Colors.black87, fontWeight: FontWeight.w600, fontSize: 15),
        ),
      ],
    );
  }
}

================================================================
FILE: lib/features/call/presentation/pages/outgoing_call_page.dart
================================================================
import 'package:chattrix_ui/core/widgets/user_avatar.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';
import 'package:chattrix_ui/features/call/presentation/state/call_notifier.dart';
import 'package:chattrix_ui/features/call/presentation/state/call_state.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class OutgoingCallPage extends ConsumerWidget {
  const OutgoingCallPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final callState = ref.watch(callProvider);

    return Scaffold(
      backgroundColor: Colors.white,
      body: callState.when(
        idle: () => const SizedBox(),
        initiating: (_, callType) => _buildView(context, ref, "Connecting...", null, callType),
        ringing: (_) => const SizedBox(),
        connecting: (connection, callType, isOutgoing) {
          if (isOutgoing) {
            return _buildView(context, ref, connection.callInfo.calleeName, connection.callInfo.calleeAvatar, callType);
          }
          return const SizedBox();
        },
        connected: (_, _, _, _, _, _, _, _, _, _) => const SizedBox(),
        ended: (_) => const SizedBox(),
        error: (msg) => Center(child: Text(msg)),
      ),
    );
  }

  Widget _buildView(BuildContext context, WidgetRef ref, String name, String? avatar, CallType callType) {
    return SizedBox.expand(
      child: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Colors.white, Color(0xFFF5F7FA)],
          ),
        ),
        child: SafeArea(
          child: SizedBox(
            width: double.infinity,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center, // CƒÉn gi·ªØa theo chi·ªÅu d·ªçc
              crossAxisAlignment: CrossAxisAlignment.center, // QUAN TR·ªåNG: CƒÉn gi·ªØa theo chi·ªÅu ngang
              children: [
                const Spacer(flex: 1),
                Container(
                  padding: const EdgeInsets.all(4),
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    border: Border.all(color: Colors.blue.withValues(alpha: 0.1), width: 1),
                    color: Colors.white,
                  ),
                  child: UserAvatar(displayName: name, avatarUrl: avatar, radius: 72),
                ),
                const SizedBox(height: 24),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 32),
                  child: Text(
                    name,
                    textAlign: TextAlign.center,
                    style: GoogleFonts.inter(fontSize: 32, fontWeight: FontWeight.bold, color: Colors.black87),
                  ),
                ),
                const SizedBox(height: 12),
                Text(
                  'Calling...',
                  style: GoogleFonts.inter(fontSize: 16, color: Colors.black54, fontWeight: FontWeight.w500),
                ),

                const Spacer(flex: 2),
                Padding(
                  padding: const EdgeInsets.only(bottom: 60),
                  child: Column(
                    children: [
                      GestureDetector(
                        onTap: () => ref.read(callProvider.notifier).endCall(),
                        child: Container(
                          width: 72,
                          height: 72,
                          decoration: BoxDecoration(
                            color: const Color(0xFFFF3B30),
                            shape: BoxShape.circle,
                            boxShadow: [
                              BoxShadow(
                                color: Colors.red.withValues(alpha: 0.3),
                                blurRadius: 15,
                                offset: const Offset(0, 4),
                              ),
                            ],
                          ),
                          child: const Icon(Icons.call_end, color: Colors.white, size: 32),
                        ),
                      ),
                      const SizedBox(height: 12),
                      Text(
                        "Cancel",
                        style: GoogleFonts.inter(color: Colors.black54, fontWeight: FontWeight.w600, fontSize: 14),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/call/presentation/providers/call_repository_provider.dart
================================================================
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/call/data/datasources/call_remote_datasource_impl.dart';
import 'package:chattrix_ui/features/call/data/repositories/call_repository_impl.dart';
import 'package:chattrix_ui/features/call/domain/datasources/call_remote_datasource.dart';
import 'package:chattrix_ui/features/call/domain/repositories/call_repository.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

final callRemoteDataSourceProvider = Provider<CallRemoteDataSource>((ref) {
  final dio = ref.watch(dioProvider);
  return CallRemoteDataSourceImpl(dio: dio);
});

final callRepositoryProvider = Provider<CallRepository>((ref) {
  final remoteDataSource = ref.watch(callRemoteDataSourceProvider);
  return CallRepositoryImpl(remoteDataSource: remoteDataSource);
});

================================================================
FILE: lib/features/call/presentation/providers/call_service_provider.dart
================================================================
import 'package:chattrix_ui/features/call/services/agora_service.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

final agoraServiceProvider = Provider<AgoraService>((ref) {
  final service = AgoraService();
  ref.onDispose(() {
    service.dispose();
  });
  return service;
});

================================================================
FILE: lib/features/call/presentation/providers/call_usecase_provider.dart
================================================================
import 'package:chattrix_ui/features/call/domain/usecases/accept_call_usecase.dart';
import 'package:chattrix_ui/features/call/domain/usecases/end_call_usecase.dart';
import 'package:chattrix_ui/features/call/domain/usecases/initiate_call_usecase.dart';
import 'package:chattrix_ui/features/call/domain/usecases/reject_call_usecase.dart';
import 'package:chattrix_ui/features/call/presentation/providers/call_repository_provider.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

final initiateCallUseCaseProvider = Provider<InitiateCallUseCase>((ref) {
  final repository = ref.watch(callRepositoryProvider);
  return InitiateCallUseCase(repository);
});

final acceptCallUseCaseProvider = Provider<AcceptCallUseCase>((ref) {
  final repository = ref.watch(callRepositoryProvider);
  return AcceptCallUseCase(repository);
});

final rejectCallUseCaseProvider = Provider<RejectCallUseCase>((ref) {
  final repository = ref.watch(callRepositoryProvider);
  return RejectCallUseCase(repository);
});

final endCallUseCaseProvider = Provider<EndCallUseCase>((ref) {
  final repository = ref.watch(callRepositoryProvider);
  return EndCallUseCase(repository);
});

================================================================
FILE: lib/features/call/presentation/providers/call_websocket_provider.dart
================================================================
import 'package:chattrix_ui/core/network/websocket_providers.dart';
import 'package:chattrix_ui/features/call/data/datasources/call_websocket_datasource_impl.dart';
import 'package:chattrix_ui/features/call/domain/datasources/call_websocket_datasource.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

final callWebSocketDataSourceProvider = Provider<CallWebSocketDataSource>((ref) {
  final webSocketService = ref.watch(webSocketServiceProvider);

  final dataSource = CallWebSocketDataSourceImpl(webSocketService: webSocketService);

  ref.onDispose(() {
    dataSource.dispose();
  });

  return dataSource;
});

================================================================
FILE: lib/features/call/presentation/state/call_notifier.dart
================================================================
import 'dart:async';

import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/core/toast/toast_controller.dart';
import 'package:chattrix_ui/core/toast/toast_type.dart';
import 'package:chattrix_ui/core/utils/app_logger.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_accept.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_end.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_end_reason.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_invitation.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_reject.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_reject_reason.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';
import 'package:chattrix_ui/features/call/presentation/providers/call_service_provider.dart';
import 'package:chattrix_ui/features/call/presentation/providers/call_usecase_provider.dart';
import 'package:chattrix_ui/features/call/presentation/providers/call_websocket_provider.dart';
import 'package:chattrix_ui/features/call/presentation/state/call_state.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:wakelock_plus/wakelock_plus.dart';

part 'call_notifier.g.dart';

@riverpod
class CallNotifier extends _$CallNotifier {
  StreamSubscription? _incomingCallSubscription;
  StreamSubscription? _callAcceptedSubscription;
  StreamSubscription? _callRejectedSubscription;
  StreamSubscription? _callEndedSubscription;
  StreamSubscription? _callTimeoutSubscription;
  StreamSubscription? _userJoinedSubscription;
  StreamSubscription? _userOfflineSubscription;
  StreamSubscription? _remoteVideoStateSubscription;
  StreamSubscription? _remoteAudioStateSubscription;

  @override
  CallState build() {
    ref.keepAlive();

    _initializeListeners();

    ref.onDispose(() {
      _cleanup();
    });

    return const CallState.idle();
  }

  void _initializeListeners() {
    final wsDataSource = ref.watch(callWebSocketDataSourceProvider);
    final agoraService = ref.watch(agoraServiceProvider);

    _incomingCallSubscription = wsDataSource.incomingCallStream.listen(_handleIncomingCall);
    _callAcceptedSubscription = wsDataSource.callAcceptedStream.listen(_handleCallAccepted);
    _callRejectedSubscription = wsDataSource.callRejectedStream.listen(_handleCallRejected);
    _callEndedSubscription = wsDataSource.callEndedStream.listen(_handleCallEnded);
    _callTimeoutSubscription = wsDataSource.callTimeoutStream.listen(_handleCallTimeout);

    _userJoinedSubscription = agoraService.userJoinedStream.listen(_handleUserJoined);
    _userOfflineSubscription = agoraService.userOfflineStream.listen(_handleUserOffline);
    _remoteVideoStateSubscription = agoraService.remoteVideoStateStream.listen(_handleRemoteVideoStateChanged);
    _remoteAudioStateSubscription = agoraService.remoteAudioStateStream.listen(_handleRemoteAudioStateChanged);
  }

  void _cleanup() {
    _incomingCallSubscription?.cancel();
    _callAcceptedSubscription?.cancel();
    _callRejectedSubscription?.cancel();
    _callEndedSubscription?.cancel();
    _callTimeoutSubscription?.cancel();
    _userJoinedSubscription?.cancel();
    _userOfflineSubscription?.cancel();
    _remoteVideoStateSubscription?.cancel();
    _remoteAudioStateSubscription?.cancel();
    WakelockPlus.disable();
  }

  void _handleIncomingCall(CallInvitation invitation) {
    AppLogger.call('Handling incoming call: ${invitation.callId} from ${invitation.callerName}');
    state = CallState.ringing(invitation: invitation);
    AppLogger.call('State changed to RINGING');
  }

  void _handleCallAccepted(CallAccept accept) {
    AppLogger.call('Call accepted: ${accept.callId}');
    state.whenOrNull(
      connecting: (connection, callType, isOutgoing) {
        if (isOutgoing && connection.callInfo.id == accept.callId) {
          AppLogger.call('Waiting for callee to join Agora channel');
        }
      },
    );
  }

  void _handleCallRejected(CallReject reject) {
    AppLogger.call('Call rejected: ${reject.callId}, reason: ${reject.reason}');

    state.whenOrNull(
      connecting: (connection, callType, isOutgoing) {
        if (connection.callInfo.id == reject.callId) {
          AppLogger.call('Handling reject for matching call');
          _endCallCleanup();
          state = const CallState.ended(reason: 'Call was rejected');
        }
      },
    );
  }

  void _handleCallEnded(CallEnd end) {
    AppLogger.call('Call ended: ${end.callId}');

    final shouldHandle = state.when(
      idle: () => false,
      initiating: (_, __) => false,
      ringing: (invitation) => invitation.callId == end.callId,
      connecting: (connection, _, __) => connection.callInfo.id == end.callId,
      connected: (connection, p1, p2, p3, p4, p5, p6, p7, p8, p9) => connection.callInfo.id == end.callId,
      ended: (_) => false,
      error: (_) => false,
    );

    if (shouldHandle) {
      AppLogger.call('Handling end for matching call');
      _endCallCleanup();
      state = const CallState.ended(reason: 'Call ended');
    }
  }

  void _handleCallTimeout(timeout) {
    AppLogger.call('Call timeout: ${timeout.callId}');
    _endCallCleanup();
    state = CallState.ended(reason: 'Call timeout: ${timeout.reason}');
  }

  void _handleUserJoined(int remoteUid) {
    AppLogger.call('Remote user joined Agora: $remoteUid');
    state.whenOrNull(
      connecting: (connection, callType, isOutgoing) {
        state = CallState.connected(
          connection: connection,
          callType: callType,
          isOutgoing: isOutgoing,
          isMuted: false,
          isVideoEnabled: callType == CallType.video,
          isSpeakerEnabled: true,
          isFrontCamera: true,
          remoteUid: remoteUid,
          remoteIsMuted: false,
          remoteIsVideoEnabled: callType == CallType.video,
        );
        WakelockPlus.enable();
      },
    );
  }

  void _handleUserOffline(int remoteUid) {
    AppLogger.call('Remote user offline: $remoteUid');
    state.whenOrNull(
      connected:
          (
            connection,
            callType,
            isOutgoing,
            isMuted,
            isVideoEnabled,
            isSpeakerEnabled,
            isFrontCamera,
            currentRemoteUid,
            _,
            __,
          ) {
            if (currentRemoteUid == remoteUid) {
              _endCallCleanup();
              state = const CallState.ended(reason: 'Remote user left');
            }
          },
    );
  }

  void _handleRemoteVideoStateChanged(remoteVideoState) {
    AppLogger.call('Remote video state changed: uid=${remoteVideoState.uid}, state=${remoteVideoState.state}');

    state.whenOrNull(
      connected:
          (
            connection,
            callType,
            isOutgoing,
            isMuted,
            isVideoEnabled,
            isSpeakerEnabled,
            isFrontCamera,
            remoteUid,
            remoteIsMuted,
            remoteIsVideoEnabled,
          ) {
            if (remoteUid == remoteVideoState.uid) {
              final isRemoteVideoOn =
                  remoteVideoState.state == RemoteVideoState.remoteVideoStateDecoding ||
                  remoteVideoState.state == RemoteVideoState.remoteVideoStateStarting;

              state = CallState.connected(
                connection: connection,
                callType: callType,
                isOutgoing: isOutgoing,
                isMuted: isMuted,
                isVideoEnabled: isVideoEnabled,
                isSpeakerEnabled: isSpeakerEnabled,
                isFrontCamera: isFrontCamera,
                remoteUid: remoteUid,
                remoteIsMuted: remoteIsMuted,
                remoteIsVideoEnabled: isRemoteVideoOn,
              );

              AppLogger.call('Updated remote video state: $isRemoteVideoOn');
            }
          },
    );
  }

  void _handleRemoteAudioStateChanged(remoteAudioState) {
    AppLogger.call('Remote audio state changed: uid=${remoteAudioState.uid}, state=${remoteAudioState.state}');

    state.whenOrNull(
      connected:
          (
            connection,
            callType,
            isOutgoing,
            isMuted,
            isVideoEnabled,
            isSpeakerEnabled,
            isFrontCamera,
            remoteUid,
            remoteIsMuted,
            remoteIsVideoEnabled,
          ) {
            if (remoteUid == remoteAudioState.uid) {
              final isRemoteMuted =
                  remoteAudioState.state == RemoteAudioState.remoteAudioStateStopped ||
                  remoteAudioState.reason == RemoteAudioStateReason.remoteAudioReasonLocalMuted;

              state = CallState.connected(
                connection: connection,
                callType: callType,
                isOutgoing: isOutgoing,
                isMuted: isMuted,
                isVideoEnabled: isVideoEnabled,
                isSpeakerEnabled: isSpeakerEnabled,
                isFrontCamera: isFrontCamera,
                remoteUid: remoteUid,
                remoteIsMuted: isRemoteMuted,
                remoteIsVideoEnabled: remoteIsVideoEnabled,
              );

              AppLogger.call('Updated remote audio state: muted=$isRemoteMuted');
            }
          },
    );
  }

  Future<void> initiateCall(int calleeId, CallType callType) async {
    try {
      state = CallState.initiating(calleeId: calleeId, callType: callType);

      final usecase = ref.read(initiateCallUseCaseProvider);
      final result = await usecase.call(calleeId: calleeId, callType: callType);

      await result.fold(
        (failure) {
          final message = _getFailureMessage(failure);
          AppLogger.error('Failed to initiate call: $message', tag: 'Call');
          ref.read(toastControllerProvider).show(title: message, type: ToastType.error);
          state = CallState.error(message: message);
        },
        (connection) async {
          AppLogger.call('Call initiated successfully: ${connection.callInfo.id}');

          try {
            final agoraService = ref.read(agoraServiceProvider);
            await agoraService.initialize();
            await agoraService.joinChannel(
              token: connection.token,
              channelId: connection.callInfo.channelId,
              uid: connection.callInfo.callerId,
              isVideoCall: callType == CallType.video,
            );

            state = CallState.connecting(connection: connection, callType: callType, isOutgoing: true);
          } catch (agoraError, stack) {
            AppLogger.error('Agora error during call initiation', error: agoraError, stackTrace: stack, tag: 'Call');
            final errorMessage = 'Failed to join call. Please check your connection and try again.';
            ref.read(toastControllerProvider).show(title: errorMessage, type: ToastType.error);
            state = CallState.error(message: errorMessage);

            try {
              final endUsecase = ref.read(endCallUseCaseProvider);
              await endUsecase.call(callId: connection.callInfo.id, reason: CallEndReason.networkError);
            } catch (_) {}
          }
        },
      );
    } catch (e, stack) {
      AppLogger.error('Error initiating call', error: e, stackTrace: stack, tag: 'Call');
      final errorMessage = 'Failed to start call. Please try again.';
      ref.read(toastControllerProvider).show(title: errorMessage, type: ToastType.error);
      state = CallState.error(message: errorMessage);
    }
  }

  Future<void> acceptCall() async {
    await state.whenOrNull(
      ringing: (invitation) async {
        try {
          final usecase = ref.read(acceptCallUseCaseProvider);
          final result = await usecase.call(callId: invitation.callId);

          await result.fold(
            (failure) {
              final message = _getFailureMessage(failure);
              AppLogger.error('Failed to accept call: $message', tag: 'Call');
              ref.read(toastControllerProvider).show(title: message, type: ToastType.error);
              state = CallState.error(message: message);
            },
            (connection) async {
              AppLogger.call('Call accepted successfully: ${connection.callInfo.id}');

              try {
                final agoraService = ref.read(agoraServiceProvider);
                await agoraService.initialize();
                await agoraService.joinChannel(
                  token: connection.token,
                  channelId: connection.callInfo.channelId,
                  uid: connection.callInfo.calleeId,
                  isVideoCall: invitation.callType == CallType.video,
                );

                state = CallState.connecting(connection: connection, callType: invitation.callType, isOutgoing: false);
              } catch (agoraError, stack) {
                AppLogger.error(
                  'Agora error during call acceptance',
                  error: agoraError,
                  stackTrace: stack,
                  tag: 'Call',
                );
                final errorMessage = 'Failed to join call. Please check your connection and try again.';
                ref.read(toastControllerProvider).show(title: errorMessage, type: ToastType.error);
                state = CallState.error(message: errorMessage);

                try {
                  final endUsecase = ref.read(endCallUseCaseProvider);
                  await endUsecase.call(callId: connection.callInfo.id, reason: CallEndReason.networkError);
                } catch (_) {}
              }
            },
          );
        } catch (e, stack) {
          AppLogger.error('Error accepting call', error: e, stackTrace: stack, tag: 'Call');
          final errorMessage = 'Failed to accept call. Please try again.';
          ref.read(toastControllerProvider).show(title: errorMessage, type: ToastType.error);
          state = CallState.error(message: errorMessage);
        }
      },
    );
  }

  Future<void> rejectCall() async {
    await state.whenOrNull(
      ringing: (invitation) async {
        try {
          final usecase = ref.read(rejectCallUseCaseProvider);
          await usecase.call(callId: invitation.callId, reason: CallRejectReason.declined);

          state = const CallState.ended(reason: 'Call declined');
        } catch (e, stack) {
          AppLogger.error('Error rejecting call', error: e, stackTrace: stack, tag: 'Call');
          state = const CallState.ended(reason: 'Call declined');
        }
      },
    );
  }

  Future<void> endCall() async {
    final currentState = state;

    String? callId;
    currentState.whenOrNull(
      connecting: (connection, _, _) => callId = connection.callInfo.id,
      connected: (connection, p1, p2, p3, p4, p5, p6, p7, p8, p9) => callId = connection.callInfo.id,
    );

    if (callId != null) {
      try {
        final usecase = ref.read(endCallUseCaseProvider);
        await usecase.call(callId: callId!, reason: CallEndReason.hangup);
        AppLogger.call('Call ended and notified to backend: $callId');
      } catch (e, stack) {
        AppLogger.error('Error ending call', error: e, stackTrace: stack, tag: 'Call');
      }
    } else {
      AppLogger.call('Cancelling call during initiation (no callId yet)');
    }

    _endCallCleanup();
    state = const CallState.ended(reason: 'Call ended');
  }

  void _endCallCleanup() {
    final agoraService = ref.read(agoraServiceProvider);
    agoraService.leaveChannel();
    WakelockPlus.disable();
  }

  Future<void> toggleMute() async {
    state.whenOrNull(
      connected:
          (
            connection,
            callType,
            isOutgoing,
            isMuted,
            isVideoEnabled,
            isSpeakerEnabled,
            isFrontCamera,
            remoteUid,
            remoteIsMuted,
            remoteIsVideoEnabled,
          ) async {
            final agoraService = ref.read(agoraServiceProvider);
            await agoraService.toggleMute(!isMuted);

            state = CallState.connected(
              connection: connection,
              callType: callType,
              isOutgoing: isOutgoing,
              isMuted: !isMuted,
              isVideoEnabled: isVideoEnabled,
              isSpeakerEnabled: isSpeakerEnabled,
              isFrontCamera: isFrontCamera,
              remoteUid: remoteUid,
              remoteIsMuted: remoteIsMuted,
              remoteIsVideoEnabled: remoteIsVideoEnabled,
            );
          },
    );
  }

  Future<void> toggleVideo() async {
    state.whenOrNull(
      connected:
          (
            connection,
            callType,
            isOutgoing,
            isMuted,
            isVideoEnabled,
            isSpeakerEnabled,
            isFrontCamera,
            remoteUid,
            remoteIsMuted,
            remoteIsVideoEnabled,
          ) async {
            if (callType == CallType.video) {
              final agoraService = ref.read(agoraServiceProvider);
              await agoraService.toggleVideo(!isVideoEnabled);

              state = CallState.connected(
                connection: connection,
                callType: callType,
                isOutgoing: isOutgoing,
                isMuted: isMuted,
                isVideoEnabled: !isVideoEnabled,
                isSpeakerEnabled: isSpeakerEnabled,
                isFrontCamera: isFrontCamera,
                remoteUid: remoteUid,
                remoteIsMuted: remoteIsMuted,
                remoteIsVideoEnabled: remoteIsVideoEnabled,
              );
            }
          },
    );
  }

  Future<void> toggleSpeaker() async {
    state.whenOrNull(
      connected:
          (
            connection,
            callType,
            isOutgoing,
            isMuted,
            isVideoEnabled,
            isSpeakerEnabled,
            isFrontCamera,
            remoteUid,
            remoteIsMuted,
            remoteIsVideoEnabled,
          ) async {
            final agoraService = ref.read(agoraServiceProvider);
            await agoraService.toggleSpeaker(!isSpeakerEnabled);

            state = CallState.connected(
              connection: connection,
              callType: callType,
              isOutgoing: isOutgoing,
              isMuted: isMuted,
              isVideoEnabled: isVideoEnabled,
              isSpeakerEnabled: !isSpeakerEnabled,
              isFrontCamera: isFrontCamera,
              remoteUid: remoteUid,
              remoteIsMuted: remoteIsMuted,
              remoteIsVideoEnabled: remoteIsVideoEnabled,
            );
          },
    );
  }

  Future<void> switchCamera() async {
    state.whenOrNull(
      connected:
          (
            connection,
            callType,
            isOutgoing,
            isMuted,
            isVideoEnabled,
            isSpeakerEnabled,
            isFrontCamera,
            remoteUid,
            remoteIsMuted,
            remoteIsVideoEnabled,
          ) async {
            if (callType == CallType.video) {
              final agoraService = ref.read(agoraServiceProvider);
              await agoraService.switchCamera();

              state = CallState.connected(
                connection: connection,
                callType: callType,
                isOutgoing: isOutgoing,
                isMuted: isMuted,
                isVideoEnabled: isVideoEnabled,
                isSpeakerEnabled: isSpeakerEnabled,
                isFrontCamera: !isFrontCamera,
                remoteUid: remoteUid,
                remoteIsMuted: remoteIsMuted,
                remoteIsVideoEnabled: remoteIsVideoEnabled,
              );
            }
          },
    );
  }
  String _getFailureMessage(Failure failure) {
    return failure.when(
      server: (message, code, requestId) => message,
      network: (message, code) => message,
      validation: (message, code, details, requestId) => message,
      auth: (message, code, requestId) => message,
      notFound: (message, code, requestId) => message,
      conflict: (message, code, requestId) => message,
      rateLimit: (message, code, requestId) => message,
    );
  }
}

================================================================
FILE: lib/features/call/presentation/state/call_state.dart
================================================================
import 'package:chattrix_ui/features/call/domain/entities/call_connection.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_invitation.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'call_state.freezed.dart';

@freezed
class CallState with _$CallState {
  const CallState._();

  const factory CallState.idle() = _Idle;

  const factory CallState.initiating({required int calleeId, required CallType callType}) = _Initiating;

  const factory CallState.ringing({required CallInvitation invitation}) = _Ringing;

  const factory CallState.connecting({
    required CallConnection connection,
    required CallType callType,
    required bool isOutgoing,
  }) = _Connecting;

  const factory CallState.connected({
    required CallConnection connection,
    required CallType callType,
    required bool isOutgoing,
    required bool isMuted,
    required bool isVideoEnabled,
    required bool isSpeakerEnabled,
    required bool isFrontCamera,
    int? remoteUid,
    @Default(false) bool remoteIsMuted,
    @Default(true) bool remoteIsVideoEnabled,
  }) = _Connected;

  const factory CallState.ended({String? reason}) = _Ended;

  const factory CallState.error({required String message}) = _Error;
}

================================================================
FILE: lib/features/call/presentation/widgets/call_control_button.dart
================================================================
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class ModernCallButton extends StatelessWidget {
  final IconData icon;
  final String label;
  final VoidCallback onPressed;
  final bool isActive;
  final Color? activeColor;
  final Color? inactiveColor;
  final bool isDestructive;

  const ModernCallButton({
    super.key,
    required this.icon,
    required this.label,
    required this.onPressed,
    this.isActive = false,
    this.activeColor,
    this.inactiveColor,
    this.isDestructive = false,
  });

  @override
  Widget build(BuildContext context) {
    final backgroundColor = isDestructive
        ? const Color(0xFFFF3B30)
        : isActive
        ? (activeColor ?? const Color(0xFF2C2C2E))
        : (inactiveColor ?? const Color(0xFFF2F2F7));

    final iconColor = isDestructive
        ? Colors.white
        : isActive
        ? Colors.white
        : Colors.black;

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        GestureDetector(
          onTap: onPressed,
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 200),
            width: 64,
            height: 64,
            decoration: BoxDecoration(
              color: backgroundColor,
              shape: BoxShape.circle,
              boxShadow: isDestructive
                  ? [BoxShadow(color: Colors.red.withValues(alpha: 0.3), blurRadius: 10, offset: const Offset(0, 4))]
                  : [],
            ),
            child: Icon(icon, color: iconColor, size: 28),
          ),
        ),
        const SizedBox(height: 8),
        Text(
          label,
          style: GoogleFonts.inter(color: Colors.black54, fontSize: 12, fontWeight: FontWeight.w500),
        ),
      ],
    );
  }
}

================================================================
FILE: lib/features/call/presentation/widgets/call_controls_panel.dart
================================================================
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';
import 'package:chattrix_ui/features/call/presentation/state/call_notifier.dart';
import 'package:chattrix_ui/features/call/presentation/state/call_state.dart';
import 'package:chattrix_ui/features/call/presentation/widgets/call_control_button.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class CallControlsPanel extends ConsumerWidget {
  final CallType callType;

  const CallControlsPanel({super.key, required this.callType});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final callState = ref.watch(callProvider);

    return callState.when(
      idle: () => const SizedBox.shrink(),
      initiating: (_, _) => const SizedBox.shrink(),
      ringing: (_) => const SizedBox.shrink(),
      connecting: (_, _, _) => const SizedBox.shrink(),
      connected: (_, _, _, isMuted, isVideoEnabled, isSpeakerEnabled, _, _, _, _) {
        final isVideoCall = callType == CallType.video;

        return Container(
          padding: const EdgeInsets.fromLTRB(24, 24, 24, 40),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: const BorderRadius.vertical(top: Radius.circular(24)),
            boxShadow: [
              BoxShadow(color: Colors.black.withValues(alpha: 0.08), blurRadius: 20, offset: const Offset(0, -4)),
            ],
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              ModernCallButton(
                icon: isMuted ? Icons.mic_off : Icons.mic,
                label: "Mute",
                isActive: isMuted,
                onPressed: ref.read(callProvider.notifier).toggleMute,
              ),

              if (isVideoCall)
                ModernCallButton(
                  icon: isVideoEnabled ? Icons.videocam : Icons.videocam_off,
                  label: "Camera",
                  isActive: !isVideoEnabled,
                  onPressed: ref.read(callProvider.notifier).toggleVideo,
                ),

              if (isVideoCall)
                ModernCallButton(
                  icon: Icons.flip_camera_ios,
                  label: "Flip",
                  onPressed: ref.read(callProvider.notifier).switchCamera,
                ),

              ModernCallButton(
                icon: isSpeakerEnabled ? Icons.volume_up : Icons.volume_off,
                label: "Speaker",
                isActive: isSpeakerEnabled,
                activeColor: Colors.blue[100],
                onPressed: ref.read(callProvider.notifier).toggleSpeaker,
              ),

              ModernCallButton(
                icon: Icons.call_end,
                label: "End",
                isDestructive: true,
                onPressed: ref.read(callProvider.notifier).endCall,
              ),
            ],
          ),
        );
      },
      ended: (_) => const SizedBox.shrink(),
      error: (_) => const SizedBox.shrink(),
    );
  }
}

================================================================
FILE: lib/features/call/services/agora_service.dart
================================================================
import 'dart:async';
import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:chattrix_ui/core/utils/app_logger.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:permission_handler/permission_handler.dart';

class AgoraService {
  RtcEngine? _engine;
  bool _isInitialized = false;

  late final StreamController<int> _userJoinedController;
  late final StreamController<int> _userOfflineController;
  late final StreamController<ConnectionStateType> _connectionStateController;
  late final StreamController<RemoteVideoStateInfo> _remoteVideoStateController;
  late final StreamController<RemoteAudioStateInfo> _remoteAudioStateController;

  AgoraService() {
    _userJoinedController = StreamController<int>.broadcast();
    _userOfflineController = StreamController<int>.broadcast();
    _connectionStateController = StreamController<ConnectionStateType>.broadcast();
    _remoteVideoStateController = StreamController<RemoteVideoStateInfo>.broadcast();
    _remoteAudioStateController = StreamController<RemoteAudioStateInfo>.broadcast();
  }

  Stream<int> get userJoinedStream => _userJoinedController.stream;
  Stream<int> get userOfflineStream => _userOfflineController.stream;
  Stream<ConnectionStateType> get connectionStateStream => _connectionStateController.stream;
  Stream<RemoteVideoStateInfo> get remoteVideoStateStream => _remoteVideoStateController.stream;
  Stream<RemoteAudioStateInfo> get remoteAudioStateStream => _remoteAudioStateController.stream;

  bool get isInitialized => _isInitialized;

  Future<void> initialize() async {
    if (_isInitialized) {
      AppLogger.warning('Agora Engine already initialized', tag: 'Agora');
      return;
    }

    try {
      AppLogger.info('Initializing Agora Service...', tag: 'Agora');

      final appId = dotenv.env['AGORA_APP_ID'];
      if (appId == null || appId.isEmpty) {
        throw Exception('AGORA_APP_ID not found in environment');
      }

      await _requestPermissions();

      _engine = createAgoraRtcEngine();
      await _engine!.initialize(
        RtcEngineContext(appId: appId, channelProfile: ChannelProfileType.channelProfileCommunication),
      );

      _registerEventHandlers();

      await _engine!.enableVideo();
      await _engine!.startPreview();
      await _engine!.setDefaultAudioRouteToSpeakerphone(true);

      _isInitialized = true;
      AppLogger.success('Agora RTC Engine initialized successfully', tag: 'Agora');
    } catch (e, stack) {
      AppLogger.error('Failed to initialize Agora', error: e, stackTrace: stack, tag: 'Agora');
      rethrow;
    }
  }

  Future<void> _requestPermissions() async {
    final status = await [Permission.camera, Permission.microphone].request();

    if (status[Permission.camera] != PermissionStatus.granted ||
        status[Permission.microphone] != PermissionStatus.granted) {
      AppLogger.warning('Camera or Microphone permission denied', tag: 'Agora');
    }
  }

  void _registerEventHandlers() {
    _engine!.registerEventHandler(
      RtcEngineEventHandler(
        onJoinChannelSuccess: (RtcConnection connection, int elapsed) {
          AppLogger.success('Joined channel: ${connection.channelId}', tag: 'Agora');
        },
        onUserJoined: (RtcConnection connection, int remoteUid, int elapsed) {
          AppLogger.info('Remote user joined: $remoteUid', tag: 'Agora');
          _userJoinedController.add(remoteUid);
        },
        onUserOffline: (RtcConnection connection, int remoteUid, UserOfflineReasonType reason) {
          AppLogger.info('Remote user offline: $remoteUid ($reason)', tag: 'Agora');
          _userOfflineController.add(remoteUid);
        },
        onConnectionStateChanged:
            (RtcConnection connection, ConnectionStateType state, ConnectionChangedReasonType reason) {
              AppLogger.info('Connection state: $state ($reason)', tag: 'Agora');
              _connectionStateController.add(state);
            },
        onRemoteVideoStateChanged:
            (
              RtcConnection connection,
              int remoteUid,
              RemoteVideoState state,
              RemoteVideoStateReason reason,
              int elapsed,
            ) {
              _remoteVideoStateController.add(RemoteVideoStateInfo(uid: remoteUid, state: state, reason: reason));
            },
        onRemoteAudioStateChanged:
            (
              RtcConnection connection,
              int remoteUid,
              RemoteAudioState state,
              RemoteAudioStateReason reason,
              int elapsed,
            ) {
              _remoteAudioStateController.add(RemoteAudioStateInfo(uid: remoteUid, state: state, reason: reason));
            },
        onError: (ErrorCodeType err, String msg) {
          AppLogger.error('Agora Internal Error: $err - $msg', tag: 'Agora');
        },
      ),
    );
  }

  Future<void> joinChannel({
    required String token,
    required String channelId,
    required int uid,
    required bool isVideoCall,
  }) async {
    if (!_isInitialized || _engine == null) {
      AppLogger.error('Attempted to join channel before initialization', tag: 'Agora');
      return;
    }

    try {
      if (isVideoCall) {
        await _engine!.enableLocalVideo(true);
        await _engine!.startPreview();
      } else {
        await _engine!.enableLocalVideo(false);
      }

      await _engine!.joinChannel(
        token: token,
        channelId: channelId,
        uid: uid,
        options: const ChannelMediaOptions(
          channelProfile: ChannelProfileType.channelProfileCommunication,
          clientRoleType: ClientRoleType.clientRoleBroadcaster,
          autoSubscribeAudio: true,
          autoSubscribeVideo: true,
        ),
      );

      AppLogger.info('Joining channel $channelId as uid: $uid', tag: 'Agora');
    } catch (e, stack) {
      AppLogger.error('Failed to join channel', error: e, stackTrace: stack, tag: 'Agora');
      rethrow;
    }
  }

  Future<void> leaveChannel() async {
    if (_engine == null) return;
    try {
      await _engine!.leaveChannel();
      await _engine!.stopPreview();
      AppLogger.info('Left channel', tag: 'Agora');
    } catch (e) {
      AppLogger.error('Error leaving channel: $e', tag: 'Agora');
    }
  }

  Future<void> toggleMute(bool mute) async {
    if (_engine == null) return;
    await _engine!.muteLocalAudioStream(mute);
    AppLogger.info('Microphone ${mute ? 'muted' : 'unmuted'}', tag: 'Agora');
  }

  Future<void> toggleVideo(bool enable) async {
    if (_engine == null) return;

    await _engine!.enableLocalVideo(enable);

    if (enable) {
      await _engine!.startPreview();
    } else {
      await _engine!.stopPreview();
    }
    AppLogger.info('Camera ${enable ? 'enabled' : 'disabled'}', tag: 'Agora');
  }

  Future<void> toggleSpeaker(bool enable) async {
    if (_engine == null) return;
    await _engine!.setEnableSpeakerphone(enable);
    AppLogger.info('Speaker ${enable ? 'enabled' : 'disabled'}', tag: 'Agora');
  }

  Future<void> switchCamera() async {
    if (_engine == null) return;
    try {
      await _engine!.switchCamera();
      AppLogger.info('Camera switched', tag: 'Agora');
    } catch (e) {
      AppLogger.error('Failed to switch camera: $e', tag: 'Agora');
    }
  }

  Future<void> dispose() async {
    try {
      await leaveChannel();
      if (_engine != null) {
        await _engine!.release();
        _engine = null;
      }
      _disposeControllers();
      _isInitialized = false;
      AppLogger.success('Agora service disposed', tag: 'Agora');
    } catch (e) {
      AppLogger.error('Error disposing Agora service: $e', tag: 'Agora');
    }
  }

  void _disposeControllers() {
    _userJoinedController.close();
    _userOfflineController.close();
    _connectionStateController.close();
    _remoteVideoStateController.close();
    _remoteAudioStateController.close();
  }

  RtcEngine? get engine => _engine;
}

class RemoteVideoStateInfo {
  final int uid;
  final RemoteVideoState state;
  final RemoteVideoStateReason reason;

  RemoteVideoStateInfo({required this.uid, required this.state, required this.reason});
}

class RemoteAudioStateInfo {
  final int uid;
  final RemoteAudioState state;
  final RemoteAudioStateReason reason;

  RemoteAudioStateInfo({required this.uid, required this.state, required this.reason});
}

================================================================
FILE: lib/features/chat/data/datasources/chat_remote_datasource_impl.dart
================================================================
import 'package:chattrix_ui/core/constants/api_constants.dart';
import 'package:chattrix_ui/core/domain/enums/conversation_filter.dart';
import 'package:chattrix_ui/core/errors/exceptions.dart';
import 'package:chattrix_ui/core/utils/app_logger.dart';
import 'package:chattrix_ui/features/auth/data/models/user_dto.dart';
import 'package:chattrix_ui/features/chat/data/models/conversation_model.dart';
import 'package:chattrix_ui/features/chat/data/models/message_model.dart';
import 'package:chattrix_ui/features/chat/data/models/search_user_model.dart';
import 'package:chattrix_ui/features/chat/data/models/user_status_model.dart';
import 'package:chattrix_ui/features/chat/domain/datasources/chat_remote_datasource.dart';
import 'package:dio/dio.dart';

class ChatRemoteDatasourceImpl implements ChatRemoteDatasource {
  final Dio dio;

  ChatRemoteDatasourceImpl({required this.dio});

  @override
  Future<ConversationModel> createConversation({
    String? name,
    required String type,
    required List<String> participantIds,
  }) async {
    try {
      final response = await dio.post(
        ApiConstants.conversations,
        data: {if (name != null) 'name': name, 'type': type, 'participantIds': participantIds},
      );

      if (response.statusCode == 201) {
        final data = response.data['data'] as Map<String, dynamic>;
        return ConversationModel.fromApi(data);
      }

      throw ServerException(message: 'Failed to create conversation');
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Failed to create conversation');
    }
  }

  @override
  Future<List<ConversationModel>> getConversations({ConversationFilter filter = ConversationFilter.all}) async {
    try {
      AppLogger.debug('üì° Fetching conversations from API with filter: $filter', tag: 'ChatRemoteDataSource');
      String? filterParam;
      switch (filter) {
        case ConversationFilter.all:
          filterParam = 'all';
          break;
        case ConversationFilter.unread:
          filterParam = 'unread';
          break;
        case ConversationFilter.groups:
          filterParam = 'group';
          break;
      }

      final response = await dio.get(ApiConstants.conversations, queryParameters: {'filter': filterParam});

      AppLogger.debug('üì• Conversations API Response - Status: ${response.statusCode}', tag: 'ChatRemoteDataSource');

      if (response.statusCode == 200) {
        final paginatedData = response.data['data'] as Map<String, dynamic>;
        final conversationsData = paginatedData['data'] as List;

        AppLogger.info('‚úÖ Successfully fetched ${conversationsData.length} conversations', tag: 'ChatRemoteDataSource');

        return conversationsData
            .whereType<Map<String, dynamic>>()
            .map((json) => ConversationModel.fromApi(json))
            .toList();
      }

      throw ServerException(message: 'Failed to fetch conversations');
    } on DioException catch (e) {
      AppLogger.error('‚ùå Failed to fetch conversations - DioException', error: e, tag: 'ChatRemoteDataSource');
      AppLogger.debug(
        'Status Code: ${e.response?.statusCode}, Message: ${e.response?.data}',
        tag: 'ChatRemoteDataSource',
      );
      throw ServerException(message: e.response?.data['message'] ?? 'Failed to fetch conversations');
    } catch (e) {
      AppLogger.error('‚ùå Failed to fetch conversations - Unexpected error', error: e, tag: 'ChatRemoteDataSource');
      throw ServerException(message: 'Failed to fetch conversations: $e');
    }
  }

  @override
  Future<ConversationModel> getConversation(String conversationId) async {
    try {
      final response = await dio.get(ApiConstants.conversationById(conversationId));

      if (response.statusCode == 200) {
        final data = response.data['data'] as Map<String, dynamic>;
        return ConversationModel.fromApi(data);
      }

      throw ServerException(message: 'Failed to fetch conversation');
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Failed to fetch conversation');
    }
  }

  @override
  Future<List<MessageModel>> getMessages({
    required String conversationId,
    int page = 0,
    int size = 50,
    String sort = 'DESC',
  }) async {
    try {
      final url = ApiConstants.messagesInConversation(conversationId);

      final response = await dio.get(url, queryParameters: {'page': page, 'size': size, 'sort': sort});

      if (response.statusCode == 200) {
        final data = response.data['data'] as List;

        return data.whereType<Map<String, dynamic>>().map((json) => MessageModel.fromApi(json)).toList();
      }

      throw ServerException(message: 'Failed to fetch messages');
    } on DioException catch (e) {
      if (e.response?.statusCode == 500) {
        return []; // Return empty list instead of crashing
      }

      throw ServerException(message: e.response?.data['message'] ?? 'Failed to fetch messages');
    } catch (e) {
      throw ServerException(message: 'Failed to fetch messages: $e');
    }
  }

  @override
  Future<List<UserDto>> getOnlineUsers() async {
    try {
      final response = await dio.get(ApiConstants.onlineUsers);

      if (response.statusCode == 200) {
        final data = response.data['data'] as List;
        return data.map((json) => UserDto.fromJson(json)).toList();
      }

      throw ServerException(message: 'Failed to fetch online users');
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Failed to fetch online users');
    }
  }

  @override
  Future<List<UserDto>> getOnlineUsersInConversation(String conversationId) async {
    try {
      final response = await dio.get(ApiConstants.onlineUsersInConversation(conversationId));

      if (response.statusCode == 200) {
        final data = response.data['data'] as List;
        return data.map((json) => UserDto.fromJson(json)).toList();
      }

      throw ServerException(message: 'Failed to fetch online users in conversation');
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Failed to fetch online users in conversation');
    }
  }

  @override
  Future<UserStatusModel> getUserStatus(String userId) async {
    try {
      final response = await dio.get(ApiConstants.userStatus(userId));

      if (response.statusCode == 200) {
        final data = response.data['data'];
        return UserStatusModel.fromJson(data);
      }

      throw ServerException(message: 'Failed to fetch user status');
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Failed to fetch user status');
    }
  }

  @override
  Future<MessageModel> sendMessage({
    required String conversationId,
    required String content,
    String? type,
    String? mediaUrl,
    String? thumbnailUrl,
    String? fileName,
    int? fileSize,
    int? duration,
    double? latitude,
    double? longitude,
    String? locationName,
    int? replyToMessageId,
    String? mentions,
  }) async {
    try {
      final data = <String, dynamic>{
        'content': content,
        if (type != null) 'type': type,
        if (mediaUrl != null) 'mediaUrl': mediaUrl,
        if (thumbnailUrl != null) 'thumbnailUrl': thumbnailUrl,
        if (fileName != null) 'fileName': fileName,
        if (fileSize != null) 'fileSize': fileSize,
        if (duration != null) 'duration': duration,
        if (latitude != null) 'latitude': latitude,
        if (longitude != null) 'longitude': longitude,
        if (locationName != null) 'locationName': locationName,
        if (replyToMessageId != null) 'replyToMessageId': replyToMessageId,
        if (mentions != null) 'mentions': mentions,
      };

      final url = ApiConstants.messagesInConversation(conversationId);

      final response = await dio.post(url, data: data);

      if (response.statusCode == 201) {
        final responseData = response.data['data'] as Map<String, dynamic>;
        return MessageModel.fromApi(responseData);
      }

      throw ServerException(message: 'Failed to send message');
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Failed to send message');
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<List<SearchUserModel>> searchUsers({required String query, int limit = 20}) async {
    try {
      final url = ApiConstants.searchUsers;

      final response = await dio.get(url, queryParameters: {'query': query, 'limit': limit});

      if (response.statusCode == 200) {
        final data = response.data['data'] as List;

        return data.whereType<Map<String, dynamic>>().map((json) => SearchUserModel.fromJson(json)).toList();
      }

      throw ServerException(message: 'Failed to search users');
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Failed to search users');
    } catch (e) {
      throw ServerException(message: 'Failed to search users: $e');
    }
  }

  @override
  Future<List<ConversationModel>> searchConversations({required String query}) async {
    try {
      AppLogger.debug('üîç Searching conversations with query: $query', tag: 'ChatRemoteDataSource');

      final response = await dio.get(ApiConstants.conversations, queryParameters: {'search': query});

      AppLogger.debug('üì• Search API Response - Status: ${response.statusCode}', tag: 'ChatRemoteDataSource');

      if (response.statusCode == 200) {
        final paginatedData = response.data['data'] as Map<String, dynamic>;
        final conversationsData = paginatedData['data'] as List;

        AppLogger.info('‚úÖ Found ${conversationsData.length} conversations matching query', tag: 'ChatRemoteDataSource');

        return conversationsData
            .whereType<Map<String, dynamic>>()
            .map((json) => ConversationModel.fromApi(json))
            .toList();
      }

      throw ServerException(message: 'Failed to search conversations');
    } on DioException catch (e) {
      AppLogger.error('‚ùå Failed to search conversations - DioException', error: e, tag: 'ChatRemoteDataSource');
      throw ServerException(message: e.response?.data['message'] ?? 'Failed to search conversations');
    } catch (e) {
      AppLogger.error('‚ùå Failed to search conversations - Unexpected error', error: e, tag: 'ChatRemoteDataSource');
      throw ServerException(message: 'Failed to search conversations: $e');
    }
  }

  @override
  Future<Map<String, dynamic>> toggleReaction({required String messageId, required String emoji}) async {
    try {
      final url = ApiConstants.messageReactions(messageId);

      final response = await dio.post(url, data: {'emoji': emoji});

      if (response.statusCode == 200) {
        return response.data['data'] as Map<String, dynamic>;
      }

      throw ServerException(message: 'Failed to toggle reaction');
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Failed to toggle reaction');
    } catch (e) {
      throw ServerException(message: 'Failed to toggle reaction: $e');
    }
  }

  @override
  Future<Map<String, dynamic>> getReactions(String messageId) async {
    try {
      final url = ApiConstants.messageReactions(messageId);

      final response = await dio.get(url);

      if (response.statusCode == 200) {
        return response.data['data'] as Map<String, dynamic>;
      }

      throw ServerException(message: 'Failed to get reactions');
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Failed to get reactions');
    } catch (e) {
      throw ServerException(message: 'Failed to get reactions: $e');
    }
  }

  @override
  Future<MessageModel> editMessage({required String messageId, required String content}) async {
    try {
      final url = ApiConstants.messageEdit(messageId);

      final response = await dio.put(url, data: {'content': content});

      if (response.statusCode == 200) {
        final data = response.data['data'] as Map<String, dynamic>;
        return MessageModel.fromApi(data);
      }

      throw ServerException(message: 'Failed to edit message');
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Failed to edit message');
    } catch (e) {
      throw ServerException(message: 'Failed to edit message: $e');
    }
  }

  @override
  Future<void> deleteMessage(String messageId) async {
    try {
      final url = ApiConstants.messageDelete(messageId);

      final response = await dio.delete(url);

      if (response.statusCode == 200 || response.statusCode == 204) {
        return;
      }

      throw ServerException(message: 'Failed to delete message');
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['message'] ?? 'Failed to delete message');
    } catch (e) {
      throw ServerException(message: 'Failed to delete message: $e');
    }
  }
}

================================================================
FILE: lib/features/chat/data/datasources/chat_websocket_datasource_impl.dart
================================================================
import 'dart:async';

import 'package:chattrix_ui/core/network/websocket_service.dart';
import 'package:chattrix_ui/core/utils/app_logger.dart';
import 'package:chattrix_ui/features/chat/data/models/message_model.dart';
import 'package:chattrix_ui/features/chat/data/models/conversation_update_model.dart';
import 'package:chattrix_ui/features/chat/data/models/typing_indicator_model.dart';
import 'package:chattrix_ui/features/chat/data/models/user_status_update_model.dart';
import 'package:chattrix_ui/features/chat/domain/datasources/chat_websocket_datasource.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation_update.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/domain/entities/typing_indicator.dart';
import 'package:chattrix_ui/features/chat/domain/entities/user_status_update.dart';
class _ChatWebSocketEvent {
  static const String chatMessage = 'chat.message';
  static const String typingStart = 'typing.start';
  static const String typingStop = 'typing.stop';
}
class _ChatWebSocketResponse {
  static const String chatMessage = 'chat.message';
  static const String typingIndicator = 'typing.indicator';
  static const String userStatus = 'user.status';
  static const String conversationUpdate = 'conversation.update';
}
class ChatWebSocketDataSourceImpl implements ChatWebSocketDataSource {
  final WebSocketService _webSocketService;
  StreamSubscription<Map<String, dynamic>>? _subscription;
  final _messageController = StreamController<Message>.broadcast();
  final _typingController = StreamController<TypingIndicator>.broadcast();
  final _userStatusController = StreamController<UserStatusUpdate>.broadcast();
  final _conversationUpdateController = StreamController<ConversationUpdate>.broadcast();

  ChatWebSocketDataSourceImpl({required WebSocketService webSocketService}) : _webSocketService = webSocketService {
    _startListening();
  }

  void _startListening() {
    final chatMessageTypes = [
      _ChatWebSocketResponse.chatMessage,
      _ChatWebSocketResponse.typingIndicator,
      _ChatWebSocketResponse.userStatus,
      _ChatWebSocketResponse.conversationUpdate,
    ];

    _subscription = _webSocketService.messageRouter
        .getStreamForTypes(chatMessageTypes)
        .listen(
          _handleMessage,
          onError: (error, stackTrace) {
            AppLogger.error(
              'WebSocket message stream error',
              error: error,
              stackTrace: stackTrace,
              tag: 'ChatWebSocketDataSource',
            );
          },
        );

    AppLogger.debug('Started listening for chat events', tag: 'ChatWebSocketDataSource');
  }

  void _handleMessage(Map<String, dynamic> message) {
    try {
      final type = message['type'] as String?;
      if (type == null) {
        AppLogger.warning('Received message without type field', tag: 'ChatWebSocketDataSource');
        return;
      }

      final payload = message['payload'] ?? message['data'];
      if (payload == null) {
        AppLogger.warning(
          'Received message without payload/data field for type: $type',
          tag: 'ChatWebSocketDataSource',
        );
        return;
      }

      AppLogger.debug('Processing WebSocket message: $type', tag: 'ChatWebSocketDataSource');

      switch (type) {
        case _ChatWebSocketResponse.chatMessage:
          try {
            final messageEntity = MessageModel.fromApi(payload as Map<String, dynamic>).toEntity();
            _messageController.add(messageEntity);
            AppLogger.debug('Successfully processed chat message', tag: 'ChatWebSocketDataSource');
          } catch (e, st) {
            AppLogger.error('Failed to parse chat message', error: e, stackTrace: st, tag: 'ChatWebSocketDataSource');
          }
          break;

        case _ChatWebSocketResponse.typingIndicator:
          try {
            final indicatorEntity = TypingIndicatorModel.fromJson(payload as Map<String, dynamic>).toEntity();
            _typingController.add(indicatorEntity);
            AppLogger.debug(
              'Typing indicator: conversationId=${indicatorEntity.conversationId}, users=${indicatorEntity.typingUsers.length}',
              tag: 'ChatWebSocketDataSource',
            );
          } catch (e, st) {
            AppLogger.error(
              'Failed to parse typing indicator',
              error: e,
              stackTrace: st,
              tag: 'ChatWebSocketDataSource',
            );
          }
          break;

        case _ChatWebSocketResponse.userStatus:
          try {
            final statusEntity = UserStatusUpdateModel.fromJson(payload as Map<String, dynamic>).toEntity();
            _userStatusController.add(statusEntity);
            AppLogger.debug('User status update: userId=${statusEntity.userId}', tag: 'ChatWebSocketDataSource');
          } catch (e, st) {
            AppLogger.error(
              'Failed to parse user status update',
              error: e,
              stackTrace: st,
              tag: 'ChatWebSocketDataSource',
            );
          }
          break;

        case _ChatWebSocketResponse.conversationUpdate:
          try {
            final updateEntity = ConversationUpdateModel.fromJson(payload as Map<String, dynamic>).toEntity();
            _conversationUpdateController.add(updateEntity);
            AppLogger.debug(
              'Conversation update: conversationId=${updateEntity.conversationId}',
              tag: 'ChatWebSocketDataSource',
            );
          } catch (e, st) {
            AppLogger.error(
              'Failed to parse conversation update',
              error: e,
              stackTrace: st,
              tag: 'ChatWebSocketDataSource',
            );
          }
          break;

        default:
          AppLogger.warning('Unknown message type: $type', tag: 'ChatWebSocketDataSource');
      }
    } catch (e, stackTrace) {
      AppLogger.error(
        'Unexpected error handling WebSocket message',
        error: e,
        stackTrace: stackTrace,
        tag: 'ChatWebSocketDataSource',
      );
    }
  }

  @override
  Future<void> connect(String accessToken) async {
    AppLogger.debug('Connect called (handled by WebSocketService)', tag: 'ChatWebSocketDataSource');
  }

  @override
  Future<void> disconnect() async {
    AppLogger.debug('Disconnect called (handled by WebSocketService)', tag: 'ChatWebSocketDataSource');
  }

  @override
  void sendMessage({required String conversationId, required String content, int? replyToMessageId}) {
    final payload = {
      'type': _ChatWebSocketEvent.chatMessage,
      'payload': {
        'conversationId': conversationId,
        'content': content,
        if (replyToMessageId != null) 'replyToMessageId': replyToMessageId,
      },
    };

    _webSocketService.send(payload);
  }

  @override
  void sendTypingStart(String conversationId) {
    final payload = {
      'type': _ChatWebSocketEvent.typingStart,
      'payload': {'conversationId': conversationId},
    };

    _webSocketService.send(payload);
  }

  @override
  void sendTypingStop(String conversationId) {
    final payload = {
      'type': _ChatWebSocketEvent.typingStop,
      'payload': {'conversationId': conversationId},
    };

    _webSocketService.send(payload);
  }

  @override
  void sendGenericMessage(Map<String, dynamic> payload) {
    _webSocketService.send(payload);
  }

  @override
  Stream<Message> get messageStream => _messageController.stream;

  @override
  Stream<TypingIndicator> get typingStream => _typingController.stream;

  @override
  Stream<UserStatusUpdate> get userStatusStream => _userStatusController.stream;

  @override
  Stream<ConversationUpdate> get conversationUpdateStream => _conversationUpdateController.stream;

  @override
  Stream<bool> get connectionStream => _webSocketService.connectionStream;

  @override
  Stream<Map<String, dynamic>> get rawMessageStream => _webSocketService.messageRouter.rawMessageStream;

  @override
  bool get isConnected => _webSocketService.isConnected;

  @override
  void dispose() {
    _subscription?.cancel();
    _messageController.close();
    _typingController.close();
    _userStatusController.close();
    _conversationUpdateController.close();
  }
}

================================================================
FILE: lib/features/chat/data/models/conversation_model.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/enums.dart';
import 'package:chattrix_ui/features/chat/data/models/message_model.dart';
import 'package:chattrix_ui/features/chat/data/models/participant_model.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'conversation_model.freezed.dart';
part 'conversation_model.g.dart';

@freezed
abstract class ConversationModel with _$ConversationModel {
  const ConversationModel._();

  const factory ConversationModel({
    required int id,
    String? name,
    required String type,
    String? avatarUrl,
    required String createdAt,
    required String updatedAt,
    required List<ParticipantModel> participants,
    MessageModel? lastMessage,
    @Default(0) int unreadCount,
  }) = _ConversationModel;

  factory ConversationModel.fromJson(Map<String, dynamic> json) => _$ConversationModelFromJson(json);

  factory ConversationModel.fromApi(Map<String, dynamic> json) {
    final participantsJson = (json['participants'] as List? ?? []).whereType<Map<String, dynamic>>().toList();

    final lastMessageJson = json['lastMessage'];
    MessageModel? lastMessageModel;
    if (lastMessageJson != null && lastMessageJson is Map<String, dynamic>) {
      lastMessageModel = MessageModel.fromApi(lastMessageJson);
    }

    return ConversationModel(
      id: (json['id'] ?? json['conversationId'] ?? 0) is int
          ? (json['id'] ?? json['conversationId'] ?? 0)
          : int.tryParse((json['id'] ?? json['conversationId'] ?? 0).toString()) ?? 0,
      name: (json['name'] ?? json['title'])?.toString(),
      type: (json['type'] ?? '').toString(),
      avatarUrl: json['avatarUrl']?.toString(),
      createdAt: (json['createdAt'] ?? json['created_at'] ?? '').toString(),
      updatedAt: (json['updatedAt'] ?? json['updated_at'] ?? '').toString(),
      participants: participantsJson.map((p) => ParticipantModel.fromApi(p)).toList(),
      lastMessage: lastMessageModel,
      unreadCount: json['unreadCount'] ?? 0,
    );
  }

  Conversation toEntity() {
    final conversationType = type.toUpperCase() == 'DIRECT' ? ConversationType.direct : ConversationType.group;

    return Conversation(
      id: id,
      name: name,
      type: conversationType,
      avatarUrl: avatarUrl,
      createdAt: DateTime.parse(createdAt),
      updatedAt: DateTime.parse(updatedAt),
      participants: participants.map((p) => p.toEntity()).toList(),
      lastMessage: lastMessage?.toEntity(),
      unreadCount: unreadCount,
    );
  }
}

================================================================
FILE: lib/features/chat/data/models/conversation_update_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'conversation_update_dto.freezed.dart';
part 'conversation_update_dto.g.dart';
@freezed
abstract class ConversationUpdateDto with _$ConversationUpdateDto {
  const factory ConversationUpdateDto({
    required int conversationId,
    required String updatedAt,
    LastMessageInfoDto? lastMessage,
  }) = _ConversationUpdateDto;

  factory ConversationUpdateDto.fromJson(Map<String, dynamic> json) => _$ConversationUpdateDtoFromJson(json);
}

@freezed
abstract class LastMessageInfoDto with _$LastMessageInfoDto {
  const factory LastMessageInfoDto({
    required int id,
    required String content,
    required int senderId,
    required String senderUsername,
    required String sentAt,
    required String type,
  }) = _LastMessageInfoDto;

  factory LastMessageInfoDto.fromJson(Map<String, dynamic> json) => _$LastMessageInfoDtoFromJson(json);
}

================================================================
FILE: lib/features/chat/data/models/conversation_update_model.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/conversation_update.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'conversation_update_model.freezed.dart';
part 'conversation_update_model.g.dart';

@freezed
abstract class ConversationUpdateModel with _$ConversationUpdateModel {
  const ConversationUpdateModel._();

  const factory ConversationUpdateModel({
    required int conversationId,
    required String updatedAt,
    LastMessageInfoModel? lastMessage,
  }) = _ConversationUpdateModel;

  factory ConversationUpdateModel.fromJson(Map<String, dynamic> json) => _$ConversationUpdateModelFromJson(json);

  ConversationUpdate toEntity() {
    return ConversationUpdate(
      conversationId: conversationId,
      updatedAt: updatedAt,
      lastMessage: lastMessage?.toEntity(),
    );
  }
}

@freezed
abstract class LastMessageInfoModel with _$LastMessageInfoModel {
  const LastMessageInfoModel._();

  const factory LastMessageInfoModel({
    required int id,
    required String content,
    required int senderId,
    required String senderUsername,
    required String sentAt,
    required String type,
  }) = _LastMessageInfoModel;

  factory LastMessageInfoModel.fromJson(Map<String, dynamic> json) => _$LastMessageInfoModelFromJson(json);

  LastMessageInfo toEntity() {
    return LastMessageInfo(
      id: id,
      content: content,
      senderId: senderId,
      senderUsername: senderUsername,
      sentAt: sentAt,
      type: type,
    );
  }
}

================================================================
FILE: lib/features/chat/data/models/mentioned_user_model.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/mentioned_user.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'mentioned_user_model.freezed.dart';
part 'mentioned_user_model.g.dart';

@freezed
abstract class MentionedUserModel with _$MentionedUserModel {
  const MentionedUserModel._();

  const factory MentionedUserModel({required int userId, required String username, required String fullName}) =
      _MentionedUserModel;

  factory MentionedUserModel.fromJson(Map<String, dynamic> json) => _$MentionedUserModelFromJson(json);

  MentionedUser toEntity() {
    return MentionedUser(userId: userId, username: username, fullName: fullName);
  }
}

================================================================
FILE: lib/features/chat/data/models/message_delete_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'message_delete_dto.freezed.dart';
part 'message_delete_dto.g.dart';
@freezed
abstract class MessageDeleteDto with _$MessageDeleteDto {
  const factory MessageDeleteDto({required int messageId, required int conversationId}) = _MessageDeleteDto;

  factory MessageDeleteDto.fromJson(Map<String, dynamic> json) => _$MessageDeleteDtoFromJson(json);
}

================================================================
FILE: lib/features/chat/data/models/message_model.dart
================================================================
import 'dart:convert';
import 'package:chattrix_ui/features/chat/data/models/mentioned_user_model.dart';
import 'package:chattrix_ui/features/chat/data/models/message_sender_model.dart';
import 'package:chattrix_ui/features/chat/data/models/read_receipt_model.dart';
import 'package:chattrix_ui/features/chat/data/models/reply_to_message_model.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:flutter/cupertino.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'message_model.freezed.dart';
part 'message_model.g.dart';

@freezed
abstract class MessageModel with _$MessageModel {
  const MessageModel._();

  const factory MessageModel({
    required int id,
    required int conversationId,
    required int senderId,
    String? senderUsername,
    String? senderFullName,
    required String content,
    required String type,
    required String createdAt,
    @Deprecated('Use senderId, senderUsername, senderFullName instead') MessageSenderModel? sender,
    String? mediaUrl,
    String? thumbnailUrl,
    String? fileName,
    int? fileSize,
    int? duration,
    double? latitude,
    double? longitude,
    String? locationName,
    int? replyToMessageId,
    ReplyToMessageModel? replyToMessage,
    String? reactions,
    String? mentions,
    @Default([]) List<MentionedUserModel> mentionedUsers,
    String? sentAt,
    String? updatedAt,
    @Default(false) bool edited,
    String? editedAt,
    @Default(false) bool deleted,
    String? deletedAt,
    @Default(false) bool forwarded,
    int? originalMessageId,
    @Default(0) int forwardCount,
    @Default(0) int readCount,
    @Default([]) List<ReadReceiptModel> readBy,
  }) = _MessageModel;

  factory MessageModel.fromJson(Map<String, dynamic> json) => _$MessageModelFromJson(json);

  factory MessageModel.fromApi(Map<String, dynamic> json) {
    final senderId = (json['senderId'] ?? json['sender']?['id'] ?? 0) is int
        ? (json['senderId'] ?? json['sender']?['id'] ?? 0)
        : int.tryParse((json['senderId'] ?? json['sender']?['id'] ?? 0).toString()) ?? 0;
    final senderUsername = json['senderUsername']?.toString() ?? json['sender']?['username']?.toString();
    final senderFullName = json['senderFullName']?.toString() ?? json['sender']?['fullName']?.toString();
    final senderJson = (json['sender'] is Map<String, dynamic>)
        ? json['sender'] as Map<String, dynamic>
        : <String, dynamic>{
            'id': senderId,
            'userId': senderId,
            'senderId': senderId,
            'username': senderUsername,
            'senderUsername': senderUsername,
            'fullName': senderFullName ?? '',
          };
    ReplyToMessageModel? replyToMessage;
    if (json['replyToMessage'] != null && json['replyToMessage'] is Map<String, dynamic>) {
      replyToMessage = ReplyToMessageModel.fromJson(json['replyToMessage']);
    }
    List<MentionedUserModel> mentionedUsers = [];
    if (json['mentionedUsers'] != null && json['mentionedUsers'] is List) {
      mentionedUsers = (json['mentionedUsers'] as List)
          .map((e) => MentionedUserModel.fromJson(e as Map<String, dynamic>))
          .toList();
    }
    List<ReadReceiptModel> readBy = [];
    if (json['readBy'] != null && json['readBy'] is List) {
      readBy = (json['readBy'] as List).map((e) => ReadReceiptModel.fromJson(e as Map<String, dynamic>)).toList();
    }

    return MessageModel(
      id: (json['id'] ?? json['messageId'] ?? 0) is int
          ? (json['id'] ?? json['messageId'] ?? 0)
          : int.tryParse((json['id'] ?? json['messageId'] ?? 0).toString()) ?? 0,
      conversationId: (json['conversationId'] ?? json['conversation_id'] ?? 0) is int
          ? (json['conversationId'] ?? json['conversation_id'] ?? 0)
          : int.tryParse((json['conversationId'] ?? json['conversation_id'] ?? '0').toString()) ?? 0,
      senderId: senderId,
      senderUsername: senderUsername,
      senderFullName: senderFullName,
      content: (json['content'] ?? '').toString(),
      type: (json['type'] ?? '').toString(),
      createdAt: (json['createdAt'] ?? json['sentAt'] ?? DateTime.now().toIso8601String()).toString(),
      sender: MessageSenderModel.fromApi(senderJson),
      mediaUrl: json['mediaUrl']?.toString(),
      thumbnailUrl: json['thumbnailUrl']?.toString(),
      fileName: json['fileName']?.toString(),
      fileSize: json['fileSize'] != null ? (json['fileSize'] as num).toInt() : null,
      duration: json['duration'] != null ? (json['duration'] as num).toInt() : null,
      latitude: json['latitude'] != null ? (json['latitude'] as num).toDouble() : null,
      longitude: json['longitude'] != null ? (json['longitude'] as num).toDouble() : null,
      locationName: json['locationName']?.toString(),
      replyToMessageId: json['replyToMessageId'] != null ? (json['replyToMessageId'] as num).toInt() : null,
      replyToMessage: replyToMessage,
      reactions: _convertReactionsToJson(json['reactions']),
      mentions: _convertMentionsToJson(json['mentions']),
      mentionedUsers: mentionedUsers,
      sentAt: json['sentAt']?.toString(),
      updatedAt: json['updatedAt']?.toString(),
      edited: json['edited'] ?? false,
      editedAt: json['editedAt']?.toString(),
      deleted: json['deleted'] ?? false,
      deletedAt: json['deletedAt']?.toString(),
      forwarded: json['forwarded'] ?? false,
      originalMessageId: json['originalMessageId'] != null ? (json['originalMessageId'] as num).toInt() : null,
      forwardCount: json['forwardCount'] ?? 0,
      readCount: json['readCount'] ?? 0,
      readBy: readBy,
    );
  }
  static String? _convertReactionsToJson(dynamic reactions) {
    if (reactions == null) return null;
    if (reactions is String) return reactions;
    if (reactions is Map) {
      try {
        return jsonEncode(reactions);
      } catch (e) {
        debugPrint('Error converting reactions to JSON: $e');
        return null;
      }
    }
    return null;
  }
  static String? _convertMentionsToJson(dynamic mentions) {
    if (mentions == null) return null;
    if (mentions is String) return mentions;
    if (mentions is List) {
      try {
        return jsonEncode(mentions);
      } catch (e) {
        debugPrint('Error converting mentions to JSON: $e');
        return null;
      }
    }
    return null;
  }

  Message toEntity() {
    return Message(
      id: id,
      conversationId: conversationId,
      senderId: senderId,
      senderUsername: senderUsername,
      senderFullName: senderFullName,
      content: content,
      type: type,
      createdAt: DateTime.parse(createdAt),
      sender: sender?.toEntity(),
      mediaUrl: mediaUrl,
      thumbnailUrl: thumbnailUrl,
      fileName: fileName,
      fileSize: fileSize,
      duration: duration,
      latitude: latitude,
      longitude: longitude,
      locationName: locationName,
      replyToMessageId: replyToMessageId,
      replyToMessage: replyToMessage?.toEntity(),
      reactions: reactions,
      mentions: mentions,
      mentionedUsers: mentionedUsers.map((e) => e.toEntity()).toList(),
      sentAt: sentAt != null ? DateTime.parse(sentAt!) : null,
      updatedAt: updatedAt != null ? DateTime.parse(updatedAt!) : null,
      edited: edited,
      editedAt: editedAt != null ? DateTime.parse(editedAt!) : null,
      deleted: deleted,
      deletedAt: deletedAt != null ? DateTime.parse(deletedAt!) : null,
      forwarded: forwarded,
      originalMessageId: originalMessageId,
      forwardCount: forwardCount,
      readCount: readCount,
      readBy: readBy.map((e) => e.toEntity()).toList(),
    );
  }
}

================================================================
FILE: lib/features/chat/data/models/message_sender_model.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/message_sender.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'message_sender_model.freezed.dart';
part 'message_sender_model.g.dart';

@freezed
abstract class MessageSenderModel with _$MessageSenderModel {
  const MessageSenderModel._();

  const factory MessageSenderModel({
    required int id,
    required String username,
    required String fullName,
    String? avatarUrl,
  }) = _MessageSenderModel;

  factory MessageSenderModel.fromJson(Map<String, dynamic> json) => _$MessageSenderModelFromJson(json);

  factory MessageSenderModel.fromApi(Map<String, dynamic> json) {
    final rawId = json['id'] ?? json['userId'] ?? json['senderId'];
    final id = rawId is int ? rawId : int.tryParse(rawId.toString()) ?? 0;

    return MessageSenderModel(
      id: id,
      username: (json['username'] ?? json['senderUsername'] ?? '').toString(),
      fullName: (json['fullName'] ?? json['full_name'] ?? '').toString(),
      avatarUrl: json['avatarUrl'] as String? ?? json['avatar_url'] as String?,
    );
  }

  MessageSender toEntity() {
    return MessageSender(id: id, username: username, fullName: fullName, avatarUrl: avatarUrl);
  }
}

================================================================
FILE: lib/features/chat/data/models/message_update_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'message_update_dto.freezed.dart';
part 'message_update_dto.g.dart';
@freezed
abstract class MessageUpdateDto with _$MessageUpdateDto {
  const factory MessageUpdateDto({
    required int messageId,
    required int conversationId,
    required String content,
    required bool edited,
    required String updatedAt,
  }) = _MessageUpdateDto;

  factory MessageUpdateDto.fromJson(Map<String, dynamic> json) => _$MessageUpdateDtoFromJson(json);
}

================================================================
FILE: lib/features/chat/data/models/outgoing_message_dto.dart
================================================================
import 'package:chattrix_ui/features/chat/data/models/mentioned_user_model.dart';
import 'package:chattrix_ui/features/chat/data/models/reply_to_message_model.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'outgoing_message_dto.freezed.dart';
part 'outgoing_message_dto.g.dart';
@freezed
abstract class OutgoingMessageDto with _$OutgoingMessageDto {
  const OutgoingMessageDto._();

  const factory OutgoingMessageDto({
    required int id,
    required int conversationId,
    required MessageSenderDto sender,
    required String content,
    required String type,
    required String createdAt,
    String? mediaUrl,
    String? thumbnailUrl,
    String? fileName,
    int? fileSize,
    int? duration,
    double? latitude,
    double? longitude,
    String? locationName,
    int? replyToMessageId,
    ReplyToMessageModel? replyToMessage,
    Map<String, List<int>>? reactions,
    List<int>? mentions,
    List<MentionedUserModel>? mentionedUsers,
  }) = _OutgoingMessageDto;

  factory OutgoingMessageDto.fromJson(Map<String, dynamic> json) => _$OutgoingMessageDtoFromJson(json);
}

@freezed
abstract class MessageSenderDto with _$MessageSenderDto {
  const factory MessageSenderDto({
    required int id,
    required String username,
    required String fullName,
    String? avatarUrl,
  }) = _MessageSenderDto;

  factory MessageSenderDto.fromJson(Map<String, dynamic> json) => _$MessageSenderDtoFromJson(json);
}

================================================================
FILE: lib/features/chat/data/models/participant_model.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/participant.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'participant_model.freezed.dart';
part 'participant_model.g.dart';

@freezed
abstract class ParticipantModel with _$ParticipantModel {
  const ParticipantModel._();

  const factory ParticipantModel({
    required int userId,
    required String username,
    required String fullName,
    required String role,
    String? email,
    String? nickname,
    String? avatarUrl,
    bool? online,
    String? lastSeen,
  }) = _ParticipantModel;

  factory ParticipantModel.fromJson(Map<String, dynamic> json) => _$ParticipantModelFromJson(json);

  factory ParticipantModel.fromApi(Map<String, dynamic> json) {
    final online = json['online'] as bool? ?? json['isOnline'] as bool?;

    final lastSeen = json['lastSeen']?.toString();

    return ParticipantModel(
      userId: (json['userId'] ?? json['user_id'] ?? 0) is int
          ? (json['userId'] ?? json['user_id'] ?? 0)
          : int.tryParse((json['userId'] ?? json['user_id'] ?? 0).toString()) ?? 0,
      username: (json['username'] ?? '').toString(),
      fullName: (json['fullName'] ?? json['full_name'] ?? '').toString(),
      role: (json['role'] ?? '').toString(),
      email: json['email']?.toString(),
      nickname: json['nickname']?.toString(),
      avatarUrl: json['avatarUrl']?.toString() ?? json['avatar_url']?.toString(),
      online: online,
      lastSeen: lastSeen,
    );
  }

  Participant toEntity() {
    return Participant(
      userId: userId,
      username: username,
      fullName: fullName,
      role: role,
      email: email,
      nickname: nickname,
      avatarUrl: avatarUrl,
      online: online,
      lastSeen: lastSeen != null ? DateTime.parse(lastSeen!) : null,
    );
  }
}

================================================================
FILE: lib/features/chat/data/models/reaction_event_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'reaction_event_dto.freezed.dart';
part 'reaction_event_dto.g.dart';
@freezed
abstract class ReactionEventDto with _$ReactionEventDto {
  const factory ReactionEventDto({
    required int messageId,
    required int userId,
    required String userName,
    required String emoji,
    required String action, // 'add' or 'remove'
    required Map<String, List<int>> reactions, // Updated reactions map
    required String timestamp,
  }) = _ReactionEventDto;

  factory ReactionEventDto.fromJson(Map<String, dynamic> json) => _$ReactionEventDtoFromJson(json);
}

================================================================
FILE: lib/features/chat/data/models/read_receipt_model.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/read_receipt.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'read_receipt_model.freezed.dart';
part 'read_receipt_model.g.dart';

@freezed
abstract class ReadReceiptModel with _$ReadReceiptModel {
  const ReadReceiptModel._();

  const factory ReadReceiptModel({
    required int userId,
    required String username,
    required String fullName,
    String? avatarUrl,
    required DateTime readAt,
  }) = _ReadReceiptModel;

  factory ReadReceiptModel.fromJson(Map<String, dynamic> json) => _$ReadReceiptModelFromJson(json);

  ReadReceipt toEntity() {
    return ReadReceipt(userId: userId, username: username, fullName: fullName, avatarUrl: avatarUrl, readAt: readAt);
  }
}

================================================================
FILE: lib/features/chat/data/models/reply_to_message_model.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/reply_to_message.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'reply_to_message_model.freezed.dart';
part 'reply_to_message_model.g.dart';

@freezed
abstract class ReplyToMessageModel with _$ReplyToMessageModel {
  const ReplyToMessageModel._();

  const factory ReplyToMessageModel({
    required int id,
    required String content,
    required int senderId,
    required String senderUsername,
  }) = _ReplyToMessageModel;

  factory ReplyToMessageModel.fromJson(Map<String, dynamic> json) => _$ReplyToMessageModelFromJson(json);

  ReplyToMessage toEntity() {
    return ReplyToMessage(id: id, content: content, senderId: senderId, senderUsername: senderUsername);
  }
}

================================================================
FILE: lib/features/chat/data/models/search_user_model.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/search_user.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'search_user_model.freezed.dart';
part 'search_user_model.g.dart';

@freezed
abstract class SearchUserModel with _$SearchUserModel {
  const SearchUserModel._();

  const factory SearchUserModel({
    required int id,
    required String username,
    required String email,
    required String fullName,
    String? avatarUrl,
    required bool isOnline,
    String? lastSeen,
    @JsonKey(name: 'contact') required bool isContact,
    required bool hasConversation,
    int? conversationId,
  }) = _SearchUserModel;

  factory SearchUserModel.fromJson(Map<String, dynamic> json) => _$SearchUserModelFromJson(json);

  SearchUser toEntity() {
    return SearchUser(
      id: id,
      username: username,
      email: email,
      fullName: fullName,
      avatarUrl: avatarUrl,
      isOnline: isOnline,
      lastSeen: lastSeen != null ? DateTime.parse(lastSeen!) : DateTime.now(),
      isContact: isContact,
      hasConversation: hasConversation,
      conversationId: conversationId,
    );
  }
}

================================================================
FILE: lib/features/chat/data/models/typing_indicator_model.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/typing_indicator.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'typing_indicator_model.freezed.dart';
part 'typing_indicator_model.g.dart';

@freezed
abstract class TypingIndicatorModel with _$TypingIndicatorModel {
  const TypingIndicatorModel._();

  const factory TypingIndicatorModel({
    @JsonKey(fromJson: _conversationIdFromJson) required String conversationId,
    required List<TypingUserModel> typingUsers,
  }) = _TypingIndicatorModel;

  factory TypingIndicatorModel.fromJson(Map<String, dynamic> json) => _$TypingIndicatorModelFromJson(json);

  TypingIndicator toEntity() {
    return TypingIndicator(
      conversationId: conversationId,
      typingUsers: typingUsers.map((user) => user.toEntity()).toList(),
    );
  }
}

String _conversationIdFromJson(dynamic value) {
  if (value is int) return value.toString();
  if (value is String) return value;
  throw FormatException('Invalid conversationId format: $value');
}

@freezed
abstract class TypingUserModel with _$TypingUserModel {
  const TypingUserModel._();

  const factory TypingUserModel({
    @JsonKey(name: 'userId', fromJson: _userIdFromJson) required String id,
    required String username,
    required String fullName,
  }) = _TypingUserModel;

  factory TypingUserModel.fromJson(Map<String, dynamic> json) => _$TypingUserModelFromJson(json);

  TypingUser toEntity() {
    return TypingUser(id: id, username: username, fullName: fullName);
  }
}

String _userIdFromJson(dynamic value) {
  if (value == null) throw FormatException('userId cannot be null');
  if (value is int) return value.toString();
  if (value is String) return value;
  throw FormatException('Invalid user id format: $value');
}

================================================================
FILE: lib/features/chat/data/models/user_status_model.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/user_status.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_status_model.freezed.dart';
part 'user_status_model.g.dart';

@freezed
abstract class UserStatusModel with _$UserStatusModel {
  const UserStatusModel._();

  const factory UserStatusModel({required int userId, required bool isOnline, required int activeSessionCount}) =
      _UserStatusModel;

  factory UserStatusModel.fromJson(Map<String, dynamic> json) => _$UserStatusModelFromJson(json);

  UserStatus toEntity() {
    return UserStatus(userId: userId, isOnline: isOnline, activeSessionCount: activeSessionCount);
  }
}

================================================================
FILE: lib/features/chat/data/models/user_status_update_model.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/user_status_update.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_status_update_model.freezed.dart';
part 'user_status_update_model.g.dart';

@freezed
abstract class UserStatusUpdateModel with _$UserStatusUpdateModel {
  const UserStatusUpdateModel._();

  const factory UserStatusUpdateModel({
    required String userId,
    required String username,
    required String displayName,
    required bool isOnline,
    String? lastSeen,
  }) = _UserStatusUpdateModel;

  factory UserStatusUpdateModel.fromJson(Map<String, dynamic> json) => _$UserStatusUpdateModelFromJson(json);

  UserStatusUpdate toEntity() {
    return UserStatusUpdate(
      userId: userId,
      username: username,
      displayName: displayName,
      isOnline: isOnline,
      lastSeen: lastSeen,
    );
  }
}

================================================================
FILE: lib/features/chat/data/models/websocket/message_delete_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'message_delete_dto.freezed.dart';
part 'message_delete_dto.g.dart';
@freezed
abstract class MessageDeleteDto with _$MessageDeleteDto {
  const factory MessageDeleteDto({required int messageId, required int conversationId}) = _MessageDeleteDto;

  factory MessageDeleteDto.fromJson(Map<String, dynamic> json) => _$MessageDeleteDtoFromJson(json);
}

================================================================
FILE: lib/features/chat/data/models/websocket/message_update_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'message_update_dto.freezed.dart';
part 'message_update_dto.g.dart';
@freezed
abstract class MessageUpdateDto with _$MessageUpdateDto {
  const factory MessageUpdateDto({
    required int messageId,
    required int conversationId,
    required String content,
    required bool edited,
    required DateTime updatedAt,
  }) = _MessageUpdateDto;

  factory MessageUpdateDto.fromJson(Map<String, dynamic> json) => _$MessageUpdateDtoFromJson(json);
}

================================================================
FILE: lib/features/chat/data/models/websocket/outgoing_message_dto.dart
================================================================
import 'package:chattrix_ui/features/chat/data/models/mentioned_user_model.dart';
import 'package:chattrix_ui/features/chat/data/models/message_sender_model.dart';
import 'package:chattrix_ui/features/chat/data/models/reply_to_message_model.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'outgoing_message_dto.freezed.dart';
part 'outgoing_message_dto.g.dart';
@freezed
abstract class OutgoingMessageDto with _$OutgoingMessageDto {
  const factory OutgoingMessageDto({
    required int id,
    required int conversationId,
    required MessageSenderModel sender,
    required String content,
    required String type,
    required DateTime createdAt,
    String? mediaUrl,
    String? thumbnailUrl,
    String? fileName,
    int? fileSize,
    int? duration,
    double? latitude,
    double? longitude,
    String? locationName,
    int? replyToMessageId,
    ReplyToMessageModel? replyToMessage,
    Map<String, List<int>>? reactions,
    List<int>? mentions,
    List<MentionedUserModel>? mentionedUsers,
  }) = _OutgoingMessageDto;

  factory OutgoingMessageDto.fromJson(Map<String, dynamic> json) => _$OutgoingMessageDtoFromJson(json);
}

================================================================
FILE: lib/features/chat/data/models/websocket/reaction_event_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'reaction_event_dto.freezed.dart';
part 'reaction_event_dto.g.dart';
@freezed
abstract class ReactionEventDto with _$ReactionEventDto {
  const factory ReactionEventDto({
    required int messageId,
    required int userId,
    required String userName,
    required String emoji,
    required String action,
    required Map<String, List<int>> reactions,
    required DateTime timestamp,
  }) = _ReactionEventDto;

  factory ReactionEventDto.fromJson(Map<String, dynamic> json) => _$ReactionEventDtoFromJson(json);
}

================================================================
FILE: lib/features/chat/data/repositories/chat_repository_impl.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/conversation_filter.dart';
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/core/repositories/base_repository.dart';
import 'package:chattrix_ui/features/chat/domain/datasources/chat_remote_datasource.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/domain/entities/search_user.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/chat_repository.dart';
import 'package:fpdart/fpdart.dart';

class ChatRepositoryImpl extends BaseRepository implements ChatRepository {
  final ChatRemoteDatasource remoteDatasource;

  ChatRepositoryImpl({required this.remoteDatasource});

  @override
  Future<Either<Failure, Conversation>> createConversation({
    String? name,
    required String type,
    required List<String> participantIds,
  }) async {
    return executeApiCall(() async {
      final model = await remoteDatasource.createConversation(name: name, type: type, participantIds: participantIds);
      return model.toEntity();
    });
  }

  @override
  Future<Either<Failure, List<Conversation>>> getConversations({
    ConversationFilter filter = ConversationFilter.all,
  }) async {
    return executeApiCall(() async {
      final models = await remoteDatasource.getConversations(filter: filter);
      return models.map((model) => model.toEntity()).toList();
    });
  }

  @override
  Future<Either<Failure, Conversation>> getConversation(String conversationId) async {
    return executeApiCall(() async {
      final model = await remoteDatasource.getConversation(conversationId);
      return model.toEntity();
    });
  }

  @override
  Future<Either<Failure, List<Message>>> getMessages({
    required String conversationId,
    int page = 0,
    int size = 50,
    String sort = 'DESC',
  }) async {
    return executeApiCall(() async {
      final models = await remoteDatasource.getMessages(
        conversationId: conversationId,
        page: page,
        size: size,
        sort: sort,
      );
      return models.map((model) => model.toEntity()).toList();
    });
  }

  @override
  Future<Either<Failure, Message>> sendMessage({
    required String conversationId,
    required String content,
    String? type,
    String? mediaUrl,
    String? thumbnailUrl,
    String? fileName,
    int? fileSize,
    int? duration,
    double? latitude,
    double? longitude,
    String? locationName,
    int? replyToMessageId,
    String? mentions,
  }) async {
    return executeApiCall(() async {
      final model = await remoteDatasource.sendMessage(
        conversationId: conversationId,
        content: content,
        type: type,
        mediaUrl: mediaUrl,
        thumbnailUrl: thumbnailUrl,
        fileName: fileName,
        fileSize: fileSize,
        duration: duration,
        latitude: latitude,
        longitude: longitude,
        locationName: locationName,
        replyToMessageId: replyToMessageId,
        mentions: mentions,
      );
      return model.toEntity();
    });
  }

  @override
  Future<Either<Failure, List<SearchUser>>> searchUsers({required String query, int limit = 20}) async {
    return executeApiCall(() async {
      final models = await remoteDatasource.searchUsers(query: query, limit: limit);
      return models.map((model) => model.toEntity()).toList();
    });
  }

  @override
  Future<Either<Failure, List<Conversation>>> searchConversations({required String query}) async {
    return executeApiCall(() async {
      final models = await remoteDatasource.searchConversations(query: query);
      return models.map((model) => model.toEntity()).toList();
    });
  }

  @override
  Future<Either<Failure, Map<String, dynamic>>> toggleReaction({
    required String messageId,
    required String emoji,
  }) async {
    return executeApiCall(() async {
      return await remoteDatasource.toggleReaction(messageId: messageId, emoji: emoji);
    });
  }

  @override
  Future<Either<Failure, Map<String, dynamic>>> getReactions(String messageId) async {
    return executeApiCall(() async {
      return await remoteDatasource.getReactions(messageId);
    });
  }

  @override
  Future<Either<Failure, Message>> editMessage({required String messageId, required String content}) async {
    return executeApiCall(() async {
      final model = await remoteDatasource.editMessage(messageId: messageId, content: content);
      return model.toEntity();
    });
  }

  @override
  Future<Either<Failure, void>> deleteMessage(String messageId) async {
    return executeApiCall(() async {
      await remoteDatasource.deleteMessage(messageId);
    });
  }
}

================================================================
FILE: lib/features/chat/data/repositories/user_status_repository_impl.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/core/repositories/base_repository.dart';
import 'package:chattrix_ui/features/auth/data/mappers/user_mapper.dart';
import 'package:chattrix_ui/features/auth/domain/entities/user.dart';
import 'package:chattrix_ui/features/chat/domain/datasources/chat_remote_datasource.dart';
import 'package:chattrix_ui/features/chat/domain/entities/user_status.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/user_status_repository.dart';
import 'package:fpdart/fpdart.dart';

class UserStatusRepositoryImpl extends BaseRepository implements UserStatusRepository {
  final ChatRemoteDatasource remoteDatasource;

  UserStatusRepositoryImpl({required this.remoteDatasource});

  @override
  Future<Either<Failure, List<User>>> getOnlineUsers() async {
    return executeApiCall(() async {
      final models = await remoteDatasource.getOnlineUsers();
      return models.map((model) => model.toEntity()).toList();
    });
  }

  @override
  Future<Either<Failure, List<User>>> getOnlineUsersInConversation(String conversationId) async {
    return executeApiCall(() async {
      final models = await remoteDatasource.getOnlineUsersInConversation(conversationId);
      return models.map((model) => model.toEntity()).toList();
    });
  }

  @override
  Future<Either<Failure, UserStatus>> getUserStatus(String userId) async {
    return executeApiCall(() async {
      final model = await remoteDatasource.getUserStatus(userId);
      return model.toEntity();
    });
  }
}

================================================================
FILE: lib/features/chat/domain/datasources/chat_remote_datasource.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/conversation_filter.dart';
import 'package:chattrix_ui/features/auth/data/models/user_dto.dart';
import 'package:chattrix_ui/features/chat/data/models/conversation_model.dart';
import 'package:chattrix_ui/features/chat/data/models/message_model.dart';
import 'package:chattrix_ui/features/chat/data/models/search_user_model.dart';
import 'package:chattrix_ui/features/chat/data/models/user_status_model.dart';
abstract class ChatRemoteDatasource {
  Future<ConversationModel> createConversation({
    String? name,
    required String type,
    required List<String> participantIds,
  });
  Future<List<ConversationModel>> getConversations({ConversationFilter filter = ConversationFilter.all});
  Future<ConversationModel> getConversation(String conversationId);
  Future<List<MessageModel>> getMessages({
    required String conversationId,
    int page = 0,
    int size = 50,
    String sort = 'DESC',
  });
  Future<MessageModel> sendMessage({
    required String conversationId,
    required String content,
    String? type,
    String? mediaUrl,
    String? thumbnailUrl,
    String? fileName,
    int? fileSize,
    int? duration,
    double? latitude,
    double? longitude,
    String? locationName,
    int? replyToMessageId,
    String? mentions,
  });
  Future<List<UserDto>> getOnlineUsers();
  Future<List<UserDto>> getOnlineUsersInConversation(String conversationId);
  Future<UserStatusModel> getUserStatus(String userId);
  Future<List<SearchUserModel>> searchUsers({required String query, int limit = 20});
  Future<List<ConversationModel>> searchConversations({required String query});
  Future<Map<String, dynamic>> toggleReaction({required String messageId, required String emoji});
  Future<Map<String, dynamic>> getReactions(String messageId);
  Future<MessageModel> editMessage({required String messageId, required String content});
  Future<void> deleteMessage(String messageId);
}

================================================================
FILE: lib/features/chat/domain/datasources/chat_websocket_datasource.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/conversation_update.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/domain/entities/typing_indicator.dart';
import 'package:chattrix_ui/features/chat/domain/entities/user_status_update.dart';
abstract class ChatWebSocketDataSource {
  Future<void> connect(String accessToken);
  Future<void> disconnect();
  void sendMessage({required String conversationId, required String content, int? replyToMessageId});
  void sendTypingStart(String conversationId);
  void sendTypingStop(String conversationId);
  void sendGenericMessage(Map<String, dynamic> payload);
  Stream<Message> get messageStream;
  Stream<TypingIndicator> get typingStream;
  Stream<UserStatusUpdate> get userStatusStream;
  Stream<ConversationUpdate> get conversationUpdateStream;
  Stream<bool> get connectionStream;
  Stream<Map<String, dynamic>> get rawMessageStream;
  bool get isConnected;
  void dispose();
}

================================================================
FILE: lib/features/chat/domain/entities/conversation.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/enums.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/domain/entities/participant.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'conversation.freezed.dart';

@freezed
abstract class Conversation with _$Conversation {
  const factory Conversation({
    required int id,
    String? name,
    required ConversationType type,
    String? avatarUrl,
    required DateTime createdAt,
    required DateTime updatedAt,
    required List<Participant> participants,
    Message? lastMessage,
    @Default(0) int unreadCount,
  }) = _Conversation;
}

================================================================
FILE: lib/features/chat/domain/entities/conversation_update.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'conversation_update.freezed.dart';

@freezed
abstract class ConversationUpdate with _$ConversationUpdate {
  const ConversationUpdate._();

  const factory ConversationUpdate({
    required int conversationId,
    required String updatedAt,
    LastMessageInfo? lastMessage,
  }) = _ConversationUpdate;
}

@freezed
abstract class LastMessageInfo with _$LastMessageInfo {
  const LastMessageInfo._();

  const factory LastMessageInfo({
    required int id,
    required String content,
    required int senderId,
    required String senderUsername,
    required String sentAt,
    required String type,
  }) = _LastMessageInfo;
}

================================================================
FILE: lib/features/chat/domain/entities/mentioned_user.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'mentioned_user.freezed.dart';

@freezed
abstract class MentionedUser with _$MentionedUser {
  const factory MentionedUser({required int userId, required String username, required String fullName}) =
      _MentionedUser;
}

================================================================
FILE: lib/features/chat/domain/entities/message.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/mentioned_user.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message_sender.dart';
import 'package:chattrix_ui/features/chat/domain/entities/read_receipt.dart';
import 'package:chattrix_ui/features/chat/domain/entities/reply_to_message.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'message.freezed.dart';

@freezed
abstract class Message with _$Message {
  const factory Message({
    required int id,
    required int conversationId,
    required int senderId,
    String? senderUsername,
    String? senderFullName,
    required String content,
    required String type, // 'TEXT', 'IMAGE', 'VIDEO', 'AUDIO', 'FILE', 'LOCATION'
    required DateTime createdAt,
    @Deprecated('Use senderId, senderUsername, senderFullName instead') MessageSender? sender,
    String? mediaUrl, // URL for image, video, audio, or document
    String? thumbnailUrl, // Thumbnail for video or document preview
    String? fileName, // Original file name for documents
    int? fileSize, // File size in bytes
    int? duration, // Duration in seconds for audio/video
    double? latitude,
    double? longitude,
    String? locationName, // Human-readable location name
    int? replyToMessageId, // ID of message being replied to
    ReplyToMessage? replyToMessage, // Full reply message details
    String? reactions,
    String? mentions,
    @Default([]) List<MentionedUser> mentionedUsers,
    DateTime? sentAt,
    DateTime? updatedAt,
    @Default(false) bool edited,
    DateTime? editedAt,
    @Default(false) bool deleted,
    DateTime? deletedAt,
    @Default(false) bool forwarded,
    int? originalMessageId,
    @Default(0) int forwardCount,
    @Default(0) int readCount,
    @Default([]) List<ReadReceipt> readBy,
  }) = _Message;
}

================================================================
FILE: lib/features/chat/domain/entities/message_sender.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'message_sender.freezed.dart';

@freezed
abstract class MessageSender with _$MessageSender {
  const factory MessageSender({
    required int id,
    required String username,
    required String fullName,
    String? avatarUrl,
  }) = _MessageSender;
}

================================================================
FILE: lib/features/chat/domain/entities/participant.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'participant.freezed.dart';

@freezed
abstract class Participant with _$Participant {
  const factory Participant({
    required int userId,
    required String username,
    required String fullName,
    required String role, // 'ADMIN' or 'MEMBER'
    String? email,
    String? nickname,
    String? avatarUrl,
    bool? online,
    DateTime? lastSeen,
  }) = _Participant;
}

================================================================
FILE: lib/features/chat/domain/entities/read_receipt.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'read_receipt.freezed.dart';

@freezed
abstract class ReadReceipt with _$ReadReceipt {
  const factory ReadReceipt({
    required int userId,
    required String username,
    required String fullName,
    String? avatarUrl,
    required DateTime readAt,
  }) = _ReadReceipt;
}

================================================================
FILE: lib/features/chat/domain/entities/reply_to_message.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'reply_to_message.freezed.dart';

@freezed
abstract class ReplyToMessage with _$ReplyToMessage {
  const factory ReplyToMessage({
    required int id,
    required String content,
    required int senderId,
    required String senderUsername,
  }) = _ReplyToMessage;
}

================================================================
FILE: lib/features/chat/domain/entities/search_user.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'search_user.freezed.dart';

@freezed
abstract class SearchUser with _$SearchUser {
  const factory SearchUser({
    required int id,
    required String username,
    required String email,
    required String fullName,
    String? avatarUrl,
    required bool isOnline,
    required DateTime lastSeen,
    required bool isContact,
    required bool hasConversation,
    int? conversationId,
  }) = _SearchUser;
}

================================================================
FILE: lib/features/chat/domain/entities/typing_indicator.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'typing_indicator.freezed.dart';

@freezed
abstract class TypingIndicator with _$TypingIndicator {
  const TypingIndicator._();

  const factory TypingIndicator({required String conversationId, required List<TypingUser> typingUsers}) =
      _TypingIndicator;
}

@freezed
abstract class TypingUser with _$TypingUser {
  const TypingUser._();

  const factory TypingUser({required String id, required String username, required String fullName}) = _TypingUser;
}

================================================================
FILE: lib/features/chat/domain/entities/user_note_entity.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_note_entity.freezed.dart';
@freezed
abstract class UserNoteEntity with _$UserNoteEntity {
  const factory UserNoteEntity({
    required String userId,
    required String content,
    required DateTime createdAt,
    DateTime? expiresAt,
  }) = _UserNoteEntity;
}

================================================================
FILE: lib/features/chat/domain/entities/user_status.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_status.freezed.dart';

@freezed
abstract class UserStatus with _$UserStatus {
  const factory UserStatus({required int userId, required bool isOnline, required int activeSessionCount}) =
      _UserStatus;
}

================================================================
FILE: lib/features/chat/domain/entities/user_status_update.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_status_update.freezed.dart';

@freezed
abstract class UserStatusUpdate with _$UserStatusUpdate {
  const UserStatusUpdate._();

  const factory UserStatusUpdate({
    required String userId,
    required String username,
    required String displayName,
    required bool isOnline,
    String? lastSeen,
  }) = _UserStatusUpdate;
}

================================================================
FILE: lib/features/chat/domain/repositories/chat_repository.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/conversation_filter.dart';
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/domain/entities/search_user.dart';
import 'package:fpdart/fpdart.dart';

abstract class ChatRepository {
  Future<Either<Failure, Conversation>> createConversation({
    String? name,
    required String type,
    required List<String> participantIds,
  });
  Future<Either<Failure, List<Conversation>>> getConversations({ConversationFilter filter = ConversationFilter.all});
  Future<Either<Failure, Conversation>> getConversation(String conversationId);
  Future<Either<Failure, List<Message>>> getMessages({
    required String conversationId,
    int page = 0,
    int size = 50,
    String sort = 'DESC',
  });
  Future<Either<Failure, Message>> sendMessage({
    required String conversationId,
    required String content,
    String? type,
    String? mediaUrl,
    String? thumbnailUrl,
    String? fileName,
    int? fileSize,
    int? duration,
    double? latitude,
    double? longitude,
    String? locationName,
    int? replyToMessageId,
    String? mentions,
  });
  Future<Either<Failure, List<SearchUser>>> searchUsers({required String query, int limit = 20});
  Future<Either<Failure, List<Conversation>>> searchConversations({required String query});
  Future<Either<Failure, Map<String, dynamic>>> toggleReaction({required String messageId, required String emoji});
  Future<Either<Failure, Map<String, dynamic>>> getReactions(String messageId);
  Future<Either<Failure, Message>> editMessage({required String messageId, required String content});
  Future<Either<Failure, void>> deleteMessage(String messageId);
}

================================================================
FILE: lib/features/chat/domain/repositories/user_status_repository.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/entities/user.dart';
import 'package:chattrix_ui/features/chat/domain/entities/user_status.dart';
import 'package:fpdart/fpdart.dart';

abstract class UserStatusRepository {
  Future<Either<Failure, List<User>>> getOnlineUsers();
  Future<Either<Failure, List<User>>> getOnlineUsersInConversation(String conversationId);
  Future<Either<Failure, UserStatus>> getUserStatus(String userId);
}

================================================================
FILE: lib/features/chat/domain/usecases/create_conversation_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/chat_repository.dart';
import 'package:fpdart/fpdart.dart';

class CreateConversationUsecase {
  final ChatRepository repository;

  CreateConversationUsecase(this.repository);

  Future<Either<Failure, Conversation>> call({
    String? name,
    required String type,
    required List<String> participantIds,
  }) async {
    final normalizedType = type.toUpperCase();
    if (normalizedType != 'DIRECT' && normalizedType != 'GROUP') {
      return left(
        const Failure.validation(message: 'Invalid conversation type. Must be DIRECT or GROUP', code: 'INVALID_TYPE'),
      );
    }
    if (normalizedType == 'DIRECT') {
      if (participantIds.length != 2) {
        return left(
          const Failure.validation(
            message: 'DIRECT conversation must have exactly 2 participants',
            code: 'INVALID_PARTICIPANT_COUNT',
          ),
        );
      }
    }
    if (normalizedType == 'GROUP') {
      if (participantIds.length < 2) {
        return left(
          const Failure.validation(
            message: 'GROUP conversation must have at least 2 participants',
            code: 'INVALID_PARTICIPANT_COUNT',
          ),
        );
      }
      if (name == null || name.trim().isEmpty) {
        return left(
          const Failure.validation(message: 'GROUP conversation must have a name', code: 'MISSING_GROUP_NAME'),
        );
      }
    }
    return repository.createConversation(name: name, type: normalizedType, participantIds: participantIds);
  }
}

================================================================
FILE: lib/features/chat/domain/usecases/delete_message_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/chat_repository.dart';
import 'package:fpdart/fpdart.dart';

class DeleteMessageUsecase {
  final ChatRepository repository;

  DeleteMessageUsecase({required this.repository});

  Future<Either<Failure, void>> call({required String messageId}) async {
    return await repository.deleteMessage(messageId);
  }
}

================================================================
FILE: lib/features/chat/domain/usecases/edit_message_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/chat_repository.dart';
import 'package:fpdart/fpdart.dart';

class EditMessageUsecase {
  final ChatRepository repository;

  EditMessageUsecase({required this.repository});

  Future<Either<Failure, Message>> call({required String messageId, required String content}) async {
    return await repository.editMessage(messageId: messageId, content: content);
  }
}

================================================================
FILE: lib/features/chat/domain/usecases/get_conversation_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/chat_repository.dart';
import 'package:fpdart/fpdart.dart';

class GetConversationUsecase {
  final ChatRepository repository;

  GetConversationUsecase(this.repository);

  Future<Either<Failure, Conversation>> call(String conversationId) {
    return repository.getConversation(conversationId);
  }
}

================================================================
FILE: lib/features/chat/domain/usecases/get_conversations_usecase.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/conversation_filter.dart';
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/chat_repository.dart';
import 'package:fpdart/fpdart.dart';

class GetConversationsUsecase {
  final ChatRepository repository;

  GetConversationsUsecase(this.repository);

  Future<Either<Failure, List<Conversation>>> call({ConversationFilter filter = ConversationFilter.all}) {
    return repository.getConversations(filter: filter);
  }
}

================================================================
FILE: lib/features/chat/domain/usecases/get_messages_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/chat_repository.dart';
import 'package:fpdart/fpdart.dart';

class GetMessagesUsecase {
  final ChatRepository repository;

  GetMessagesUsecase(this.repository);
  Future<Either<Failure, List<Message>>> call({
    required String conversationId,
    int page = 0,
    int size = 50,
    String sort = 'DESC',
  }) {
    return repository.getMessages(conversationId: conversationId, page: page, size: size, sort: sort);
  }
}

================================================================
FILE: lib/features/chat/domain/usecases/get_online_users_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/domain/entities/user.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/user_status_repository.dart';
import 'package:fpdart/fpdart.dart';

class GetOnlineUsersUsecase {
  final UserStatusRepository repository;

  GetOnlineUsersUsecase(this.repository);

  Future<Either<Failure, List<User>>> call() {
    return repository.getOnlineUsers();
  }
}

================================================================
FILE: lib/features/chat/domain/usecases/get_user_status_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/chat/domain/entities/user_status.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/user_status_repository.dart';
import 'package:fpdart/fpdart.dart';

class GetUserStatusUsecase {
  final UserStatusRepository repository;

  GetUserStatusUsecase(this.repository);

  Future<Either<Failure, UserStatus>> call(String userId) {
    return repository.getUserStatus(userId);
  }
}

================================================================
FILE: lib/features/chat/domain/usecases/search_conversations_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/chat_repository.dart';
import 'package:fpdart/fpdart.dart';
class SearchConversationsUseCase {
  final ChatRepository _repository;

  SearchConversationsUseCase(this._repository);
  Future<Either<Failure, List<Conversation>>> call({required String query}) async {
    if (query.trim().isEmpty) {
      return right([]); // Return empty list for empty query
    }
    return await _repository.searchConversations(query: query);
  }
}

================================================================
FILE: lib/features/chat/domain/usecases/search_users_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/chat/domain/entities/search_user.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/chat_repository.dart';
import 'package:fpdart/fpdart.dart';

class SearchUsersUsecase {
  final ChatRepository repository;

  SearchUsersUsecase(this.repository);

  Future<Either<Failure, List<SearchUser>>> call({required String query, int limit = 20}) {
    return repository.searchUsers(query: query, limit: limit);
  }
}

================================================================
FILE: lib/features/chat/domain/usecases/send_message_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/chat_repository.dart';
import 'package:fpdart/fpdart.dart';

class SendMessageUsecase {
  final ChatRepository repository;

  SendMessageUsecase(this.repository);

  Future<Either<Failure, Message>> call({
    required String conversationId,
    required String content,
    String? type,
    String? mediaUrl,
    String? thumbnailUrl,
    String? fileName,
    int? fileSize,
    int? duration,
    double? latitude,
    double? longitude,
    String? locationName,
    int? replyToMessageId,
    String? mentions,
  }) {
    return repository.sendMessage(
      conversationId: conversationId,
      content: content,
      type: type,
      mediaUrl: mediaUrl,
      thumbnailUrl: thumbnailUrl,
      fileName: fileName,
      fileSize: fileSize,
      duration: duration,
      latitude: latitude,
      longitude: longitude,
      locationName: locationName,
      replyToMessageId: replyToMessageId,
      mentions: mentions,
    );
  }
}

================================================================
FILE: lib/features/chat/domain/usecases/toggle_reaction_usecase.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/chat_repository.dart';
import 'package:fpdart/fpdart.dart';

class ToggleReactionUsecase {
  final ChatRepository repository;

  ToggleReactionUsecase(this.repository);

  Future<Either<Failure, Map<String, dynamic>>> call({required String messageId, required String emoji}) {
    return repository.toggleReaction(messageId: messageId, emoji: emoji);
  }
}

================================================================
FILE: lib/features/chat/presentation/pages/chat_info_page.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/enums.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/chat_info/chat_info_header.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/chat_info/media_grid_widget.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/chat_info/members_list_widget.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/chat_info/message_search_widget.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/chat_info/settings_section_widget.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class ChatInfoPage extends HookConsumerWidget {
  const ChatInfoPage({super.key, required this.conversation});

  final Conversation conversation;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedTab = useState(0);
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(icon: const Icon(Icons.arrow_back), onPressed: () => context.pop()),
        title: Text('Conversation Info', style: textTheme.titleMedium),
      ),
      body: Column(
        children: [

          ChatInfoHeader(conversation: conversation),

          Container(
            decoration: BoxDecoration(
              border: Border(bottom: BorderSide(color: colors.onSurface.withValues(alpha: 0.1))),
            ),
            child: Row(
              children: [
                _TabButton(
                  label: 'Overview',
                  icon: Icons.info_outline,
                  isSelected: selectedTab.value == 0,
                  onTap: () => selectedTab.value = 0,
                ),
                _TabButton(
                  label: 'Media',
                  icon: Icons.photo_library_outlined,
                  isSelected: selectedTab.value == 1,
                  onTap: () => selectedTab.value = 1,
                ),
                _TabButton(
                  label: 'Search',
                  icon: Icons.search,
                  isSelected: selectedTab.value == 2,
                  onTap: () => selectedTab.value = 2,
                ),
                if (conversation.type == ConversationType.group)
                  _TabButton(
                    label: 'Members',
                    icon: Icons.people_outline,
                    isSelected: selectedTab.value == 3,
                    onTap: () => selectedTab.value = 3,
                  ),
              ],
            ),
          ),

          Expanded(
            child: IndexedStack(
              index: selectedTab.value,
              children: [

                SettingsSectionWidget(conversation: conversation),

                MediaGridWidget(conversationId: conversation.id.toString()),

                MessageSearchWidget(conversationId: conversation.id.toString()),

                if (conversation.type == ConversationType.group) MembersListWidget(conversation: conversation),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _TabButton extends StatelessWidget {
  const _TabButton({required this.label, required this.icon, required this.isSelected, required this.onTap});

  final String label;
  final IconData icon;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    return Expanded(
      child: InkWell(
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 12),
          decoration: BoxDecoration(
            border: Border(bottom: BorderSide(color: isSelected ? colors.primary : Colors.transparent, width: 2)),
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon, size: 20, color: isSelected ? colors.primary : colors.onSurface.withValues(alpha: 0.6)),
              const SizedBox(height: 4),
              Text(
                label,
                style: textTheme.labelSmall?.copyWith(
                  color: isSelected ? colors.primary : colors.onSurface.withValues(alpha: 0.6),
                  fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/pages/chat_list_demo_page.dart
================================================================
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
class ChatMock {
  final String id;
  final String name;
  final String message;
  final String time;
  final String avatarUrl;
  final int unreadCount;
  final bool isOnline;
  final bool isTyping;
  final bool isRead;
  final bool isSent;
  final String? note;
  final bool isGroup;

  ChatMock({
    required this.id,
    required this.name,
    required this.message,
    required this.time,
    required this.avatarUrl,
    this.unreadCount = 0,
    this.isOnline = false,
    this.isTyping = false,
    this.isRead = false,
    this.isSent = false,
    this.note,
    this.isGroup = false,
  });
}

final List<ChatMock> _allChats = [
  ChatMock(
    id: '1',
    name: 'Alberne',
    message: 'T·ªëi nay ƒëi ƒÉn kh√¥ng?',
    time: '2m',
    avatarUrl: 'https://i.pravatar.cc/150?u=1',
    unreadCount: 3,
    isOnline: true,
    note: 'ƒê√≥i qu√° üçú',
  ),
  ChatMock(
    id: '2',
    name: 'H·ªìng Nhung',
    message: 'ƒêang so·∫°n tin...',
    time: 'Now',
    avatarUrl: 'https://i.pravatar.cc/150?u=2',
    isTyping: true,
    isOnline: true,
    note: 'Nh·∫°c hay üé∂',
  ),
  ChatMock(
    id: '3',
    name: 'Dev Team üöÄ',
    message: 'Long: ƒê√£ merge code nha anh em.',
    time: '1h',
    avatarUrl: 'https://i.pravatar.cc/150?u=8',
    unreadCount: 12,
    isGroup: true,
  ),
  ChatMock(
    id: '4',
    name: 'Tu·∫•n Anh',
    message: 'Ok ch·ªët ƒë∆°n.',
    time: '3h',
    avatarUrl: 'https://i.pravatar.cc/150?u=3',
    isRead: true,
    isSent: true,
    isOnline: false,
    note: 'Gym time üí™',
  ),
  ChatMock(
    id: '5',
    name: 'Design Team',
    message: 'G·ª≠i file figma m·ªõi.',
    time: 'Yesterday',
    avatarUrl: 'https://i.pravatar.cc/150?u=4',
    isSent: true,
    isRead: false,
    isGroup: true,
  ),
  ChatMock(
    id: '6',
    name: 'Gia ƒë√¨nh üè†',
    message: 'M·∫π: V·ªÅ ƒÉn c∆°m nha con.',
    time: 'Yesterday',
    avatarUrl: 'https://i.pravatar.cc/150?u=10',
    isGroup: true,
    unreadCount: 1,
  ),
  ChatMock(
    id: '7',
    name: 'Minh Kh√¥i',
    message: 'ƒê√£ nh·∫≠n ti·ªÅn.',
    time: 'Mon',
    avatarUrl: 'https://i.pravatar.cc/150?u=6',
    isRead: true,
    isSent: true,
    note: 'Deadline d√≠ ü•≤',
  ),
  ChatMock(
    id: '8',
    name: 'Support',
    message: 'Y√™u c·∫ßu ƒëang x·ª≠ l√Ω.',
    time: 'Sun',
    avatarUrl: 'https://i.pravatar.cc/150?u=7',
  ),
  ChatMock(
    id: '9',
    name: 'John Doe',
    message: 'Hello!',
    time: 'Sun',
    avatarUrl: 'https://i.pravatar.cc/150?u=9',
    isOnline: true,
  ),
  ChatMock(
    id: '10',
    name: 'Sarah',
    message: 'Call me maybe?',
    time: 'Sun',
    avatarUrl: 'https://i.pravatar.cc/150?u=12',
    isOnline: true,
    note: 'Chilling ‚òïÔ∏è',
  ),
];
class MessageMock {
  final String id;
  final String text;
  final bool isMe;
  final String time;
  final String? senderName; // Ch·ªâ d√πng cho Group
  final String? senderAvatar; // Ch·ªâ d√πng cho Group
  final bool isImage; // Gi·∫£ l·∫≠p tin nh·∫Øn ·∫£nh

  MessageMock({
    required this.id,
    required this.text,
    required this.isMe,
    required this.time,
    this.senderName,
    this.senderAvatar,
    this.isImage = false,
  });
}
final List<MessageMock> _mockMessages = [
  MessageMock(id: 'm1', text: 'Oke ch·ªët v·∫≠y nh√©, mai g·∫∑p l·∫°i anh em! üëã', isMe: true, time: '22:30'),
  MessageMock(
    id: 'm2',
    text: 'Nh·∫•t tr√≠, ng·ªß ngon nha m·ªçi ng∆∞·ªùi.',
    isMe: false,
    time: '22:29',
    senderName: 'Tu·∫•n Anh',
    senderAvatar: 'https://i.pravatar.cc/150?u=3',
  ),
  MessageMock(
    id: 'm3',
    text: 'G9 all! üò¥',
    isMe: false,
    time: '22:28',
    senderName: 'H·ªìng Nhung',
    senderAvatar: 'https://i.pravatar.cc/150?u=2',
  ),
  MessageMock(id: 'm4', text: 'Mai nh·ªõ mang theo s·∫°c laptop nha √¥ng, tui qu√™n ·ªü cty r·ªìi.', isMe: true, time: '22:25'),
  MessageMock(
    id: 'm5',
    text: 'Ok √¥ng, ƒë·ªÉ tui note l·∫°i kh√¥ng qu√™n.',
    isMe: false,
    time: '22:24',
    senderName: 'Minh Kh√¥i',
    senderAvatar: 'https://i.pravatar.cc/150?u=6',
  ),
  MessageMock(id: 'm6', text: '√Ä n√£y tui c√≥ g·ª≠i mail confirm v·ªõi b√™n kh√°ch h√†ng r·ªìi ƒë√≥.', isMe: true, time: '21:15'),
  MessageMock(
    id: 'm7',
    text: 'Tuy·ªát v·ªùi, thanks Long nh√©!',
    isMe: false,
    time: '21:14',
    senderName: 'Alberne',
    senderAvatar: 'https://i.pravatar.cc/150?u=1',
  ),
  MessageMock(
    id: 'm8',
    text: 'M·ªçi ng∆∞·ªùi check th·ª≠ c√°i UI n√†y xem ·ªïn kh√¥ng?',
    isMe: false,
    time: '20:00',
    senderName: 'Design Team',
    senderAvatar: 'https://i.pravatar.cc/150?u=4',
  ),
  MessageMock(
    id: 'm9',
    text: 'https://picsum.photos/400/300',
    isMe: false,
    isImage: true,
    time: '20:00',
    senderName: 'Design Team',
    senderAvatar: 'https://i.pravatar.cc/150?u=4',
  ),
  MessageMock(
    id: 'm10',
    text: 'ƒê·∫πp ƒë√≥, nh∆∞ng m√†u n√∫t b·∫•m h∆°i ch√¨m, cho n√≥ n·ªïi h∆°n ch√∫t ƒë∆∞·ª£c kh√¥ng?',
    isMe: true,
    time: '20:05',
  ),
  MessageMock(
    id: 'm11',
    text: 'ƒê·ªìng √Ω v·ªõi Long, chuy·ªÉn sang m√†u gradient xanh t√≠m th·ª≠ xem.',
    isMe: false,
    time: '20:07',
    senderName: 'Sarah',
    senderAvatar: 'https://i.pravatar.cc/150?u=12',
  ),
  MessageMock(
    id: 'm12',
    text: 'Ok ƒë·ªÉ team s·ª≠a l·∫°i r·ªìi g·ª≠i b·∫£n v2 nh√©.',
    isMe: false,
    time: '20:10',
    senderName: 'Design Team',
    senderAvatar: 'https://i.pravatar.cc/150?u=4',
  ),
  MessageMock(
    id: 'm13',
    text:
        'Anh em l∆∞u √Ω ng√†y mai h·ªçp l√∫c 9h s√°ng nh√©. N·ªôi dung cu·ªôc h·ªçp bao g·ªìm:\n1. Review ti·∫øn ƒë·ªô d·ª± √°n\n2. Ph√¢n chia task tu·∫ßn m·ªõi\n3. Th·∫£o lu·∫≠n v·ªÅ v·∫•n ƒë·ªÅ performance c·ªßa App.\nM·ªçi ng∆∞·ªùi chu·∫©n b·ªã b√°o c√°o ƒë·∫ßy ƒë·ªß nha.',
    isMe: false,
    time: '19:30',
    senderName: 'Project Manager',
    senderAvatar: 'https://i.pravatar.cc/150?u=8',
  ),
  MessageMock(
    id: 'm14',
    text: 'ƒê√£ nh·∫≠n th√¥ng tin. Em s·∫Ω chu·∫©n b·ªã slide b√°o c√°o ph·∫ßn Backend.',
    isMe: true,
    time: '19:35',
  ),
  MessageMock(
    id: 'm15',
    text: 'Em xin ph√©p mai v√†o tr·ªÖ 15p do ƒë∆∞a con ƒëi h·ªçc ·∫°.',
    isMe: false,
    time: '19:40',
    senderName: 'H·ªìng Nhung',
    senderAvatar: 'https://i.pravatar.cc/150?u=2',
  ),
  MessageMock(id: 'm16', text: 'T·ªëi qua ƒëi ƒÉn l·∫©u ngon v√£i.', isMe: true, time: 'Yesterday'),
  MessageMock(
    id: 'm17',
    text: 'https://picsum.photos/400/400',
    isMe: true,
    isImage: true,
    time: 'Yesterday',
  ),
  MessageMock(
    id: 'm18',
    text: 'Nh√¨n th√®m th·∫ø ü§§',
    isMe: false,
    time: 'Yesterday',
    senderName: 'Tu·∫•n Anh',
    senderAvatar: 'https://i.pravatar.cc/150?u=3',
  ),
  MessageMock(
    id: 'm19',
    text: 'B·ªØa n√†o r·ªß c·∫£ team ƒëi ƒëi.',
    isMe: false,
    time: 'Yesterday',
    senderName: 'Tu·∫•n Anh',
    senderAvatar: 'https://i.pravatar.cc/150?u=3',
  ),
  MessageMock(id: 'm20', text: 'ƒê·ª£i l√£nh l∆∞∆°ng ƒë√£ √¥ng ∆°i =))', isMe: true, time: 'Yesterday'),
  MessageMock(
    id: 'm21',
    text: 'Fix xong c√°i bug login ch∆∞a Long?',
    isMe: false,
    time: 'Mon',
    senderName: 'Alberne',
    senderAvatar: 'https://i.pravatar.cc/150?u=1',
  ),
  MessageMock(id: 'm22', text: 'Xong r·ªìi nha, ƒëang ch·ªù tester verify l·∫°i.', isMe: true, time: 'Mon'),
  MessageMock(
    id: 'm23',
    text: 'Oke good job.',
    isMe: false,
    time: 'Mon',
    senderName: 'Alberne',
    senderAvatar: 'https://i.pravatar.cc/150?u=1',
  ),
  MessageMock(id: 'm24', text: 'Hello World!', isMe: true, time: 'Sun'),
  MessageMock(
    id: 'm25',
    text: 'Ch√†o m·ª´ng Long gia nh·∫≠p team! üéâ',
    isMe: false,
    time: 'Sun',
    senderName: 'Dev Team',
    senderAvatar: 'https://i.pravatar.cc/150?u=8',
  ),
  MessageMock(id: 'm26', text: 'R·∫•t vui ƒë∆∞·ª£c l√†m vi·ªác c√πng m·ªçi ng∆∞·ªùi ·∫°.', isMe: true, time: 'Sun'),
];

enum ChatFilter { all, unread, groups }

class ChatListPagePreview extends StatefulWidget {
  const ChatListPagePreview({super.key});

  @override
  State<ChatListPagePreview> createState() => _ChatListPagePreviewState();
}

class _ChatListPagePreviewState extends State<ChatListPagePreview> {
  ChatFilter _selectedFilter = ChatFilter.all;

  List<ChatMock> get _filteredChats {
    switch (_selectedFilter) {
      case ChatFilter.unread:
        return _allChats.where((chat) => chat.unreadCount > 0).toList();
      case ChatFilter.groups:
        return _allChats.where((chat) => chat.isGroup).toList();
      case ChatFilter.all:
        return _allChats;
    }
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final backgroundColor = isDark ? Colors.black : Colors.white;
    final surfaceColor = isDark ? const Color(0xFF1C1C1E) : const Color(0xFFF3F4F6);

    return Scaffold(
      backgroundColor: backgroundColor,
      body: CustomScrollView(
        physics: const BouncingScrollPhysics(),
        slivers: [
          SliverAppBar(
            backgroundColor: backgroundColor,
            surfaceTintColor: Colors.transparent,
            floating: true,
            pinned: true,
            centerTitle: false,
            elevation: 0,
            scrolledUnderElevation: 0,
            title: const Text('Chats', style: TextStyle(fontWeight: FontWeight.w800, fontSize: 30)),
            actions: [
              Padding(
                padding: const EdgeInsets.only(right: 16, top: 8),
                child: SizedBox(
                  width: 40,
                  height: 40,
                  child: Material(
                    color: surfaceColor,
                    shape: const CircleBorder(), // ƒê·ªãnh h√¨nh tr√≤n vector
                    clipBehavior: Clip.antiAlias, // Kh·ª≠ rƒÉng c∆∞a
                    child: InkWell(
                      onTap: () {},
                      child: Center(
                        child: SvgPicture.asset(
                          'assets/icons/message-circle-plus.svg',
                          width: 24,
                          height: 24,
                          colorFilter: ColorFilter.mode(isDark ? Colors.white : Colors.black, BlendMode.srcIn),
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              child: Container(
                height: 46,
                decoration: BoxDecoration(color: surfaceColor, borderRadius: BorderRadius.circular(30)),
                child: Row(
                  children: [
                    const SizedBox(width: 16),
                    Icon(Icons.search, color: Colors.grey.shade500, size: 24),
                    const SizedBox(width: 8),
                    Text('Search', style: TextStyle(color: Colors.grey.shade500, fontSize: 17)),
                  ],
                ),
              ),
            ),
          ),
          SliverToBoxAdapter(
            child: SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              child: Row(
                children: [
                  _buildFilterChip('T·∫•t c·∫£', ChatFilter.all, isDark, surfaceColor),
                  const SizedBox(width: 10),
                  _buildFilterChip('Ch∆∞a ƒë·ªçc', ChatFilter.unread, isDark, surfaceColor),
                  const SizedBox(width: 10),
                  _buildFilterChip('Nh√≥m', ChatFilter.groups, isDark, surfaceColor),
                ],
              ),
            ),
          ),
          if (_selectedFilter == ChatFilter.all)
            SliverToBoxAdapter(
              child: SizedBox(
                height: 130,
                child: ListView.builder(
                  scrollDirection: Axis.horizontal,
                  physics: const BouncingScrollPhysics(),
                  padding: const EdgeInsets.symmetric(horizontal: 12),
                  itemCount: 15,
                  itemBuilder: (context, index) {
                    if (index == 0) return _buildMyStoryItem(isDark, surfaceColor);
                    final userIndex = (index - 1) % _allChats.length;
                    return _buildOnlineUserItem(_allChats[userIndex], isDark, surfaceColor);
                  },
                ),
              ),
            ),
          SliverList(
            delegate: SliverChildBuilderDelegate((context, index) {
              final chats = _filteredChats;
              if (index >= chats.length) return null;
              return _ChatItem(chat: chats[index]);
            }, childCount: _filteredChats.length),
          ),

          if (_filteredChats.isEmpty)
            SliverToBoxAdapter(
              child: Padding(
                padding: const EdgeInsets.only(top: 50),
                child: Center(
                  child: Text('Kh√¥ng t√¨m th·∫•y tin nh·∫Øn n√†o', style: TextStyle(color: Colors.grey.shade500)),
                ),
              ),
            ),

          const SliverPadding(padding: EdgeInsets.only(bottom: 30)),
        ],
      ),
    );
  }
  Widget _buildFilterChip(String label, ChatFilter filter, bool isDark, Color surfaceColor) {
    final isSelected = _selectedFilter == filter;
    final bgColor = isSelected ? (isDark ? Colors.white : Colors.black) : surfaceColor;
    final textColor = isSelected ? (isDark ? Colors.black : Colors.white) : (isDark ? Colors.white70 : Colors.black87);
    return InkWell(
      onTap: () => setState(() => _selectedFilter = filter),
      borderRadius: BorderRadius.circular(20),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        decoration: BoxDecoration(color: bgColor, borderRadius: BorderRadius.circular(20)),
        child: Text(
          label,
          style: TextStyle(color: textColor, fontSize: 14, fontWeight: FontWeight.w600),
        ),
      ),
    );
  }

  Widget _buildMyStoryItem(bool isDark, Color surfaceColor) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 10),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          SizedBox(
            height: 75,
            child: Stack(
              alignment: Alignment.bottomCenter,
              clipBehavior: Clip.none,
              children: [
                const CircleAvatar(radius: 30, backgroundImage: NetworkImage('https://i.pravatar.cc/150?u=0')),
                Positioned(
                  top: -8,
                  child: Container(
                    padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                    decoration: BoxDecoration(
                      color: surfaceColor,
                      borderRadius: BorderRadius.circular(20),
                      boxShadow: [
                        if (!isDark)
                          BoxShadow(
                            color: Colors.black.withValues(alpha: 0.05),
                            blurRadius: 4,
                            offset: const Offset(0, 2),
                          ),
                      ],
                    ),
                    child: Text("Ghi ch√∫...", style: TextStyle(fontSize: 11, color: Colors.grey.shade500)),
                  ),
                ),
                Positioned(
                  right: 0,
                  bottom: 0,
                  child: Container(
                    width: 24,
                    height: 24,
                    decoration: BoxDecoration(color: isDark ? Colors.black : Colors.white, shape: BoxShape.circle),
                    padding: const EdgeInsets.all(2.5),
                    child: Container(
                      decoration: const BoxDecoration(color: Colors.blueAccent, shape: BoxShape.circle),
                      child: const Icon(Icons.add, color: Colors.white, size: 18),
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 8),
          Text('Tin c·ªßa b·∫°n', style: TextStyle(fontSize: 12, color: isDark ? Colors.white70 : Colors.grey.shade600)),
        ],
      ),
    );
  }

  Widget _buildOnlineUserItem(ChatMock user, bool isDark, Color surfaceColor) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 10),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          SizedBox(
            height: 75,
            child: Stack(
              alignment: Alignment.bottomCenter,
              clipBehavior: Clip.none,
              children: [
                CircleAvatar(radius: 30, backgroundImage: NetworkImage(user.avatarUrl)),
                if (user.note != null)
                  Positioned(
                    top: -12,
                    child: Container(
                      constraints: const BoxConstraints(maxWidth: 80),
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                      decoration: BoxDecoration(
                        color: isDark ? const Color(0xFF2C2C2E) : Colors.white,
                        borderRadius: BorderRadius.circular(16),
                        border: Border.all(color: isDark ? Colors.transparent : Colors.grey.shade200, width: 1),
                        boxShadow: [
                          if (!isDark)
                            BoxShadow(
                              color: Colors.black.withValues(alpha: 0.08),
                              blurRadius: 8,
                              offset: const Offset(0, 2),
                            ),
                        ],
                      ),
                      child: Text(
                        user.note!,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          fontSize: 11,
                          fontWeight: FontWeight.w600,
                          color: isDark ? Colors.white : Colors.black87,
                        ),
                      ),
                    ),
                  ),
                if (user.isOnline)
                  Positioned(
                    right: 2,
                    bottom: 2,
                    child: Container(
                      width: 16,
                      height: 16,
                      decoration: BoxDecoration(
                        color: const Color(0xFF31A24C),
                        shape: BoxShape.circle,
                        border: Border.all(color: isDark ? Colors.black : Colors.white, width: 2.5),
                      ),
                    ),
                  ),
              ],
            ),
          ),
          const SizedBox(height: 8),
          SizedBox(
            width: 64,
            child: Text(
              user.name.split(' ').first,
              textAlign: TextAlign.center,
              overflow: TextOverflow.ellipsis,
              style: TextStyle(
                fontSize: 12,
                fontWeight: FontWeight.w500,
                color: isDark ? Colors.white70 : Colors.black87,
              ),
            ),
          ),
        ],
      ),
    );
  }
}
class ChatDetailPage extends StatefulWidget {
  final ChatMock chat;

  const ChatDetailPage({super.key, required this.chat});

  @override
  State<ChatDetailPage> createState() => _ChatDetailPageState();
}

class _ChatDetailPageState extends State<ChatDetailPage> {
  final TextEditingController _controller = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  bool _isTyping = false;

  @override
  void initState() {
    super.initState();
    _controller.addListener(() {
      setState(() {
        _isTyping = _controller.text.isNotEmpty;
      });
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final backgroundColor = isDark ? Colors.black : Colors.white;
    final surfaceColor = isDark ? const Color(0xFF1C1C1E) : const Color(0xFFF3F4F6);

    return Scaffold(
      backgroundColor: backgroundColor,
      appBar: _buildAppBar(context, isDark, surfaceColor),
      body: SafeArea(
        child: Column(
          children: [
            Expanded(
              child: GestureDetector(
                onTap: () => FocusScope.of(context).unfocus(),
                child: ListView.builder(
                  controller: _scrollController,
                  reverse: true,
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                  itemCount: _mockMessages.length,
                  itemBuilder: (context, index) {
                    final message = _mockMessages[index];
                    bool isLastMessage = index == 0;
                    return _buildMessageBubble(message, isDark, surfaceColor, isLastMessage);
                  },
                ),
              ),
            ),
            _buildInputBar(isDark, surfaceColor),
          ],
        ),
      ),
    );
  }
  AppBar _buildAppBar(BuildContext context, bool isDark, Color surfaceColor) {
    const appBarIconColor = Colors.blueAccent;

    return AppBar(
      backgroundColor: isDark ? Colors.black : Colors.white,
      surfaceTintColor: Colors.transparent,
      elevation: 0,
      leadingWidth: 40,
      leading: Padding(
        padding: const EdgeInsets.only(left: 8),
        child: IconButton(
          icon: const Icon(Icons.arrow_back_ios_new_rounded, color: appBarIconColor, size: 22),
          onPressed: () => Navigator.pop(context),
        ),
      ),
      title: Row(
        children: [
          Stack(
            children: [
              CircleAvatar(radius: 18, backgroundImage: NetworkImage(widget.chat.avatarUrl)),
              if (widget.chat.isOnline)
                Positioned(
                  right: 0,
                  bottom: 0,
                  child: Container(
                    width: 10,
                    height: 10,
                    decoration: BoxDecoration(
                      color: const Color(0xFF31A24C),
                      shape: BoxShape.circle,
                      border: Border.all(color: isDark ? Colors.black : Colors.white, width: 1.5),
                    ),
                  ),
                ),
            ],
          ),
          const SizedBox(width: 10),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  widget.chat.name,
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w700,
                    color: isDark ? Colors.white : Colors.black,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
                Text(
                  widget.chat.isGroup
                      ? '12 th√†nh vi√™n'
                      : (widget.chat.isOnline ? 'ƒêang ho·∫°t ƒë·ªông' : 'Ho·∫°t ƒë·ªông 15p tr∆∞·ªõc'),
                  style: TextStyle(fontSize: 12, color: Colors.grey.shade500, fontWeight: FontWeight.normal),
                ),
              ],
            ),
          ),
        ],
      ),
      actions: [
        IconButton(
          icon: const Icon(Icons.call_outlined, color: appBarIconColor),
          onPressed: () {},
        ),
        IconButton(
          icon: const Icon(Icons.videocam_outlined, color: appBarIconColor),
          onPressed: () {},
        ),
        IconButton(
          icon: const Icon(Icons.info_outline_rounded, color: appBarIconColor),
          onPressed: () {
            Navigator.push(context, MaterialPageRoute(builder: (context) => ChatInfoPageDemo(chat: widget.chat)));
          },
        ),
        const SizedBox(width: 6),
      ],
      bottom: PreferredSize(
        preferredSize: const Size.fromHeight(1),
        child: Container(color: isDark ? Colors.grey.shade900 : Colors.grey.shade200, height: 1),
      ),
    );
  }
  Widget _buildMessageBubble(MessageMock message, bool isDark, Color surfaceColor, bool isLastMessage) {
    final showAvatar = !message.isMe;
    final showName = !message.isMe && widget.chat.isGroup;
    final screenWidth = MediaQuery.of(context).size.width;
    final bubbleMaxWidth = screenWidth * 0.67;

    return Padding(
      padding: EdgeInsets.only(bottom: isLastMessage ? 5 : 12),
      child: Row(
        mainAxisAlignment: message.isMe ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          if (showAvatar)
            CircleAvatar(radius: 14, backgroundImage: NetworkImage(message.senderAvatar ?? widget.chat.avatarUrl))
          else if (!message.isMe)
            const SizedBox(width: 28),

          const SizedBox(width: 8),

          Flexible(
            child: Column(
              crossAxisAlignment: message.isMe ? CrossAxisAlignment.end : CrossAxisAlignment.start,
              children: [
                if (showName && message.senderName != null)
                  Padding(
                    padding: const EdgeInsets.only(left: 12, bottom: 4),
                    child: Text(message.senderName!, style: TextStyle(fontSize: 11, color: Colors.grey.shade500)),
                  ),
                Container(
                  constraints: BoxConstraints(maxWidth: bubbleMaxWidth),
                  padding: message.isImage
                      ? const EdgeInsets.all(0)
                      : const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                  decoration: BoxDecoration(
                    color: message.isMe
                        ? Colors.blueAccent
                        : (isDark ? const Color(0xFF2C2C2E) : const Color(0xFFE5E7EB)),
                    borderRadius: BorderRadius.only(
                      topLeft: const Radius.circular(18),
                      topRight: const Radius.circular(18),
                      bottomLeft: Radius.circular(message.isMe ? 18 : 4),
                      bottomRight: Radius.circular(message.isMe ? 4 : 18),
                    ),
                    image: message.isImage
                        ? DecorationImage(image: NetworkImage(message.text), fit: BoxFit.cover)
                        : null,
                  ),
                  child: message.isImage
                      ? const SizedBox(width: 220, height: 160)
                      : Text(
                          message.text,
                          style: TextStyle(
                            fontSize: 16,
                            height: 1.3,
                            color: message.isMe ? Colors.white : (isDark ? Colors.white : Colors.black87),
                          ),
                        ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  Widget _buildInputBar(bool isDark, Color surfaceColor) {
    final iconColor = Colors.blueAccent;
    final inputFieldColor = isDark ? const Color(0xFF3A3A3C) : const Color(0xFFF0F2F5);

    return Container(
      color: isDark ? Colors.black : Colors.white,
      child: SafeArea(
        top: false,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Row(
                children: [
                  _buildActionIcon(Icons.add_circle, iconColor, size: 28),
                  _buildActionIcon(Icons.camera_alt_rounded, iconColor, size: 26),
                  _buildActionIcon(Icons.photo_outlined, iconColor, size: 26),
                  _buildActionIcon(Icons.mic_none_rounded, iconColor, size: 26),
                ],
              ),

              const SizedBox(width: 4),
              Expanded(
                child: Container(
                  constraints: const BoxConstraints(minHeight: 44, maxHeight: 120),
                  decoration: BoxDecoration(color: inputFieldColor, borderRadius: BorderRadius.circular(24)),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.end,
                    children: [
                      Expanded(
                        child: TextField(
                          controller: _controller,
                          maxLines: null,
                          textCapitalization: TextCapitalization.sentences,
                          style: TextStyle(color: isDark ? Colors.white : Colors.black, fontSize: 16, height: 1.3),
                          decoration: InputDecoration(
                            hintText: 'Nh·∫Øn tin...',
                            hintStyle: TextStyle(color: Colors.grey.shade500),
                            border: InputBorder.none,
                            focusedBorder: InputBorder.none,
                            enabledBorder: InputBorder.none,
                            errorBorder: InputBorder.none,
                            disabledBorder: InputBorder.none,
                            contentPadding: const EdgeInsets.fromLTRB(16, 12, 8, 12),
                            isDense: true,
                          ),
                        ),
                      ),
                      Padding(
                        padding: const EdgeInsets.only(bottom: 10, right: 12),
                        child: InkWell(
                          onTap: () {},
                          borderRadius: BorderRadius.circular(20),
                          child: Icon(Icons.sentiment_satisfied_alt_rounded, color: iconColor, size: 26),
                        ),
                      ),
                    ],
                  ),
                ),
              ),

              const SizedBox(width: 8),
              Padding(
                padding: const EdgeInsets.only(bottom: 8),
                child: AnimatedSwitcher(
                  duration: const Duration(milliseconds: 200),
                  transitionBuilder: (child, anim) => ScaleTransition(scale: anim, child: child),
                  child: _isTyping
                      ? InkWell(
                          key: const ValueKey('send'),
                          onTap: () {
                            _controller.clear();
                            setState(() => _isTyping = false);
                          },
                          child: Icon(Icons.send_rounded, color: iconColor, size: 28),
                        )
                      : InkWell(
                          key: const ValueKey('like'),
                          onTap: () {},
                          child: Icon(Icons.thumb_up_alt_rounded, color: iconColor, size: 28),
                        ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  Widget _buildActionIcon(IconData icon, Color color, {double size = 26}) {
    return Container(
      margin: const EdgeInsets.only(right: 12, bottom: 10),
      child: InkWell(
        onTap: () {},
        borderRadius: BorderRadius.circular(20),
        child: Icon(icon, color: color, size: size),
      ),
    );
  }
}
class _ChatItem extends StatelessWidget {
  final ChatMock chat;

  const _ChatItem({required this.chat});
  void _showChatOptions(BuildContext context) {
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      builder: (context) {
        final isDark = Theme.of(context).brightness == Brightness.dark;
        final color = isDark ? const Color(0xFF1C1C1E) : Colors.white;

        return Container(
          decoration: BoxDecoration(
            color: color,
            borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
          ),
          child: SafeArea(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  margin: const EdgeInsets.symmetric(vertical: 12),
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: Colors.grey.withValues(alpha: 0.3),
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
                ListTile(
                  leading: const Icon(Icons.mark_chat_read),
                  title: const Text('ƒê√°nh d·∫•u ƒë√£ ƒë·ªçc'),
                  onTap: () => Navigator.pop(context),
                ),
                ListTile(
                  leading: const Icon(Icons.notifications_off),
                  title: const Text('T·∫Øt th√¥ng b√°o'),
                  onTap: () => Navigator.pop(context),
                ),
                ListTile(
                  leading: const Icon(Icons.archive),
                  title: const Text('L∆∞u tr·ªØ'),
                  onTap: () => Navigator.pop(context),
                ),
                ListTile(
                  leading: const Icon(Icons.delete, color: Colors.red),
                  title: const Text('X√≥a ƒëo·∫°n chat', style: TextStyle(color: Colors.red)),
                  onTap: () => Navigator.pop(context),
                ),
                const SizedBox(height: 10),
              ],
            ),
          ),
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final isUnread = chat.unreadCount > 0;

    final nameStyle = TextStyle(
      fontSize: 17,
      fontWeight: isUnread ? FontWeight.w700 : FontWeight.w500,
      color: isDark ? Colors.white : Colors.black,
    );
    final messageStyle = TextStyle(
      fontSize: 15,
      color: isUnread
          ? (isDark ? Colors.white : Colors.black87)
          : (isDark ? Colors.grey.shade400 : Colors.grey.shade600),
      fontWeight: isUnread ? FontWeight.w600 : FontWeight.normal,
    );

    return InkWell(
      onTap: () {
        Navigator.push(context, MaterialPageRoute(builder: (context) => ChatDetailPage(chat: chat)));
      },
      onLongPress: () => _showChatOptions(context),
      overlayColor: WidgetStateProperty.all(Colors.grey.withValues(alpha: 0.1)),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        child: Row(
          children: [
            Stack(
              children: [
                CircleAvatar(radius: 30, backgroundImage: NetworkImage(chat.avatarUrl)),
                if (chat.isGroup)
                  Positioned(
                    right: -2,
                    bottom: -2,
                    child: Container(
                      padding: const EdgeInsets.all(2),
                      decoration: BoxDecoration(color: isDark ? Colors.black : Colors.white, shape: BoxShape.circle),
                      child: CircleAvatar(
                        radius: 10,
                        backgroundColor: Colors.grey.shade200,
                        child: const Icon(Icons.people, size: 12, color: Colors.black54),
                      ),
                    ),
                  )
                else if (chat.isOnline)
                  Positioned(
                    right: 0,
                    bottom: 0,
                    child: Container(
                      width: 18,
                      height: 18,
                      decoration: BoxDecoration(
                        color: const Color(0xFF31A24C),
                        shape: BoxShape.circle,
                        border: Border.all(color: isDark ? Colors.black : Colors.white, width: 3),
                      ),
                    ),
                  ),
              ],
            ),
            const SizedBox(width: 14),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(chat.name, style: nameStyle),
                  const SizedBox(height: 4),
                  Row(
                    children: [
                      Expanded(
                        child: chat.isTyping
                            ? const Text(
                                'ƒêang so·∫°n tin...',
                                style: TextStyle(
                                  fontSize: 14,
                                  fontWeight: FontWeight.bold,
                                  color: Colors.blueAccent,
                                  fontStyle: FontStyle.italic,
                                ),
                              )
                            : Row(
                                children: [
                                  if (chat.isSent)
                                    Text('B·∫°n: ', style: messageStyle.copyWith(fontWeight: FontWeight.normal)),
                                  Expanded(
                                    child: Text(
                                      chat.message,
                                      maxLines: 1,
                                      overflow: TextOverflow.ellipsis,
                                      style: messageStyle,
                                    ),
                                  ),
                                ],
                              ),
                      ),
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 6),
                        child: Text('¬∑', style: messageStyle),
                      ),
                      Text(chat.time, style: messageStyle.copyWith(fontWeight: FontWeight.normal, fontSize: 13)),
                    ],
                  ),
                ],
              ),
            ),
            const SizedBox(width: 8),
            if (chat.unreadCount > 0)
              Container(
                constraints: const BoxConstraints(minWidth: 20, minHeight: 20),
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: const Color(0xFFEF4444), // M√†u ƒë·ªè th√¥ng b√°o
                  borderRadius: BorderRadius.circular(10), // Bo tr√≤n th√†nh Pill shape
                ),
                child: Center(
                  child: Text(
                    chat.unreadCount > 9 ? '9+' : chat.unreadCount.toString(),
                    style: const TextStyle(color: Colors.white, fontSize: 11, fontWeight: FontWeight.bold),
                  ),
                ),
              )
            else if (chat.isSent)
              if (chat.isRead)
                CircleAvatar(radius: 8, backgroundImage: NetworkImage(chat.avatarUrl))
              else
                Icon(Icons.check_circle_outline_rounded, size: 16, color: Colors.grey.shade400),
          ],
        ),
      ),
    );
  }
}
class ChatInfoPageDemo extends StatelessWidget {
  final ChatMock chat;

  const ChatInfoPageDemo({super.key, required this.chat});

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final backgroundColor = isDark ? Colors.black : const Color(0xFFF5F5F5); // N·ªÅn x√°m nh·∫°t cho light mode
    final surfaceColor = isDark ? const Color(0xFF1C1C1E) : Colors.white; // M√†u c√°c kh·ªëi
    final textColor = isDark ? Colors.white : Colors.black;

    return Scaffold(
      backgroundColor: backgroundColor,
      appBar: AppBar(
        backgroundColor: backgroundColor,
        elevation: 0,
        leading: IconButton(
          icon: Icon(Icons.arrow_back_ios_new_rounded, color: textColor),
          onPressed: () => Navigator.pop(context),
        ),
        actions: [
          IconButton(
            icon: Icon(Icons.more_vert_rounded, color: textColor),
            onPressed: () {},
          ),
        ],
      ),
      body: SingleChildScrollView(
        physics: const BouncingScrollPhysics(),
        padding: const EdgeInsets.only(bottom: 40),
        child: Column(
          children: [
            Center(
              child: Column(
                children: [
                  const SizedBox(height: 10),
                  Stack(
                    children: [
                      CircleAvatar(radius: 50, backgroundImage: NetworkImage(chat.avatarUrl)),
                      if (chat.isOnline)
                        Positioned(
                          right: 4,
                          bottom: 4,
                          child: Container(
                            width: 20,
                            height: 20,
                            decoration: BoxDecoration(
                              color: const Color(0xFF31A24C),
                              shape: BoxShape.circle,
                              border: Border.all(color: backgroundColor, width: 3.5),
                            ),
                          ),
                        ),
                    ],
                  ),
                  const SizedBox(height: 16),
                  Text(
                    chat.name,
                    style: TextStyle(fontSize: 24, fontWeight: FontWeight.w800, color: textColor),
                  ),
                  const SizedBox(height: 4),
                  if (!chat.isGroup)
                    Text(
                      chat.isOnline ? 'ƒêang ho·∫°t ƒë·ªông' : 'Ho·∫°t ƒë·ªông 15 ph√∫t tr∆∞·ªõc',
                      style: TextStyle(fontSize: 14, color: Colors.grey.shade500),
                    ),
                ],
              ),
            ),

            const SizedBox(height: 24),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                _buildActionButton(context, Icons.call, 'G·ªçi tho·∫°i', isDark),
                _buildActionButton(context, Icons.videocam, 'Video', isDark),
                _buildActionButton(context, Icons.person, 'Trang c√° nh√¢n', isDark),
                _buildActionButton(context, Icons.notifications_off, 'T·∫Øt b√°o', isDark),
              ],
            ),

            const SizedBox(height: 24),
            _buildSection(
              title: 'T√πy ch·ªânh',
              children: [
                _buildListTile(
                  icon: Icons.palette_rounded,
                  iconColor: Colors.purpleAccent,
                  title: 'Ch·ªß ƒë·ªÅ',
                  subtitle: 'M·∫∑c ƒë·ªãnh',
                  isDark: isDark,
                  onTap: () {},
                ),
                _buildListTile(
                  icon: Icons.emoji_emotions_rounded,
                  iconColor: Colors.blueAccent,
                  title: 'Bi·ªÉu t∆∞·ª£ng c·∫£m x√∫c',
                  subtitle: 'üëç',
                  isDark: isDark,
                  onTap: () {},
                ),
                _buildListTile(
                  icon: Icons.text_fields_rounded,
                  iconColor: Colors.green,
                  title: 'Bi·ªát danh',
                  isDark: isDark,
                  onTap: () {},
                ),
              ],
              isDark: isDark,
              surfaceColor: surfaceColor,
            ),

            const SizedBox(height: 20),
            _buildSection(
              title: 'File & ƒêa ph∆∞∆°ng ti·ªán',
              children: [
                _buildListTile(
                  icon: Icons.image_rounded,
                  iconColor: Colors.pinkAccent,
                  title: 'Xem ·∫£nh & video',
                  isDark: isDark,
                  onTap: () {},
                ),
                Container(
                  height: 100,
                  padding: const EdgeInsets.only(left: 16, bottom: 16, top: 4),
                  child: ListView.separated(
                    scrollDirection: Axis.horizontal,
                    itemCount: 8,
                    separatorBuilder: (ctx, i) => const SizedBox(width: 8),
                    itemBuilder: (ctx, i) {
                      return Container(
                        width: 100,
                        decoration: BoxDecoration(
                          borderRadius: BorderRadius.circular(12),
                          image: DecorationImage(
                            image: NetworkImage('https://picsum.photos/200/200?random=$i'),
                            fit: BoxFit.cover,
                          ),
                        ),
                      );
                    },
                  ),
                ),
                _buildListTile(
                  icon: Icons.folder_rounded,
                  iconColor: Colors.orangeAccent,
                  title: 'Xem file',
                  isDark: isDark,
                  onTap: () {},
                ),
              ],
              isDark: isDark,
              surfaceColor: surfaceColor,
            ),

            const SizedBox(height: 20),
            _buildSection(
              title: 'Quy·ªÅn ri√™ng t∆∞',
              children: [
                _buildListTile(
                  icon: Icons.notifications_none_rounded,
                  iconColor: isDark ? Colors.white : Colors.black54,
                  title: 'T·∫Øt th√¥ng b√°o',
                  isDark: isDark,
                  hasSwitch: true,
                ),
                _buildListTile(
                  icon: Icons.search_rounded,
                  iconColor: isDark ? Colors.white : Colors.black54,
                  title: 'T√¨m ki·∫øm trong cu·ªôc tr√≤ chuy·ªán',
                  isDark: isDark,
                  onTap: () {},
                ),
                _buildListTile(
                  icon: Icons.block_rounded,
                  iconColor: Colors.redAccent,
                  title: 'Ch·∫∑n',
                  textColor: Colors.redAccent,
                  isDark: isDark,
                  onTap: () {},
                ),
                _buildListTile(
                  icon: Icons.report_gmailerrorred_rounded,
                  iconColor: Colors.redAccent,
                  title: 'B√°o c√°o',
                  textColor: Colors.redAccent,
                  isDark: isDark,
                  hideArrow: true, // Kh√¥ng hi·ªán m≈©i t√™n cho m·ª•c b√°o c√°o
                  onTap: () {},
                ),
              ],
              isDark: isDark,
              surfaceColor: surfaceColor,
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildActionButton(BuildContext context, IconData icon, String label, bool isDark) {
    return Column(
      children: [
        Container(
          width: 48,
          height: 48,
          decoration: BoxDecoration(
            color: isDark ? const Color(0xFF2C2C2E) : Colors.grey.shade200,
            shape: BoxShape.circle,
          ),
          child: InkWell(
            onTap: () {},
            borderRadius: BorderRadius.circular(24),
            child: Icon(icon, color: isDark ? Colors.white : Colors.black87, size: 22),
          ),
        ),
        const SizedBox(height: 8),
        Text(
          label,
          style: TextStyle(fontSize: 12, fontWeight: FontWeight.w500, color: isDark ? Colors.white70 : Colors.black87),
        ),
      ],
    );
  }
  Widget _buildSection({
    required String title,
    required List<Widget> children,
    required bool isDark,
    required Color surfaceColor,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 16, bottom: 8),
          child: Text(
            title,
            style: TextStyle(fontSize: 13, fontWeight: FontWeight.w600, color: Colors.grey.shade500),
          ),
        ),
        Container(
          width: double.infinity,
          decoration: BoxDecoration(
            color: surfaceColor,
          ),
          child: Column(children: children),
        ),
      ],
    );
  }
  Widget _buildListTile({
    required IconData icon,
    required Color iconColor,
    required String title,
    String? subtitle,
    required bool isDark,
    bool hasSwitch = false,
    Color? textColor,
    bool hideArrow = false,
    VoidCallback? onTap,
  }) {
    return InkWell(
      onTap: hasSwitch ? null : onTap,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            Icon(icon, color: iconColor, size: 26),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                      color: textColor ?? (isDark ? Colors.white : Colors.black),
                    ),
                  ),
                  if (subtitle != null) Text(subtitle, style: TextStyle(fontSize: 13, color: Colors.grey.shade500)),
                ],
              ),
            ),
            if (hasSwitch)
              Transform.scale(
                scale: 0.8,
                child: Switch(
                  value: false, // Demo state
                  onChanged: (val) {},
                  activeTrackColor: Colors.green,
                  activeThumbColor: Colors.white,
                ),
              )
            else if (!hideArrow)
              Icon(Icons.arrow_forward_ios_rounded, size: 16, color: Colors.grey.shade400),
          ],
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/pages/chat_list_page.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/conversation_filter.dart';
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_websocket_provider_new.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/user_notes_provider.dart';
import 'package:chattrix_ui/features/chat/presentation/state/conversations_notifier.dart';
import 'package:chattrix_ui/features/chat/presentation/state/filter_notifier.dart';
import 'package:chattrix_ui/features/chat/presentation/state/online_users_notifier.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/conversation_list_item.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/filter_chip_widget.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/note_dialog.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class ChatListPage extends HookConsumerWidget {
  const ChatListPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.watch(webSocketConnectionProvider);

    return Scaffold(
      appBar: _buildAppBar(context),
      body: const CustomScrollView(
        physics: ClampingScrollPhysics(),
        slivers: [_HeaderSearch(), _FilterBar(), _OnlineStoryList(), _ConversationList()],
      ),
    );
  }

  AppBar _buildAppBar(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    return AppBar(
      elevation: 0,
      scrolledUnderElevation: 0,
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      surfaceTintColor: Colors.transparent,
      toolbarHeight: 60,
      title: Text(
        'Chats',
        style: TextStyle(fontSize: 24, fontWeight: FontWeight.w700, color: isDark ? Colors.white : Colors.black),
      ),
      actions: [
        Padding(
          padding: const EdgeInsets.only(right: 8),
          child: IconButton(
            icon: SvgPicture.asset(
              'assets/icons/message-circle-plus.svg',
              width: 24,
              height: 24,
              colorFilter: ColorFilter.mode(Theme.of(context).colorScheme.primary, BlendMode.srcIn),
            ),
            onPressed: () => context.push('/new-chat'),
            tooltip: 'New chat',
          ),
        ),
      ],
      bottom: PreferredSize(
        preferredSize: const Size.fromHeight(1),
        child: Container(
          height: 0.5,
          color: isDark ? Colors.grey.withValues(alpha: 0.2) : Colors.grey.withValues(alpha: 0.1),
        ),
      ),
    );
  }
}

class _HeaderSearch extends StatelessWidget {
  const _HeaderSearch();

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final bgColor = isDark ? const Color(0xFF2C2C2E) : const Color(0xFFF3F4F6);
    final iconColor = isDark ? Colors.grey[400] : Colors.grey[600];

    return SliverToBoxAdapter(
      child: Padding(
        padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
        child: GestureDetector(
          onTap: () => context.push('/search-conversations'),
          child: Container(
            height: 40,
            decoration: BoxDecoration(color: bgColor, borderRadius: BorderRadius.circular(20)),
            child: Row(
              children: [
                Padding(
                  padding: const EdgeInsets.only(left: 14, right: 10),
                  child: Icon(Icons.search, color: iconColor, size: 20),
                ),
                Expanded(
                  child: Text('Search conversations', style: TextStyle(fontSize: 15, color: iconColor)),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class _FilterBar extends ConsumerWidget {
  const _FilterBar();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentFilter = ref.watch(filterProvider);
    final notifier = ref.read(conversationsProvider.notifier);

    return SliverToBoxAdapter(
      child: Container(
        height: 44,
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
        child: ListView(
          scrollDirection: Axis.horizontal,
          physics: const BouncingScrollPhysics(),
          children: [
            FilterChipWidget(
              label: 'All',
              isSelected: currentFilter == ConversationFilter.all,
              onTap: () => notifier.applyFilter(ConversationFilter.all),
            ),
            const SizedBox(width: 8),
            FilterChipWidget(
              label: 'Unread',
              isSelected: currentFilter == ConversationFilter.unread,
              onTap: () => notifier.applyFilter(ConversationFilter.unread),
            ),
            const SizedBox(width: 8),
            FilterChipWidget(
              label: 'Groups',
              isSelected: currentFilter == ConversationFilter.groups,
              onTap: () => notifier.applyFilter(ConversationFilter.groups),
            ),
          ],
        ),
      ),
    );
  }
}

class _OnlineStoryList extends ConsumerWidget {
  const _OnlineStoryList();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentFilter = ref.watch(filterProvider);
    if (currentFilter != ConversationFilter.all) return const SliverToBoxAdapter(child: SizedBox.shrink());

    final onlineUsersAsync = ref.watch(onlineUsersProvider);

    return SliverToBoxAdapter(
      child: onlineUsersAsync.when(
        data: (onlineUsers) {
          final me = ref.watch(currentUserProvider);
          final notes = ref.watch(userNotesProvider);
          final currentUserId = me?.id.toString() ?? '';
          final totalItems = onlineUsers.length + 1; // +1 for "My Story"

          return Container(
            height: 110,
            margin: const EdgeInsets.symmetric(vertical: 10),
            child: ListView.separated(
              scrollDirection: Axis.horizontal,
              physics: const BouncingScrollPhysics(),
              padding: const EdgeInsets.symmetric(horizontal: 16),
              itemCount: totalItems,
              separatorBuilder: (_, _) => const SizedBox(width: 12),
              itemBuilder: (context, index) {
                if (index == 0) {
                  final myNote = notes[currentUserId];
                  return _StoryItem(
                    name: 'My Story',
                    imageUrl: me?.avatarUrl,
                    note: myNote?.content,
                    isMe: true,
                    isOnline: true,
                    onTap: () => showDialog(
                      context: context,
                      builder: (_) => NoteDialog(currentUserId: currentUserId, existingNote: myNote),
                    ),
                  );
                }
                final user = onlineUsers[index - 1];
                final userNote = notes[user.id.toString()];
                return _StoryItem(
                  name: user.username,
                  imageUrl: user.avatarUrl,
                  note: userNote?.content,
                  isMe: false,
                  isOnline: true,
                  onTap: () => context.push('/chat/${user.id}'),
                );
              },
            ),
          );
        },
        loading: () => const SizedBox(height: 110, child: Center(child: CircularProgressIndicator())),
        error: (_, _) => const SizedBox.shrink(),
      ),
    );
  }
}

class _ConversationList extends ConsumerWidget {
  const _ConversationList();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final conversationsAsync = ref.watch(conversationsProvider);
    final me = ref.watch(currentUserProvider);

    return conversationsAsync.when(
      data: (conversations) {
        if (conversations.isEmpty) {
          return const SliverFillRemaining(child: Center(child: Text('No conversations yet')));
        }
        return SliverList(
          delegate: SliverChildBuilderDelegate((context, index) {
            final conversation = conversations[index];
            return ConversationListItem(
              conversation: conversation,
              currentUser: me,
              onTap: () => context.push('/chat/${conversation.id}'),
            );
          }, childCount: conversations.length),
        );
      },
      loading: () => const SliverFillRemaining(child: Center(child: CircularProgressIndicator())),
      error: (error, _) => SliverFillRemaining(child: _ErrorView(error: error)),
    );
  }
}

class _ErrorView extends ConsumerWidget {
  final Object error;

  const _ErrorView({required this.error});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    if (error is! Failure) return Center(child: Text("Error: $error"));

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.error_outline, size: 64, color: Colors.red),
          const SizedBox(height: 16),
          const Text('Failed to load conversations'),
          const SizedBox(height: 24),
          ElevatedButton(
            onPressed: () => ref.read(conversationsProvider.notifier).refresh(),
            child: const Text('Retry'),
          ),
        ],
      ),
    );
  }
}

class _StoryItem extends StatelessWidget {
  final String name;
  final String? imageUrl;
  final String? note;
  final bool isOnline;
  final String? lastSeenBadge;
  final bool isMe;
  final VoidCallback? onTap;

  const _StoryItem({
    required this.name,
    this.imageUrl,
    this.note,
    this.isOnline = false,
    this.lastSeenBadge,
    this.isMe = false,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    const double avatarSize = 60.0;
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final textColor = isDark ? Colors.grey[300] : Colors.black87;

    return GestureDetector(
      onTap: onTap,
      child: SizedBox(
        width: 76,
        child: Stack(
          clipBehavior: Clip.none,
          alignment: Alignment.bottomCenter,
          children: [
            Column(
              mainAxisSize: MainAxisSize.min,
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                SizedBox(
                  height: avatarSize,
                  width: avatarSize,
                  child: _AvatarWithBadge(
                    imageUrl: imageUrl,
                    name: name,
                    isOnline: isOnline,
                    lastSeenBadge: lastSeenBadge,
                    isMe: isMe,
                    radius: avatarSize / 2,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  isMe ? 'My Story' : name,
                  style: TextStyle(fontSize: 11, fontWeight: FontWeight.w600, color: textColor),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  textAlign: TextAlign.center,
                ),
              ],
            ),
            if (note != null && note!.isNotEmpty)
              Positioned(
                bottom: 65,
                left: -10,
                right: -10,
                child: Center(child: _MessengerBubble(text: note!)),
              ),
          ],
        ),
      ),
    );
  }
}

class _AvatarWithBadge extends StatelessWidget {
  final String? imageUrl;
  final String name;
  final bool isOnline;
  final String? lastSeenBadge;
  final bool isMe;
  final double radius;

  const _AvatarWithBadge({
    this.imageUrl,
    required this.name,
    required this.isOnline,
    this.lastSeenBadge,
    required this.isMe,
    required this.radius,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    const fbGreen = Color(0xFF31A24C);
    final bgColor = theme.scaffoldBackgroundColor;
    final fallbackBg = isMe ? (isDark ? Colors.grey[700] : Colors.grey[200]) : theme.colorScheme.primary;
    final fallbackText = isMe ? (isDark ? Colors.white : Colors.black) : Colors.white;

    Widget avatarContent;
    if (imageUrl != null && imageUrl!.isNotEmpty) {
      avatarContent = Image.network(
        imageUrl!,
        fit: BoxFit.cover,
        width: radius * 2,
        height: radius * 2,
        errorBuilder: (_, _, _) => Icon(Icons.person, color: Colors.grey[400]),
      );
    } else {
      avatarContent = Container(
        color: fallbackBg,
        alignment: Alignment.center,
        child: Text(
          name.isNotEmpty ? name[0].toUpperCase() : 'U',
          style: TextStyle(color: fallbackText, fontSize: radius, fontWeight: FontWeight.bold),
        ),
      );
    }

    return Stack(
      clipBehavior: Clip.none,
      children: [
        ClipOval(
          clipBehavior: Clip.antiAliasWithSaveLayer,
          child: SizedBox(width: radius * 2, height: radius * 2, child: avatarContent),
        ),
        if (isMe)
          Positioned(
            bottom: 0,
            right: 0,
            child: Container(
              decoration: BoxDecoration(color: bgColor, shape: BoxShape.circle),
              padding: const EdgeInsets.all(2),
              child: const Icon(Icons.add_circle, color: Colors.black, size: 20),
            ),
          )
        else if (isOnline)
          Positioned(
            bottom: 2,
            right: 2,
            child: _StatusBadge(color: fbGreen, borderColor: bgColor, isCircle: true),
          )
        else if (lastSeenBadge != null)
          Positioned(
            bottom: -2,
            right: -4,
            child: _StatusBadge(
              color: Colors.green.shade50,
              borderColor: bgColor,
              isCircle: false,
              child: Text(
                lastSeenBadge!,
                style: const TextStyle(fontSize: 9, fontWeight: FontWeight.w800, color: fbGreen, height: 1.0),
              ),
            ),
          ),
      ],
    );
  }
}

class _StatusBadge extends StatelessWidget {
  final Color color;
  final Color borderColor;
  final bool isCircle;
  final Widget? child;

  const _StatusBadge({required this.color, required this.borderColor, required this.isCircle, this.child});

  @override
  Widget build(BuildContext context) {
    final container = Container(
      width: isCircle ? 15 : null,
      height: isCircle ? 15 : null,
      padding: isCircle ? null : const EdgeInsets.symmetric(horizontal: 5, vertical: 2),
      decoration: BoxDecoration(
        color: color,
        shape: isCircle ? BoxShape.circle : BoxShape.rectangle,
        borderRadius: isCircle ? null : BorderRadius.circular(10),
        border: Border.all(color: borderColor, width: 2),
      ),
      alignment: Alignment.center,
      child: child,
    );

    return isCircle ? ClipOval(child: container) : ClipRRect(borderRadius: BorderRadius.circular(10), child: container);
  }
}

class _MessengerBubble extends StatelessWidget {
  final String text;

  const _MessengerBubble({required this.text});

  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      painter: _BubblePainter(),
      child: Container(
        padding: const EdgeInsets.only(bottom: 12),
        child: Container(
          constraints: const BoxConstraints(minWidth: 40, maxWidth: 85),
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          child: Text(
            text,
            style: const TextStyle(fontSize: 11, fontWeight: FontWeight.w500, color: Colors.black87, height: 1.2),
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
            textAlign: TextAlign.center,
          ),
        ),
      ),
    );
  }
}

class _BubblePainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final fillPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.fill;
    final borderPaint = Paint()
      ..color = Colors.grey.shade400
      ..style = PaintingStyle.stroke
      ..strokeWidth = 0.5;

    final double bodyBottom = size.height - 12;
    final bodyPath = Path()
      ..addRRect(
        RRect.fromLTRBAndCorners(
          0,
          0,
          size.width,
          bodyBottom,
          topLeft: const Radius.circular(18),
          topRight: const Radius.circular(18),
          bottomLeft: const Radius.circular(18),
          bottomRight: const Radius.circular(18),
        ),
      );

    final tailPath = Path()
      ..addOval(Rect.fromCircle(center: Offset(size.width * 0.22, bodyBottom), radius: 5))
      ..addOval(Rect.fromCircle(center: Offset(size.width * 0.30, bodyBottom + 8), radius: 2.5));

    final finalPath = Path.combine(PathOperation.union, bodyPath, tailPath);

    canvas.drawShadow(finalPath, Colors.black.withValues(alpha: 0.1), 4.0, true);
    canvas.drawPath(finalPath, fillPaint);
    canvas.drawPath(finalPath, borderPaint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

================================================================
FILE: lib/features/chat/presentation/pages/chat_view_page.dart
================================================================
import 'dart:async';

import 'package:chattrix_ui/core/domain/enums/enums.dart';
import 'package:chattrix_ui/core/widgets/user_avatar.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/call/domain/entities/call_type.dart';
import 'package:chattrix_ui/features/call/presentation/state/call_notifier.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_providers.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/typing_providers.dart';
import 'package:chattrix_ui/features/chat/presentation/utils/conversation_utils.dart';
import 'package:chattrix_ui/features/chat/presentation/utils/typing_debouncer.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/attachment_picker_bottom_sheet.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/edit_message_dialog.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_bubble.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_reactions.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/reply_message_preview.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/typing_indicator_widget.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/voice_recorder_widget.dart';
import 'package:chattrix_ui/features/chat/services/cloudinary_provider.dart';
import 'package:chattrix_ui/features/chat/services/media_picker_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class ChatViewPage extends HookConsumerWidget {
  const ChatViewPage({super.key, required this.chatId});

  final String chatId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final controller = useTextEditingController();
    final scrollController = useScrollController();
    final showScrollButton = useState(false);
    final previousMessageCount = useRef(0);
    final previousFirstMessageId = useRef<int?>(null);
    final shouldAutoScroll = useRef(true);
    final hasNewMessages = useState(false);
    final replyToMessage = useState<Message?>(null);

    final textTheme = Theme.of(context).textTheme;
    final primaryColor = const Color(0xFF0084FF);
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final backgroundColor = isDark ? const Color(0xFF1E1E1E) : Colors.white;

    final me = ref.watch(currentUserProvider);
    final messagesAsync = ref.watch(messagesProvider(chatId));
    final wsConnection = ref.watch(webSocketConnectionProvider);
    final wsDataSource = ref.watch(chatWebSocketDataSourceProvider);

    final conversationsAsync = ref.watch(conversationsProvider);
    final conversation = conversationsAsync.value?.firstWhere(
      (c) => c.id.toString() == chatId,
      orElse: () => conversationsAsync.value!.first,
    );
    useEffect(() {
      void onScroll() {
        if (scrollController.hasClients) {
          final pixels = scrollController.position.pixels;
          final isAtBottom = pixels <= 100;
          showScrollButton.value = !isAtBottom;
          shouldAutoScroll.value = isAtBottom;
          if (isAtBottom && hasNewMessages.value) {
            hasNewMessages.value = false;
          }
        }
      }

      scrollController.addListener(onScroll);
      return () => scrollController.removeListener(onScroll);
    }, [scrollController]);

    useEffect(() {
      messagesAsync.whenData((messages) {
        final newCount = messages.length;
        final oldCount = previousMessageCount.value;
        final newFirstId = messages.isNotEmpty ? messages.first.id : null;
        final oldFirstId = previousFirstMessageId.value;

        final hasNewMessage =
            (oldFirstId != null && newFirstId != null && newFirstId != oldFirstId) ||
            (newCount > oldCount && oldCount > 0);

        if (hasNewMessage) {
          if (shouldAutoScroll.value) {
            hasNewMessages.value = false;
            WidgetsBinding.instance.addPostFrameCallback((_) {
              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (scrollController.hasClients) {
                  scrollController.animateTo(0, duration: const Duration(milliseconds: 300), curve: Curves.easeOut);
                }
              });
            });
          } else {
            hasNewMessages.value = true;
          }
        }
        previousMessageCount.value = newCount;
        previousFirstMessageId.value = newFirstId;
      });
      return null;
    }, [messagesAsync]);
    Future<void> sendMessage({String? specificContent}) async {
      final text = specificContent ?? controller.text.trim();
      if (text.isEmpty) return;

      final replyId = replyToMessage.value?.id;
      if (specificContent == null) controller.clear(); // Ch·ªâ clear n·∫øu g·ª≠i t·ª´ input
      replyToMessage.value = null;

      if (wsConnection.isConnected) {
        wsDataSource.sendMessage(conversationId: chatId, content: text, replyToMessageId: replyId);
      } else {
        final usecase = ref.read(sendMessageUsecaseProvider);
        final result = await usecase(conversationId: chatId, content: text, replyToMessageId: replyId);
        result.fold(
          (failure) => ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(failure.message))),
          (_) => ref.read(messagesProvider(chatId).notifier).refresh(),
        );
      }
    }
    Future<void> handleReaction(Message message, String emoji) async {
      final usecase = ref.read(toggleReactionUsecaseProvider);
      await usecase(messageId: message.id.toString(), emoji: emoji);
      ref.read(messagesProvider(chatId).notifier).refresh();
    }

    Future<void> handleEditMessage(Message message) async {
      final newContent = await showDialog<String>(
        context: context,
        builder: (context) => EditMessageDialog(initialContent: message.content),
      );
      if (newContent != null && newContent.isNotEmpty) {
        final usecase = ref.read(editMessageUsecaseProvider);
        await usecase(messageId: message.id.toString(), content: newContent);
        ref.read(messagesProvider(chatId).notifier).refresh();
      }
    }

    Future<void> handleDeleteMessage(Message message) async {
      final usecase = ref.read(deleteMessageUsecaseProvider);
      await usecase(messageId: message.id.toString());
      ref.read(messagesProvider(chatId).notifier).refresh();
    }

    void scrollToBottom() {
      if (scrollController.hasClients) {
        scrollController.animateTo(0, duration: const Duration(milliseconds: 300), curve: Curves.easeOut);
      }
    }
    PreferredSizeWidget buildAppBar() {
      return AppBar(
        elevation: 0.5,
        scrolledUnderElevation: 0,
        backgroundColor: backgroundColor,
        surfaceTintColor: Colors.transparent,
        leadingWidth: 40,
        leading: IconButton(
          icon: Icon(Icons.arrow_back, color: primaryColor),
          onPressed: () => context.pop(),
        ),
        title: InkWell(
          onTap: () {
            if (conversation != null) context.push('/chat-info', extra: conversation);
          },
          child: Row(
            children: [
              Stack(
                children: [
                  UserAvatar(
                    displayName:  'User $chatId',
                    avatarUrl: conversation != null
                        ? ConversationUtils.getOtherParticipantAvatarUrl(conversation, me)
                        : null,
                    radius: 20,
                  ),
                  if (conversation != null && ConversationUtils.isUserOnline(conversation, me))
                    Positioned(
                      bottom: 0,
                      right: 0,
                      child: Container(
                        width: 13,
                        height: 13,
                        decoration: BoxDecoration(
                          color: const Color(0xFF31A24C), // Green status
                          shape: BoxShape.circle,
                          border: Border.all(color: backgroundColor, width: 2.5),
                        ),
                      ),
                    ),
                ],
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'User $chatId',
                      style: TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.w700,
                        color: isDark ? Colors.white : Colors.black,
                      ),
                    ),
                    if (conversation != null && conversation.type == ConversationType.direct)
                      Builder(
                        builder: (context) {
                          final isOnline = ConversationUtils.isUserOnline(conversation, me);
                          return Text(
                            isOnline ? 'Active now' : 'Offline',
                            style: TextStyle(
                              fontSize: 12,
                              color: isOnline ? Colors.green[600] : Colors.grey,
                              fontWeight: FontWeight.w500,
                            ),
                          );
                        },
                      )
                    else
                      Text(
                        wsConnection.isConnected ? 'Connected' : 'Connecting...',
                        style: TextStyle(fontSize: 12, color: Colors.grey),
                      ),
                  ],
                ),
              ),
            ],
          ),
        ),
        actions: [
          IconButton(
            icon: Icon(Icons.call, color: primaryColor),
            onPressed: () {
              if (conversation != null && conversation.type == ConversationType.direct) {
                final otherUser = ConversationUtils.getOtherUser(conversation, me);
                if (otherUser != null) {
                  ref.read(callProvider.notifier).initiateCall(otherUser.id, CallType.audio);
                  context.push('/call');
                }
              }
            },
          ),
          IconButton(
            icon: Icon(Icons.videocam, color: primaryColor),
            onPressed: () {
              if (conversation != null && conversation.type == ConversationType.direct) {
                final otherUser = ConversationUtils.getOtherUser(conversation, me);
                if (otherUser != null) {
                  ref.read(callProvider.notifier).initiateCall(otherUser.id, CallType.video);
                  context.push('/call');
                }
              }
            },
          ),
          IconButton(
            icon: Icon(Icons.info_outline, color: primaryColor),
            onPressed: () {
              if (conversation != null) context.push('/chat-info', extra: conversation);
            },
          ),
          const SizedBox(width: 8),
        ],
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(1),
          child: Container(height: 0.5, color: isDark ? Colors.grey.withOpacity(0.2) : Colors.grey.withOpacity(0.1)),
        ),
      );
    }

    return Scaffold(
      backgroundColor: backgroundColor,
      appBar: buildAppBar(),
      body: Stack(
        children: [
          Column(
            children: [
              Expanded(
                child: messagesAsync.when(
                  data: (messages) {
                    final repliedMessageMap = useMemoized(() {
                      final map = <int, Message>{};
                      for (final msg in messages) map[msg.id] = msg;
                      return map;
                    }, [messages]);

                    return ListView.builder(
                      controller: scrollController,
                      reverse: true,
                      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
                      itemCount: messages.length,
                      itemBuilder: (context, index) {
                        final m = messages[index];
                        final isMe = m.senderId == me?.id;
                        final repliedMsg = m.replyToMessageId != null ? repliedMessageMap[m.replyToMessageId] : null;
                        bool showAvatar = !isMe;
                        if (index < messages.length - 1) {
                          if (messages[index + 1].senderId == m.senderId) {
                            showAvatar = false;
                          }
                        }
                        return Padding(
                          padding: const EdgeInsets.only(bottom: 2),
                          child: Row(
                            mainAxisAlignment: isMe ? MainAxisAlignment.end : MainAxisAlignment.start,
                            crossAxisAlignment: CrossAxisAlignment.end,
                            children: [
                              if (!isMe) ...[
                                SizedBox(
                                  width: 32,
                                  height: 32,
                                  child: showAvatar
                                      ? UserAvatar(
                                          displayName: m.senderFullName ?? 'U',
                                          avatarUrl: m.sender?.avatarUrl,
                                          radius: 16,
                                        )
                                      : null,
                                ),
                                const SizedBox(width: 8),
                              ],

                              Flexible(
                                child: MessageBubble(
                                  message: m,
                                  isMe: isMe,
                                  currentUserId: me?.id,
                                  replyToMessage: repliedMsg,
                                  onReply: () => replyToMessage.value = m,
                                  onReactionTap: (emoji) => handleReaction(m, emoji),
                                  onAddReaction: () => showReactionPicker(context, (emoji) => handleReaction(m, emoji)),
                                  onEdit: isMe ? () => handleEditMessage(m) : null,
                                  onDelete: isMe ? () => handleDeleteMessage(m) : null,
                                ),
                              ),
                            ],
                          ),
                        );
                      },
                    );
                  },
                  loading: () => const Center(child: CircularProgressIndicator()),
                  error: (e, st) => Center(child: Text('Failed to load messages', style: textTheme.bodyMedium)),
                ),
              ),
              Column(
                children: [
                  if (replyToMessage.value != null)
                    ReplyMessagePreview(
                      replyToMessage: replyToMessage.value!,
                      onCancel: () => replyToMessage.value = null,
                    ),
                  _InputBar(controller: controller, onSend: sendMessage, chatId: chatId, isDark: isDark),
                ],
              ),
            ],
          ),
          if (showScrollButton.value)
            Positioned(
              right: 16,
              bottom: replyToMessage.value != null ? 160 : 100,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  if (hasNewMessages.value)
                    Container(
                      margin: const EdgeInsets.only(bottom: 8),
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                      decoration: BoxDecoration(
                        color: primaryColor,
                        borderRadius: BorderRadius.circular(16),
                        boxShadow: [BoxShadow(color: Colors.black12, blurRadius: 4, offset: const Offset(0, 2))],
                      ),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.arrow_downward, size: 16, color: Colors.white),
                          const SizedBox(width: 4),
                          Text(
                            'New',
                            style: textTheme.labelSmall?.copyWith(color: Colors.white, fontWeight: FontWeight.bold),
                          ),
                        ],
                      ),
                    ),
                  FloatingActionButton.small(
                    onPressed: () {
                      scrollToBottom();
                      hasNewMessages.value = false;
                    },
                    backgroundColor: primaryColor,
                    foregroundColor: Colors.white,
                    child: const Icon(Icons.keyboard_arrow_down),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }
}
class _InputBar extends HookConsumerWidget {
  const _InputBar({required this.controller, required this.onSend, required this.chatId, required this.isDark});

  final TextEditingController controller;
  final Function({String? specificContent}) onSend;
  final String chatId;
  final bool isDark;
  Future<void> _handleAttachment(BuildContext context, WidgetRef ref, AttachmentType type) async {
    final mediaPickerService = ref.read(mediaPickerServiceProvider);
    final cloudinaryService = ref.read(cloudinaryServiceProvider);
    final sendMessageUsecase = ref.read(sendMessageUsecaseProvider);
    if (type == AttachmentType.camera) {
      final file = await mediaPickerService.takePhoto();
      if (file != null) {
        final result = await cloudinaryService.uploadImage(file);
        await sendMessageUsecase(conversationId: chatId, content: 'Photo', type: 'IMAGE', mediaUrl: result.url);
        ref.read(messagesProvider(chatId).notifier).refresh();
      }
    }
  }

  Future<void> _showVoiceRecorder(BuildContext context, WidgetRef ref) async {
    await showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (ctx) => VoiceRecorderWidget(
        onRecordingComplete: (file, duration) async {
          Navigator.pop(ctx);
          final cloud = ref.read(cloudinaryServiceProvider);
          final res = await cloud.uploadAudio(file);
          final send = ref.read(sendMessageUsecaseProvider);
          await send(
            conversationId: chatId,
            content: 'Voice',
            type: 'AUDIO',
            mediaUrl: res.url,
            duration: duration.inSeconds,
          );
          ref.read(messagesProvider(chatId).notifier).refresh();
        },
        onCancel: () => Navigator.pop(ctx),
      ),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final primaryColor = const Color(0xFF0084FF);
    final iconColor = primaryColor;
    final inputFillColor = isDark ? const Color(0xFF303030) : const Color(0xFFF0F2F5);
    final hintColor = isDark ? Colors.grey[400] : Colors.grey[600];
    const double minBoxHeight = 44.0;
    final typingDebouncer = useRef<TypingDebouncer?>(null);
    useEffect(() {
      typingDebouncer.value = TypingDebouncer();
      return () => typingDebouncer.value?.dispose();
    }, []);

    final typingUsers = ref.watch(conversationTypingUsersProvider(chatId));

    void handleTextChange(String text) {
      typingDebouncer.value?.onTextChanged(
        text,
        () => ref.read(typingProvider.notifier).sendTypingStart(chatId),
        () => ref.read(typingProvider.notifier).sendTypingStop(chatId),
      );
    }

    void handleSend() {
      typingDebouncer.value?.stop(() => ref.read(typingProvider.notifier).sendTypingStop(chatId));
      onSend();
    }

    Widget buildCompactIconButton(IconData icon, VoidCallback onPressed) {
      return Container(
        width: 32,
        alignment: Alignment.center,
        child: IconButton(
          icon: Icon(icon, color: iconColor, size: 26),
          onPressed: onPressed,
          padding: EdgeInsets.zero,
          constraints: const BoxConstraints(),
          splashRadius: 20,
        ),
      );
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        if (typingUsers.isNotEmpty) TypingIndicatorWidget(typingUsers: typingUsers),

        Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 6),
          decoration: BoxDecoration(
            color: Theme.of(context).scaffoldBackgroundColor,
            border: Border(
              top: BorderSide(color: isDark ? Colors.grey.withOpacity(0.2) : Colors.grey.withOpacity(0.1), width: 0.5),
            ),
          ),
          child: SafeArea(
            top: false,
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                SizedBox(
                  height: minBoxHeight,
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      buildCompactIconButton(Icons.add_circle, () async {
                        final type = await AttachmentPickerBottomSheet.show(context);
                        if (type != null && context.mounted) {
                        }
                      }),
                      const SizedBox(width: 4),
                      buildCompactIconButton(Icons.image, () async {
                        final mediaService = ref.read(mediaPickerServiceProvider);
                        final images = await mediaService.pickMultipleImagesFromGallery();
                        if (images.isNotEmpty) {
                        }
                      }),
                      const SizedBox(width: 4),
                      buildCompactIconButton(Icons.mic, () => _showVoiceRecorder(context, ref)),
                    ],
                  ),
                ),

                const SizedBox(width: 6),
                Expanded(
                  child: Container(
                    constraints: const BoxConstraints(minHeight: minBoxHeight, maxHeight: 120),
                    decoration: BoxDecoration(color: inputFillColor, borderRadius: BorderRadius.circular(24)),
                    child: TextField(
                      controller: controller,
                      maxLines: null,
                      textCapitalization: TextCapitalization.sentences,
                      onChanged: handleTextChange,
                      onSubmitted: (_) => handleSend(),
                      textInputAction: TextInputAction.send,
                      style: TextStyle(color: isDark ? Colors.white : Colors.black, fontSize: 16, height: 1.3),
                      decoration: InputDecoration(
                        hintText: 'Nh·∫Øn tin...',
                        hintStyle: TextStyle(color: hintColor, fontSize: 16),
                        border: InputBorder.none,
                        isDense: true,
                        contentPadding: const EdgeInsets.fromLTRB(16, 12, 4, 12),
                        suffixIcon: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          mainAxisSize: MainAxisSize.min,
                          children: [Icon(Icons.sticky_note_2_outlined, color: hintColor, size: 24)],
                        ),
                        suffixIconConstraints: const BoxConstraints(minWidth: 40, minHeight: 40),
                      ),
                    ),
                  ),
                ),

                const SizedBox(width: 6),
                SizedBox(
                  height: minBoxHeight,
                  child: Center(
                    child: buildCompactIconButton(Icons.thumb_up_alt, () {
                      onSend(specificContent: 'üëç');
                    }),
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/pages/new_chat_page.dart
================================================================
import 'dart:async';

import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/core/widgets/user_avatar.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/chat/domain/entities/search_user.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class NewChatPage extends HookConsumerWidget {
  const NewChatPage({super.key});

  Color _avatarColor(BuildContext context, int seed) {
    final palette = <Color>[
      const Color(0xFFEF5350), // red
      const Color(0xFFAB47BC), // purple
      const Color(0xFF5C6BC0), // indigo
      const Color(0xFF29B6F6), // blue
      const Color(0xFF26A69A), // teal
      const Color(0xFF66BB6A), // green
      const Color(0xFFFFCA28), // amber
      const Color(0xFFFF7043), // deep orange
      const Color(0xFF8D6E63), // brown
      const Color(0xFF78909C), // blue grey
    ];

    final index = seed % palette.length;
    return palette[index];
  }

  Future<void> _handleUserTap(BuildContext context, WidgetRef ref, SearchUser user) async {

    if (user.hasConversation && user.conversationId != null) {
      final userName = user.fullName.isNotEmpty ? user.fullName : user.username;
      context.pop();
      context.push('/chat/${user.conversationId}', extra: {'name': userName, 'color': _avatarColor(context, user.id)});
      return;
    }

    final currentUser = ref.read(currentUserProvider);
    if (currentUser == null) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('User not logged in')));
      }
      return;
    }

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(child: CircularProgressIndicator()),
    );

    final createUsecase = ref.read(createConversationUsecaseProvider);
    final result = await createUsecase(type: 'DIRECT', participantIds: [currentUser.id.toString(), user.id.toString()]);

    if (context.mounted) {
      Navigator.of(context).pop();
    }

    result.fold(
      (failure) {

        if (context.mounted) {

          final errorMessage = failure.when(
            validation: (message, code, details, requestId) => 'Invalid conversation: $message',
            conflict: (message, code, requestId) => 'Conversation already exists',
            network: (message, code) => 'Network error: $message',
            auth: (message, code, requestId) => 'Authentication error: $message',
            server: (message, code, requestId) => 'Server error: $message',
            notFound: (message, code, requestId) => 'Not found: $message',
            rateLimit: (message, code, requestId) => 'Too many requests: $message',
          );

          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(errorMessage), backgroundColor: Colors.red, duration: const Duration(seconds: 3)),
          );
        }
      },
      (conversation) {

        ref.invalidate(conversationsProvider);

        if (context.mounted) {
          final userName = user.fullName.isNotEmpty ? user.fullName : user.username;

          context.pop();
          context.push('/chat/${conversation.id}', extra: {'name': userName, 'color': _avatarColor(context, user.id)});
        }
      },
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final textTheme = Theme.of(context).textTheme;
    final searchController = useTextEditingController();
    final searchQuery = useState('');
    final searchResults = useState<List<SearchUser>>([]);
    final isSearching = useState(false);
    final searchError = useState<String?>(null);

    useEffect(() {
      Timer? debounceTimer;

      void performSearch() async {
        final query = searchController.text.trim();

        if (query.isEmpty) {
          searchQuery.value = '';
          searchResults.value = [];
          isSearching.value = false;
          searchError.value = null;
          return;
        }

        searchQuery.value = query;
        isSearching.value = true;
        searchError.value = null;

        final searchUsecase = ref.read(searchUsersUsecaseProvider);
        final result = await searchUsecase(query: query, limit: 50);

        result.fold(
          (failure) {
            isSearching.value = false;
            searchError.value = failure.message;
          },
          (users) {
            isSearching.value = false;
            searchResults.value = users;
          },
        );
      }

      void onSearchChanged() {
        debounceTimer?.cancel();
        debounceTimer = Timer(const Duration(milliseconds: 500), performSearch);
      }

      searchController.addListener(onSearchChanged);

      return () {
        debounceTimer?.cancel();
        searchController.removeListener(onSearchChanged);
      };
    }, [searchController]);

    return Scaffold(
      appBar: AppBar(
        title: Text('New Chat', style: textTheme.titleLarge),
        leading: IconButton(icon: const Icon(Icons.arrow_back), onPressed: () => context.pop()),
      ),
      body: Column(
        children: [

          Padding(
            padding: const EdgeInsets.all(16.0),
            child: SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: () => context.push('/new-group'),
                icon: const Icon(Icons.group_add),
                label: const Text('New Group'),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                ),
              ),
            ),
          ),

          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Row(
              children: [
                Expanded(child: Divider(color: Colors.grey[300])),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: Text('OR', style: textTheme.bodySmall?.copyWith(color: Colors.grey[600])),
                ),
                Expanded(child: Divider(color: Colors.grey[300])),
              ],
            ),
          ),

          Padding(
            padding: const EdgeInsets.all(16.0),
            child: TextField(
              controller: searchController,
              decoration: InputDecoration(
                hintText: 'Search users...',
                prefixIcon: const Icon(Icons.search),
                suffixIcon: searchController.text.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear),
                        onPressed: () {
                          searchController.clear();
                        },
                      )
                    : null,
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                filled: true,
                fillColor: Theme.of(context).colorScheme.surfaceContainerHighest,
              ),
              autofocus: false,
            ),
          ),

          Expanded(
            child: _buildSearchResults(
              context,
              ref,
              textTheme,
              searchQuery.value,
              searchResults.value,
              isSearching.value,
              searchError.value,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSearchResults(
    BuildContext context,
    WidgetRef ref,
    TextTheme textTheme,
    String query,
    List<SearchUser> results,
    bool isSearching,
    String? error,
  ) {

    if (isSearching) {
      return const Center(child: CircularProgressIndicator());
    }

    if (error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 64, color: Colors.red[300]),
            const SizedBox(height: 16),
            Text('Search failed', style: textTheme.titleMedium?.copyWith(color: Colors.red[700])),
            const SizedBox(height: 8),
            Text(
              error,
              style: textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      );
    }

    if (query.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.search, size: 64, color: Colors.grey[400]),
            const SizedBox(height: 16),
            Text('Search for users', style: textTheme.titleMedium?.copyWith(color: Colors.grey[600])),
            const SizedBox(height: 8),
            Text('Enter a name, username, or email', style: textTheme.bodySmall?.copyWith(color: Colors.grey[500])),
          ],
        ),
      );
    }

    if (results.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.person_search, size: 64, color: Colors.grey[400]),
            const SizedBox(height: 16),
            Text('No users found', style: textTheme.titleMedium?.copyWith(color: Colors.grey[600])),
            const SizedBox(height: 8),
            Text('Try a different search term', style: textTheme.bodySmall?.copyWith(color: Colors.grey[500])),
          ],
        ),
      );
    }

    return ListView.separated(
      itemCount: results.length,
      separatorBuilder: (_, _) => const Divider(height: 1),
      itemBuilder: (context, index) {
        final user = results[index];
        return _buildUserTile(context, ref, textTheme, user);
      },
    );
  }

  Widget _buildUserTile(BuildContext context, WidgetRef ref, TextTheme textTheme, SearchUser user) {
    final userName = user.fullName.isNotEmpty ? user.fullName : user.username;
    final avatarColor = _avatarColor(context, user.id);

    return ListTile(
      onTap: () => _handleUserTap(context, ref, user),
      leading: UserAvatar(displayName: userName, avatarUrl: user.avatarUrl, radius: 20, backgroundColor: avatarColor),
      title: Row(
        children: [
          Expanded(child: Text(userName, style: textTheme.titleMedium)),
          if (user.isContact)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.primaryContainer,
                borderRadius: BorderRadius.circular(12),
              ),
              child: Text(
                'Contact',
                style: textTheme.labelSmall?.copyWith(color: Theme.of(context).colorScheme.onPrimaryContainer),
              ),
            ),
        ],
      ),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('@${user.username}', style: textTheme.bodySmall?.copyWith(color: Colors.grey[600])),
          if (user.hasConversation)
            Text(
              'Already chatting',
              style: textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.primary,
                fontStyle: FontStyle.italic,
              ),
            ),
        ],
      ),
      trailing: Container(
        width: 12,
        height: 12,
        decoration: BoxDecoration(
          color: user.isOnline ? Colors.green : Colors.grey,
          shape: BoxShape.circle,
          border: Border.all(color: Theme.of(context).scaffoldBackgroundColor, width: 2),
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/pages/new_group_chat_page.dart
================================================================
import 'dart:async';

import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/core/widgets/user_avatar.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/chat/domain/entities/search_user.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class NewGroupChatPage extends HookConsumerWidget {
  const NewGroupChatPage({super.key});

  Color _avatarColor(BuildContext context, int seed) {
    final palette = <Color>[
      const Color(0xFFEF5350), // red
      const Color(0xFFAB47BC), // purple
      const Color(0xFF5C6BC0), // indigo
      const Color(0xFF29B6F6), // blue
      const Color(0xFF26A69A), // teal
      const Color(0xFF66BB6A), // green
      const Color(0xFFFFCA28), // amber
      const Color(0xFFFF7043), // deep orange
      const Color(0xFF8D6E63), // brown
      const Color(0xFF78909C), // blue grey
    ];

    final index = seed % palette.length;
    return palette[index];
  }

  Future<void> _createGroup(
    BuildContext context,
    WidgetRef ref,
    String groupName,
    List<SearchUser> selectedUsers,
  ) async {

    if (groupName.trim().isEmpty) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text('Please enter a group name'), backgroundColor: Colors.orange));
      return;
    }

    if (selectedUsers.length < 2) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text('Please select at least 2 members'), backgroundColor: Colors.orange));
      return;
    }

    final currentUser = ref.read(currentUserProvider);
    if (currentUser == null) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('User not logged in')));
      }
      return;
    }

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(child: CircularProgressIndicator()),
    );

    final participantIds = [currentUser.id.toString(), ...selectedUsers.map((u) => u.id.toString())];

    final createUsecase = ref.read(createConversationUsecaseProvider);
    final result = await createUsecase(name: groupName.trim(), type: 'GROUP', participantIds: participantIds);

    if (context.mounted) {
      Navigator.of(context).pop();
    }

    result.fold(
      (failure) {

        if (context.mounted) {

          final errorMessage = failure.when(
            validation: (message, code, details, requestId) => 'Invalid group: $message',
            conflict: (message, code, requestId) => 'Group already exists',
            network: (message, code) => 'Network error: $message',
            auth: (message, code, requestId) => 'Authentication error: $message',
            server: (message, code, requestId) => 'Server error: $message',
            notFound: (message, code, requestId) => 'Not found: $message',
            rateLimit: (message, code, requestId) => 'Too many requests: $message',
          );

          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(errorMessage), backgroundColor: Colors.red, duration: const Duration(seconds: 3)),
          );
        }
      },
      (conversation) {

        ref.invalidate(conversationsProvider);

        if (context.mounted) {

          context.pop();
          context.push(
            '/chat/${conversation.id}',
            extra: {'name': groupName.trim(), 'color': _avatarColor(context, conversation.id)},
          );
        }
      },
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final textTheme = Theme.of(context).textTheme;
    final searchController = useTextEditingController();
    final groupNameController = useTextEditingController();
    final searchQuery = useState('');
    final searchResults = useState<List<SearchUser>>([]);
    final selectedUsers = useState<List<SearchUser>>([]);
    final isSearching = useState(false);
    final searchError = useState<String?>(null);

    useEffect(() {
      Timer? debounceTimer;

      void performSearch() async {
        final query = searchController.text.trim();

        if (query.isEmpty) {
          searchQuery.value = '';
          searchResults.value = [];
          isSearching.value = false;
          searchError.value = null;
          return;
        }

        searchQuery.value = query;
        isSearching.value = true;
        searchError.value = null;

        final searchUsecase = ref.read(searchUsersUsecaseProvider);
        final result = await searchUsecase(query: query, limit: 50);

        result.fold(
          (failure) {
            isSearching.value = false;
            searchError.value = failure.message;
          },
          (users) {
            isSearching.value = false;
            searchResults.value = users;
          },
        );
      }

      void onSearchChanged() {
        debounceTimer?.cancel();
        debounceTimer = Timer(const Duration(milliseconds: 500), performSearch);
      }

      searchController.addListener(onSearchChanged);

      return () {
        debounceTimer?.cancel();
        searchController.removeListener(onSearchChanged);
      };
    }, [searchController]);

    return Scaffold(
      appBar: AppBar(
        title: Text('New Group', style: textTheme.titleLarge),
        leading: IconButton(icon: const Icon(Icons.arrow_back), onPressed: () => context.pop()),
        actions: [
          TextButton(
            onPressed: () => _createGroup(context, ref, groupNameController.text, selectedUsers.value),
            child: Text(
              'Create',
              style: textTheme.titleMedium?.copyWith(
                color: Theme.of(context).colorScheme.primary,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [

          Padding(
            padding: const EdgeInsets.all(16.0),
            child: TextField(
              controller: groupNameController,
              decoration: InputDecoration(
                hintText: 'Group name',
                prefixIcon: const Icon(Icons.group),
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                filled: true,
                fillColor: Theme.of(context).colorScheme.surfaceContainerHighest,
              ),
            ),
          ),

          if (selectedUsers.value.isNotEmpty)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              height: 60,
              child: ListView.builder(
                scrollDirection: Axis.horizontal,
                itemCount: selectedUsers.value.length,
                itemBuilder: (context, index) {
                  final user = selectedUsers.value[index];
                  final userName = user.fullName.isNotEmpty ? user.fullName : user.username;
                  return Padding(
                    padding: const EdgeInsets.only(right: 8.0),
                    child: Chip(
                      avatar: CircleAvatar(
                        backgroundColor: _avatarColor(context, user.id),
                        child: Text(
                          userName.substring(0, 1),
                          style: textTheme.labelSmall?.copyWith(color: Colors.white),
                        ),
                      ),
                      label: Text(userName),
                      onDeleted: () {
                        selectedUsers.value = List.from(selectedUsers.value)..removeAt(index);
                      },
                    ),
                  );
                },
              ),
            ),

          Padding(
            padding: const EdgeInsets.all(16.0),
            child: TextField(
              controller: searchController,
              decoration: InputDecoration(
                hintText: 'Search users to add...',
                prefixIcon: const Icon(Icons.search),
                suffixIcon: searchController.text.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear),
                        onPressed: () {
                          searchController.clear();
                        },
                      )
                    : null,
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                filled: true,
                fillColor: Theme.of(context).colorScheme.surfaceContainerHighest,
              ),
            ),
          ),

          Expanded(
            child: _buildSearchResults(
              context,
              ref,
              textTheme,
              searchQuery.value,
              searchResults.value,
              selectedUsers.value,
              isSearching.value,
              searchError.value,
              (user) {
                if (selectedUsers.value.contains(user)) {
                  selectedUsers.value = List.from(selectedUsers.value)..remove(user);
                } else {
                  selectedUsers.value = [...selectedUsers.value, user];
                }
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSearchResults(
    BuildContext context,
    WidgetRef ref,
    TextTheme textTheme,
    String query,
    List<SearchUser> results,
    List<SearchUser> selectedUsers,
    bool isSearching,
    String? error,
    void Function(SearchUser) onUserToggle,
  ) {

    if (isSearching) {
      return const Center(child: CircularProgressIndicator());
    }

    if (error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 64, color: Colors.red[300]),
            const SizedBox(height: 16),
            Text('Search failed', style: textTheme.titleMedium?.copyWith(color: Colors.red[700])),
            const SizedBox(height: 8),
            Text(
              error,
              style: textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      );
    }

    if (query.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.group_add, size: 64, color: Colors.grey[400]),
            const SizedBox(height: 16),
            Text('Add members to your group', style: textTheme.titleMedium?.copyWith(color: Colors.grey[600])),
            const SizedBox(height: 8),
            Text('Search for users to add', style: textTheme.bodySmall?.copyWith(color: Colors.grey[500])),
          ],
        ),
      );
    }

    if (results.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.person_search, size: 64, color: Colors.grey[400]),
            const SizedBox(height: 16),
            Text('No users found', style: textTheme.titleMedium?.copyWith(color: Colors.grey[600])),
            const SizedBox(height: 8),
            Text('Try a different search term', style: textTheme.bodySmall?.copyWith(color: Colors.grey[500])),
          ],
        ),
      );
    }

    return ListView.separated(
      itemCount: results.length,
      separatorBuilder: (_, _) => const Divider(height: 1),
      itemBuilder: (context, index) {
        final user = results[index];
        final isSelected = selectedUsers.contains(user);
        return _buildUserTile(context, ref, textTheme, user, isSelected, onUserToggle);
      },
    );
  }

  Widget _buildUserTile(
    BuildContext context,
    WidgetRef ref,
    TextTheme textTheme,
    SearchUser user,
    bool isSelected,
    void Function(SearchUser) onUserToggle,
  ) {
    final userName = user.fullName.isNotEmpty ? user.fullName : user.username;
    final avatarColor = _avatarColor(context, user.id);

    return ListTile(
      onTap: () => onUserToggle(user),
      leading: UserAvatar(displayName: userName, avatarUrl: user.avatarUrl, radius: 20, backgroundColor: avatarColor),
      title: Row(
        children: [
          Expanded(child: Text(userName, style: textTheme.titleMedium)),
          if (user.isContact)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.primaryContainer,
                borderRadius: BorderRadius.circular(12),
              ),
              child: Text(
                'Contact',
                style: textTheme.labelSmall?.copyWith(color: Theme.of(context).colorScheme.onPrimaryContainer),
              ),
            ),
        ],
      ),
      subtitle: Text('@${user.username}', style: textTheme.bodySmall?.copyWith(color: Colors.grey[600])),
      trailing: Checkbox(value: isSelected, onChanged: (_) => onUserToggle(user)),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/pages/search_conversations_page.dart
================================================================
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/search_conversations_provider.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/conversation_list_item.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
class SearchConversationsPage extends HookConsumerWidget {
  const SearchConversationsPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final searchController = useTextEditingController();
    final searchFocusNode = useFocusNode();
    final asyncState = ref.watch(searchConversationsProvider);
    final currentUser = ref.watch(currentUserProvider);
    final colors = Theme.of(context).colorScheme;
    useEffect(() {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        searchFocusNode.requestFocus();
      });
      return null;
    }, []);
    useEffect(() {
      void onSearchChanged() {
        final query = searchController.text.trim();
        if (query.isEmpty) {
          ref.read(searchConversationsProvider.notifier).clear();
        } else {
          ref.read(searchConversationsProvider.notifier).search(query);
        }
      }

      searchController.addListener(onSearchChanged);
      return () => searchController.removeListener(onSearchChanged);
    }, [searchController]);

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        leading: IconButton(icon: const Icon(Icons.arrow_back), onPressed: () => context.pop()),
        title: TextField(
          controller: searchController,
          focusNode: searchFocusNode,
          decoration: InputDecoration(
            hintText: 'T√¨m ki·∫øm tin nh·∫Øn...',
            border: InputBorder.none,
            hintStyle: TextStyle(color: colors.onSurface.withOpacity(0.5)),
          ),
          style: const TextStyle(fontSize: 16),
        ),
        actions: [
          if (searchController.text.isNotEmpty)
            IconButton(
              icon: const Icon(Icons.clear),
              onPressed: () {
                searchController.clear();
                ref.read(searchConversationsProvider.notifier).clear();
              },
            ),
        ],
      ),
      body: _buildBody(context, ref, asyncState, currentUser),
    );
  }

  Widget _buildBody(BuildContext context, WidgetRef ref, AsyncValue<List<dynamic>> asyncState, dynamic currentUser) {
    return switch (asyncState) {
      AsyncData(:final value) => _buildResults(context, ref, value, currentUser),
      AsyncError(:final error) => _buildError(context, error),
      _ => const Center(child: CircularProgressIndicator()),
    };
  }

  Widget _buildResults(BuildContext context, WidgetRef ref, List<dynamic> conversations, dynamic currentUser) {
    if (conversations.isEmpty) {
      return _buildEmptyState(context, 'Kh√¥ng t√¨m th·∫•y tin nh·∫Øn n√†o');
    }

    return ListView.builder(
      itemCount: conversations.length,
      itemBuilder: (context, index) {
        final conversation = conversations[index];
        return ConversationListItem(
          conversation: conversation,
          currentUser: currentUser,
          onTap: () {
            context.push('/chat/${conversation.id}', extra: {'name': conversation.name});
          },
        );
      },
    );
  }

  Widget _buildError(BuildContext context, Object error) {
    final colors = Theme.of(context).colorScheme;

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.error_outline, size: 64, color: Colors.red),
          const SizedBox(height: 16),
          Text(
            'ƒê√£ x·∫£y ra l·ªói',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.w600, color: colors.onSurface),
          ),
          const SizedBox(height: 8),
          Text(
            error.toString(),
            style: TextStyle(fontSize: 14, color: colors.onSurface.withOpacity(0.7)),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState(BuildContext context, String message) {
    final colors = Theme.of(context).colorScheme;

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.search, size: 64, color: colors.onSurface.withOpacity(0.3)),
          const SizedBox(height: 16),
          Text(
            message,
            style: TextStyle(fontSize: 16, color: colors.onSurface.withOpacity(0.7)),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/providers/chat_datasource_provider.dart
================================================================
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/chat/data/datasources/chat_remote_datasource_impl.dart';
import 'package:chattrix_ui/features/chat/domain/datasources/chat_remote_datasource.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

final chatRemoteDatasourceProvider = Provider<ChatRemoteDatasource>((ref) {
  final dio = ref.watch(dioProvider);
  return ChatRemoteDatasourceImpl(dio: dio);
});

================================================================
FILE: lib/features/chat/presentation/providers/chat_providers.dart
================================================================
export '../state/conversations_notifier.dart';
export '../state/messages_notifier.dart';
export 'chat_datasource_provider.dart';
export 'chat_repository_provider.dart';
export 'chat_state_provider.dart';
export 'chat_usecase_provider.dart';
export 'chat_websocket_provider_new.dart';

================================================================
FILE: lib/features/chat/presentation/providers/chat_repository_provider.dart
================================================================
import 'package:chattrix_ui/features/chat/data/repositories/chat_repository_impl.dart';
import 'package:chattrix_ui/features/chat/data/repositories/user_status_repository_impl.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/chat_repository.dart';
import 'package:chattrix_ui/features/chat/domain/repositories/user_status_repository.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_datasource_provider.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

final chatRepositoryProvider = Provider<ChatRepository>((ref) {
  final remoteDatasource = ref.watch(chatRemoteDatasourceProvider);
  return ChatRepositoryImpl(remoteDatasource: remoteDatasource);
});

final userStatusRepositoryProvider = Provider<UserStatusRepository>((ref) {
  final remoteDatasource = ref.watch(chatRemoteDatasourceProvider);
  return UserStatusRepositoryImpl(remoteDatasource: remoteDatasource);
});

================================================================
FILE: lib/features/chat/presentation/providers/chat_state_provider.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/search_user.dart';
import 'package:chattrix_ui/features/chat/domain/entities/user_status.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_usecase_provider.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

final onlineUsersProvider = FutureProvider((ref) async {
  final usecase = ref.watch(getOnlineUsersUsecaseProvider);
  final result = await usecase();

  return result.fold((failure) => throw Exception(failure.message), (users) => users);
});

final userStatusProvider = FutureProvider.family<UserStatus, String>((ref, userId) async {
  final usecase = ref.watch(getUserStatusUsecaseProvider);
  final result = await usecase(userId);

  return result.fold((failure) => throw Exception(failure.message), (status) => status);
});

final searchUsersProvider = FutureProvider.family<List<SearchUser>, String>((ref, query) async {
  if (query.isEmpty) {
    return [];
  }

  final usecase = ref.watch(searchUsersUsecaseProvider);
  final result = await usecase(query: query);

  return result.fold((failure) => throw Exception(failure.message), (users) => users);
});

================================================================
FILE: lib/features/chat/presentation/providers/chat_usecase_provider.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/usecases/create_conversation_usecase.dart';
import 'package:chattrix_ui/features/chat/domain/usecases/delete_message_usecase.dart';
import 'package:chattrix_ui/features/chat/domain/usecases/edit_message_usecase.dart';
import 'package:chattrix_ui/features/chat/domain/usecases/get_conversation_usecase.dart';
import 'package:chattrix_ui/features/chat/domain/usecases/get_conversations_usecase.dart';
import 'package:chattrix_ui/features/chat/domain/usecases/get_messages_usecase.dart';
import 'package:chattrix_ui/features/chat/domain/usecases/get_online_users_usecase.dart';
import 'package:chattrix_ui/features/chat/domain/usecases/get_user_status_usecase.dart';
import 'package:chattrix_ui/features/chat/domain/usecases/search_users_usecase.dart';
import 'package:chattrix_ui/features/chat/domain/usecases/send_message_usecase.dart';
import 'package:chattrix_ui/features/chat/domain/usecases/toggle_reaction_usecase.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_repository_provider.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

final createConversationUsecaseProvider = Provider<CreateConversationUsecase>((ref) {
  final repository = ref.watch(chatRepositoryProvider);
  return CreateConversationUsecase(repository);
});

final getConversationsUsecaseProvider = Provider<GetConversationsUsecase>((ref) {
  final repository = ref.watch(chatRepositoryProvider);
  return GetConversationsUsecase(repository);
});

final getConversationUsecaseProvider = Provider<GetConversationUsecase>((ref) {
  final repository = ref.watch(chatRepositoryProvider);
  return GetConversationUsecase(repository);
});

final getMessagesUsecaseProvider = Provider<GetMessagesUsecase>((ref) {
  final repository = ref.watch(chatRepositoryProvider);
  return GetMessagesUsecase(repository);
});

final sendMessageUsecaseProvider = Provider<SendMessageUsecase>((ref) {
  final repository = ref.watch(chatRepositoryProvider);
  return SendMessageUsecase(repository);
});

final editMessageUsecaseProvider = Provider<EditMessageUsecase>((ref) {
  final repository = ref.watch(chatRepositoryProvider);
  return EditMessageUsecase(repository: repository);
});

final deleteMessageUsecaseProvider = Provider<DeleteMessageUsecase>((ref) {
  final repository = ref.watch(chatRepositoryProvider);
  return DeleteMessageUsecase(repository: repository);
});

final getOnlineUsersUsecaseProvider = Provider<GetOnlineUsersUsecase>((ref) {
  final repository = ref.watch(userStatusRepositoryProvider);
  return GetOnlineUsersUsecase(repository);
});

final getUserStatusUsecaseProvider = Provider<GetUserStatusUsecase>((ref) {
  final repository = ref.watch(userStatusRepositoryProvider);
  return GetUserStatusUsecase(repository);
});

final searchUsersUsecaseProvider = Provider<SearchUsersUsecase>((ref) {
  final repository = ref.watch(chatRepositoryProvider);
  return SearchUsersUsecase(repository);
});

final toggleReactionUsecaseProvider = Provider<ToggleReactionUsecase>((ref) {
  final repository = ref.watch(chatRepositoryProvider);
  return ToggleReactionUsecase(repository);
});

================================================================
FILE: lib/features/chat/presentation/providers/chat_websocket_provider_new.dart
================================================================
import 'dart:async';
import 'package:chattrix_ui/core/constants/api_constants.dart';
import 'package:chattrix_ui/core/network/websocket_providers.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/chat/data/datasources/chat_websocket_datasource_impl.dart';
import 'package:chattrix_ui/features/chat/domain/datasources/chat_websocket_datasource.dart';
import 'package:flutter/foundation.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

final chatWebSocketDataSourceProvider = Provider<ChatWebSocketDataSource>((ref) {
  final webSocketService = ref.watch(webSocketServiceProvider);

  final dataSource = ChatWebSocketDataSourceImpl(webSocketService: webSocketService);

  ref.onDispose(() {
    dataSource.dispose();
  });

  return dataSource;
});
class WebSocketConnectionState {
  final bool isConnected;
  final String? error;

  WebSocketConnectionState({this.isConnected = false, this.error});

  WebSocketConnectionState copyWith({bool? isConnected, String? error, bool clearError = false}) {
    return WebSocketConnectionState(
      isConnected: isConnected ?? this.isConnected,
      error: clearError ? null : (error ?? this.error),
    );
  }
}

class WebSocketConnectionNotifier extends Notifier<WebSocketConnectionState> {
  int _reconnectAttempts = 0;
  static const int _maxReconnectAttempts = 5;
  Timer? _reconnectTimer;

  @override
  WebSocketConnectionState build() {
    _initializeConnection();

    ref.onDispose(() {
      _reconnectTimer?.cancel();
    });

    return WebSocketConnectionState();
  }

  Future<void> _initializeConnection() async {
    try {
      final tokenCache = ref.read(tokenCacheServiceProvider);
      final accessToken = await tokenCache.getAccessToken();

      if (accessToken == null || accessToken.isEmpty) {
        state = state.copyWith(error: 'Not authenticated', clearError: false);
        return;
      }

      final webSocketService = ref.read(webSocketServiceProvider);
      webSocketService.connectionStream.listen((isConnected) async {
        state = state.copyWith(isConnected: isConnected, clearError: true);

        if (!isConnected) {
          _scheduleReconnect();
        } else {
          _reconnectAttempts = 0;
          _reconnectTimer?.cancel();
        }
      });

      final wsUrl = ApiConstants.chatWebSocketWithToken(accessToken);
      await webSocketService.connect(wsUrl);

      state = state.copyWith(isConnected: true, clearError: true);
      _reconnectAttempts = 0;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      _scheduleReconnect();
    }
  }
  void _scheduleReconnect() {
    _reconnectTimer?.cancel();

    if (_reconnectAttempts >= _maxReconnectAttempts) {
      state = state.copyWith(error: 'Max reconnection attempts reached. Using polling fallback.', clearError: false);
      return;
    }

    _reconnectAttempts++;
    final delay = Duration(seconds: 1 << _reconnectAttempts);

    debugPrint(
      'üîÑ Scheduling WebSocket reconnect attempt $_reconnectAttempts/$_maxReconnectAttempts in ${delay.inSeconds}s',
    );

    _reconnectTimer = Timer(delay, () {
      if (!state.isConnected) {
        debugPrint('üîÑ Attempting WebSocket reconnection...');
        _initializeConnection();
      }
    });
  }

  Future<void> reconnect() async {
    _reconnectAttempts = 0;
    _reconnectTimer?.cancel();
    await _initializeConnection();
  }

  Future<void> disconnect() async {
    _reconnectTimer?.cancel();
    _reconnectAttempts = 0;
    final webSocketService = ref.read(webSocketServiceProvider);
    await webSocketService.disconnect();
    state = state.copyWith(isConnected: false, clearError: true);
  }
}

final webSocketConnectionProvider = NotifierProvider<WebSocketConnectionNotifier, WebSocketConnectionState>(() {
  return WebSocketConnectionNotifier();
});

================================================================
FILE: lib/features/chat/presentation/providers/search_conversations_provider.dart
================================================================
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/chat/data/datasources/chat_remote_datasource_impl.dart';
import 'package:chattrix_ui/features/chat/data/repositories/chat_repository_impl.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/domain/usecases/search_conversations_usecase.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'search_conversations_provider.g.dart';
@riverpod
SearchConversationsUseCase searchConversationsUseCase(Ref ref) {
  final dio = ref.watch(dioProvider);
  final datasource = ChatRemoteDatasourceImpl(dio: dio);
  final repository = ChatRepositoryImpl(remoteDatasource: datasource);
  return SearchConversationsUseCase(repository);
}
@riverpod
class SearchConversations extends _$SearchConversations {
  late final SearchConversationsUseCase _useCase;

  @override
  Future<List<Conversation>> build() async {
    _useCase = ref.read(searchConversationsUseCaseProvider);
    return [];
  }
  Future<void> search(String query) async {
    state = const AsyncValue.loading();
    final result = await _useCase(query: query);
    state = result.fold(
      (failure) => AsyncValue.error(Exception(failure.message), StackTrace.current),
      (conversations) => AsyncValue.data(conversations),
    );
  }
  void clear() {
    state = const AsyncValue.data([]);
  }
}

================================================================
FILE: lib/features/chat/presentation/providers/typing_providers.dart
================================================================
import 'dart:async';

import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/chat/domain/entities/typing_indicator.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_providers.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'typing_providers.g.dart';
@riverpod
class TypingNotifier extends _$TypingNotifier {
  StreamSubscription<TypingIndicator>? _subscription;

  @override
  Map<String, List<TypingUser>> build() {
    _listenToTypingStream();
    ref.onDispose(() {
      _subscription?.cancel();
    });

    return {};
  }
  void _listenToTypingStream() {
    try {
      final dataSource = ref.read(chatWebSocketDataSourceProvider);
      _subscription = dataSource.typingStream.listen(
        (indicator) {
          print(
            '‚å®Ô∏è [TypingNotifier] Received typing indicator: conversationId=${indicator.conversationId}, users=${indicator.typingUsers.length}',
          );
          if (indicator.typingUsers.isNotEmpty) {
            print(
              '‚å®Ô∏è [TypingNotifier] Users: ${indicator.typingUsers.map((u) => '${u.fullName}(${u.id})').join(', ')}',
            );
          }
          state = {...state, indicator.conversationId: indicator.typingUsers};

          print('‚å®Ô∏è [TypingNotifier] Updated state: ${state.keys.map((k) => '$k:${state[k]!.length}').join(', ')}');
          if (indicator.typingUsers.isEmpty) {
            Future.delayed(const Duration(milliseconds: 500), () {
              if (state[indicator.conversationId]?.isEmpty ?? false) {
                final newState = Map<String, List<TypingUser>>.from(state);
                newState.remove(indicator.conversationId);
                state = newState;
                print('‚å®Ô∏è [TypingNotifier] Cleaned up empty state for conversation: ${indicator.conversationId}');
              }
            });
          }
        },
        onError: (error) {
          print('‚ùå [TypingNotifier] Error listening to typing stream: $error');
        },
      );
      print('‚úÖ [TypingNotifier] Started listening to typing stream');
    } catch (e) {
      print('‚ùå [TypingNotifier] Failed to listen to typing stream: $e');
    }
  }
  void sendTypingStart(String conversationId) {
    try {
      final dataSource = ref.read(chatWebSocketDataSourceProvider);
      dataSource.sendTypingStart(conversationId);
      print('‚å®Ô∏è [TypingNotifier] Sent typing start for conversation: $conversationId');
    } catch (e) {
      print('‚ùå [TypingNotifier] Failed to send typing start: $e');
    }
  }
  void sendTypingStop(String conversationId) {
    try {
      final dataSource = ref.read(chatWebSocketDataSourceProvider);
      dataSource.sendTypingStop(conversationId);
      print('‚å®Ô∏è [TypingNotifier] Sent typing stop for conversation: $conversationId');
    } catch (e) {
      print('‚ùå [TypingNotifier] Failed to send typing stop: $e');
    }
  }
  List<TypingUser> getTypingUsers(String conversationId, {String? excludeUserId}) {
    final users = state[conversationId] ?? [];
    if (excludeUserId != null) {
      return users.where((user) => user.id != excludeUserId).toList();
    }
    return users;
  }
}
@riverpod
List<TypingUser> conversationTypingUsers(Ref ref, String conversationId) {
  final currentUser = ref.watch(currentUserProvider);
  final typingUsers = ref.watch(typingProvider);

  final users = typingUsers[conversationId] ?? [];

  print(
    '‚å®Ô∏è [conversationTypingUsersProvider] conversationId=$conversationId, totalUsers=${users.length}, currentUserId=${currentUser?.id}',
  );
  if (currentUser != null) {
    final filtered = users.where((user) => user.id != currentUser.id.toString()).toList();
    print('‚å®Ô∏è [conversationTypingUsersProvider] After filtering: ${filtered.length} users');
    if (filtered.isNotEmpty) {
      print(
        '‚å®Ô∏è [conversationTypingUsersProvider] Filtered users: ${filtered.map((u) => '${u.fullName}(${u.id})').join(', ')}',
      );
    }
    return filtered;
  }

  return users;
}

================================================================
FILE: lib/features/chat/presentation/providers/user_notes_provider.dart
================================================================
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/user_note_entity.dart';

part 'user_notes_provider.g.dart';
@riverpod
class UserNotes extends _$UserNotes {
  @override
  Map<String, UserNoteEntity> build() {
    return _initializeMockData();
  }
  Map<String, UserNoteEntity> _initializeMockData() {
    return {
      '2': UserNoteEntity(userId: '2', content: 'Coding üíª', createdAt: DateTime.now()),
      '3': UserNoteEntity(userId: '3', content: 'At the gym üí™', createdAt: DateTime.now()),
      '4': UserNoteEntity(userId: '4', content: 'Lunch break üçú', createdAt: DateTime.now()),
    };
  }
  void createOrUpdateNote(String userId, String content) {
    state = {...state, userId: UserNoteEntity(userId: userId, content: content, createdAt: DateTime.now())};
  }
  void deleteNote(String userId) {
    final newState = Map<String, UserNoteEntity>.from(state);
    newState.remove(userId);
    state = newState;
  }
  UserNoteEntity? getNoteForUser(String userId) {
    return state[userId];
  }
}

================================================================
FILE: lib/features/chat/presentation/state/conversations_notifier.dart
================================================================
import 'dart:async';

import 'package:chattrix_ui/core/domain/enums/conversation_filter.dart';
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/core/utils/app_logger.dart';
import 'package:chattrix_ui/core/utils/retry_helper.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation_update.dart';
import 'package:chattrix_ui/features/chat/domain/entities/user_status_update.dart';
import 'package:chattrix_ui/features/chat/domain/entities/typing_indicator.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_usecase_provider.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_websocket_provider_new.dart';
import 'package:chattrix_ui/features/chat/presentation/state/filter_notifier.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'conversations_notifier.g.dart';

@riverpod
class ConversationsNotifier extends _$ConversationsNotifier {
  late final _getConversationsUsecase = ref.read(getConversationsUsecaseProvider);
  Timer? _pollingTimer;
  StreamSubscription<bool>? _connectionSubscription;
  StreamSubscription<Message>? _messageSubscription;
  StreamSubscription<ConversationUpdate>? _conversationUpdateSubscription;
  StreamSubscription<UserStatusUpdate>? _userStatusSubscription;
  StreamSubscription<TypingIndicator>? _typingSubscription;

  final Map<int, List<TypingUser>> _typingStates = {};

  @override
  FutureOr<List<Conversation>> build() async {
    AppLogger.debug('üèóÔ∏è Building ConversationsNotifier...', tag: 'ConversationsNotifier');

    final isLoggedIn = await ref.read(isLoggedInUseCaseProvider)();
    if (!isLoggedIn) {
      AppLogger.warning('‚ö†Ô∏è User not logged in, returning empty conversations list', tag: 'ConversationsNotifier');
      return [];
    }
    ref.keepAlive();

    final wsDataSource = ref.watch(chatWebSocketDataSourceProvider);

    _messageSubscription = wsDataSource.messageStream.listen((message) {
      AppLogger.debug(
        'üì® Message received via WebSocket for conversation ${message.conversationId}',
        tag: 'ConversationsNotifier',
      );
      _handleMessageEvent(message);
    });

    _conversationUpdateSubscription = wsDataSource.conversationUpdateStream.listen((update) {
      AppLogger.debug(
        'üì® Conversation update received via WebSocket for conversation ${update.conversationId}',
        tag: 'ConversationsNotifier',
      );
      _handleConversationUpdateEvent(update);
    });

    _userStatusSubscription = wsDataSource.userStatusStream.listen((statusUpdate) {
      AppLogger.debug(
        'üì® User status update received via WebSocket for user ${statusUpdate.userId}',
        tag: 'ConversationsNotifier',
      );
      _handleUserStatusEvent(statusUpdate);
    });

    _typingSubscription = wsDataSource.typingStream.listen((typingIndicator) {
      AppLogger.debug(
        'üì® Typing indicator received via WebSocket for conversation ${typingIndicator.conversationId}',
        tag: 'ConversationsNotifier',
      );
      _handleTypingIndicatorEvent(typingIndicator);
    });

    _connectionSubscription = wsDataSource.connectionStream.listen((isConnected) {
      AppLogger.info(
        'WebSocket connection state changed: ${isConnected ? "Connected" : "Disconnected"}',
        tag: 'ConversationsNotifier',
      );
      if (isConnected) {

        _stopPolling();
      } else {

        _startPolling();
      }
    });

    final isConnected = wsDataSource.isConnected;
    AppLogger.debug(
      'üîå Initial WebSocket connection state: ${isConnected ? "Connected" : "Disconnected"}',
      tag: 'ConversationsNotifier',
    );

    if (!isConnected) {
      _startPolling();
    }

    ref.onDispose(() {
      AppLogger.debug('üßπ Disposing ConversationsNotifier...', tag: 'ConversationsNotifier');
      _messageSubscription?.cancel();
      _conversationUpdateSubscription?.cancel();
      _userStatusSubscription?.cancel();
      _typingSubscription?.cancel();
      _connectionSubscription?.cancel();
      _stopPolling();
      _typingStates.clear();
    });

    return _fetchConversations();
  }

  void _startPolling() {
    _stopPolling();
    AppLogger.info('üîÑ Starting conversation polling (every 10s)', tag: 'ConversationsNotifier');
    _pollingTimer = Timer.periodic(const Duration(seconds: 10), (timer) {
      AppLogger.debug('‚è∞ Polling timer triggered - refreshing conversations', tag: 'ConversationsNotifier');
      refresh();
    });
  }

  void _stopPolling() {
    if (_pollingTimer != null) {
      AppLogger.info('‚è∏Ô∏è Stopping conversation polling', tag: 'ConversationsNotifier');
      _pollingTimer?.cancel();
      _pollingTimer = null;
    }
  }

  Future<List<Conversation>> _fetchConversations() async {
    AppLogger.debug('üîÑ Starting to fetch conversations...', tag: 'ConversationsNotifier');

    final isLoggedIn = await ref.read(isLoggedInUseCaseProvider)();
    if (!isLoggedIn) {
      AppLogger.warning('‚ö†Ô∏è User not logged in, skipping fetch', tag: 'ConversationsNotifier');
      return [];
    }

    final currentFilter = ref.read(filterProvider);
    AppLogger.debug('üîç Using filter: $currentFilter', tag: 'ConversationsNotifier');

    return await RetryHelper.retry(
      operation: () async {
        final result = await _getConversationsUsecase(filter: currentFilter);

        return result.fold(
          (failure) {
            AppLogger.error('‚ùå Failed to fetch conversations: ${failure.message}', tag: 'ConversationsNotifier');

            failure.when(
              server: (message, code, requestId) {
                AppLogger.error('Server error: $code - $message', tag: 'ConversationsNotifier');
              },
              network: (message, code) {
                AppLogger.error('Network error: $code - $message', tag: 'ConversationsNotifier');
              },
              validation: (message, code, details, requestId) {
                AppLogger.error('Validation error: $code - $message', tag: 'ConversationsNotifier');
              },
              auth: (message, code, requestId) {
                AppLogger.error('Auth error: $code - $message', tag: 'ConversationsNotifier');

              },
              notFound: (message, code, requestId) {
                AppLogger.error('Not found error: $code - $message', tag: 'ConversationsNotifier');
              },
              conflict: (message, code, requestId) {
                AppLogger.error('Conflict error: $code - $message', tag: 'ConversationsNotifier');
              },
              rateLimit: (message, code, requestId) {
                AppLogger.error('Rate limit error: $code - $message', tag: 'ConversationsNotifier');
              },
            );

            throw failure;
          },
          (conversations) {
            AppLogger.info(
              '‚úÖ Successfully fetched ${conversations.length} conversations',
              tag: 'ConversationsNotifier',
            );
            return conversations;
          },
        );
      },
      maxAttempts: 3,
      shouldRetry: (error) {

        if (error is Failure) {
          return error.maybeWhen(network: (_, __) => true, orElse: () => false);
        }
        return RetryHelper.isNetworkError(error);
      },
    );
  }

  Future<void> refresh() async {
    AppLogger.debug('üîÑ Refreshing conversations...', tag: 'ConversationsNotifier');
    state = await AsyncValue.guard(_fetchConversations);
  }

  Future<void> applyFilter(ConversationFilter filter) async {
    AppLogger.info('üîç Applying filter: $filter', tag: 'ConversationsNotifier');

    ref.read(filterProvider.notifier).setFilter(filter);

    await refresh();
  }

  void _handleMessageEvent(Message message) {
    final currentState = state.value;
    if (currentState == null) return;

    final currentUser = ref.read(currentUserProvider);
    if (currentUser == null) return;

    final conversationIndex = currentState.indexWhere((c) => c.id == message.conversationId);
    if (conversationIndex == -1) {

      AppLogger.debug(
        'Conversation ${message.conversationId} not found, refreshing list',
        tag: 'ConversationsNotifier',
      );
      refresh();
      return;
    }

    final conversation = currentState[conversationIndex];

    _typingStates.remove(conversation.id);

    final updatedConversation = conversation.copyWith(
      lastMessage: message,
      updatedAt: message.createdAt,

      unreadCount: message.senderId == currentUser.id ? conversation.unreadCount : conversation.unreadCount + 1,
    );

    final updatedList = <Conversation>[updatedConversation, ...currentState.where((c) => c.id != conversation.id)];

    state = AsyncValue.data(updatedList);
    AppLogger.debug('Updated conversation ${conversation.id} with new message', tag: 'ConversationsNotifier');
  }

  void _handleConversationUpdateEvent(ConversationUpdate update) {
    final currentState = state.value;
    if (currentState == null) return;

    final conversationIndex = currentState.indexWhere((c) => c.id == update.conversationId);
    if (conversationIndex == -1) {

      AppLogger.debug('Conversation ${update.conversationId} not found, refreshing list', tag: 'ConversationsNotifier');
      refresh();
      return;
    }

    AppLogger.debug(
      'Refreshing conversations due to update for conversation ${update.conversationId}',
      tag: 'ConversationsNotifier',
    );
    refresh();
  }

  void _handleUserStatusEvent(UserStatusUpdate statusUpdate) {
    final currentState = state.value;
    if (currentState == null) return;

    final userId = int.tryParse(statusUpdate.userId);
    if (userId == null) {
      AppLogger.warning('Invalid userId in status update: ${statusUpdate.userId}', tag: 'ConversationsNotifier');
      return;
    }

    bool hasChanges = false;
    final updatedList = currentState.map((conversation) {

      final participantIndex = conversation.participants.indexWhere((p) => p.userId == userId);
      if (participantIndex == -1) return conversation;

      final updatedParticipants = List.of(conversation.participants);
      updatedParticipants[participantIndex] = updatedParticipants[participantIndex].copyWith(
        online: statusUpdate.isOnline,
        lastSeen: statusUpdate.lastSeen != null ? DateTime.tryParse(statusUpdate.lastSeen!) : null,
      );

      hasChanges = true;
      return conversation.copyWith(participants: updatedParticipants);
    }).toList();

    if (hasChanges) {
      state = AsyncValue.data(updatedList);
      AppLogger.debug(
        'Updated online status for user $userId to ${statusUpdate.isOnline}',
        tag: 'ConversationsNotifier',
      );
    }
  }

  void _handleTypingIndicatorEvent(TypingIndicator typingIndicator) {
    final currentState = state.value;
    if (currentState == null) return;

    final currentUser = ref.read(currentUserProvider);
    if (currentUser == null) return;

    final conversationId = int.tryParse(typingIndicator.conversationId);
    if (conversationId == null) {
      AppLogger.warning(
        'Invalid conversationId in typing indicator: ${typingIndicator.conversationId}',
        tag: 'ConversationsNotifier',
      );
      return;
    }

    final typingUsers = typingIndicator.typingUsers.where((user) => user.id != currentUser.id.toString()).toList();

    if (typingUsers.isEmpty) {
      _typingStates.remove(conversationId);
    } else {
      _typingStates[conversationId] = typingUsers;
    }

    final conversationIndex = currentState.indexWhere((c) => c.id == conversationId);
    if (conversationIndex == -1) return;

    final conversation = currentState[conversationIndex];

    Message? displayMessage;
    if (typingUsers.isNotEmpty) {
      String typingText;
      if (typingUsers.length == 1) {
        typingText = 'ƒêang so·∫°n tin...';
      } else {
        typingText = '${typingUsers.length} ng∆∞·ªùi ƒëang so·∫°n tin...';
      }

      displayMessage = Message(
        id: -1, // Temporary ID
        conversationId: conversationId,
        senderId: typingUsers.first.id.hashCode, // Temporary sender ID
        senderUsername: typingUsers.first.username,
        content: typingText,
        type: 'TEXT',
        createdAt: DateTime.now(),
      );
    } else {

      displayMessage = conversation.lastMessage;
    }

    final updatedConversation = conversation.copyWith(lastMessage: displayMessage);

    final updatedList = currentState.map((c) => c.id == conversationId ? updatedConversation : c).toList();

    state = AsyncValue.data(updatedList);
    AppLogger.debug(
      'Updated typing indicator for conversation $conversationId: ${typingUsers.length} users typing',
      tag: 'ConversationsNotifier',
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/state/filter_notifier.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/conversation_filter.dart';
import 'package:chattrix_ui/core/utils/app_logger.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'filter_notifier.g.dart';
@Riverpod(keepAlive: true)
class FilterNotifier extends _$FilterNotifier {
  @override
  ConversationFilter build() {
    AppLogger.debug('üèóÔ∏è Building FilterNotifier with default filter: all', tag: 'FilterNotifier');
    return ConversationFilter.all;
  }
  void setFilter(ConversationFilter filter) {
    AppLogger.info('üîÑ Setting filter to: $filter', tag: 'FilterNotifier');
    state = filter;
  }
  ConversationFilter get currentFilter {
    return state;
  }
}

================================================================
FILE: lib/features/chat/presentation/state/messages_notifier.dart
================================================================
import 'dart:async';

import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_usecase_provider.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_websocket_provider_new.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'messages_notifier.g.dart';

@riverpod
class MessagesNotifier extends _$MessagesNotifier {
  late final _getMessagesUsecase = ref.read(getMessagesUsecaseProvider);
  Timer? _pollingTimer;
  StreamSubscription<bool>? _connectionSubscription;

  @override
  FutureOr<List<Message>> build(String conversationId) async {
    ref.keepAlive();

    final wsDataSource = ref.watch(chatWebSocketDataSourceProvider);
    final messageSubscription = wsDataSource.messageStream.listen((message) {
      if (message.conversationId.toString() == conversationId.toString()) {
        refresh();
      }
    });
    _connectionSubscription = wsDataSource.connectionStream.listen((isConnected) {
      if (isConnected) {
        _stopPolling();
      } else {
        _startPolling();
      }
    });
    if (!wsDataSource.isConnected) {
      _startPolling();
    }

    ref.onDispose(() {
      messageSubscription.cancel();
      _connectionSubscription?.cancel();
      _stopPolling();
    });

    return _fetchMessages(conversationId);
  }

  void _startPolling() {
    _stopPolling();
    _pollingTimer = Timer.periodic(const Duration(seconds: 5), (timer) {
      refresh();
    });
  }

  void _stopPolling() {
    _pollingTimer?.cancel();
    _pollingTimer = null;
  }

  Future<List<Message>> _fetchMessages(String conversationId) async {
    final result = await _getMessagesUsecase(conversationId: conversationId, sort: 'DESC');

    return result.fold((failure) => throw Exception(failure.message), (messages) => messages);
  }

  Future<void> refresh() async {
    state = await AsyncValue.guard(() => _fetchMessages(conversationId));
  }
}

================================================================
FILE: lib/features/chat/presentation/state/online_users_notifier.dart
================================================================
import 'dart:async';

import 'package:chattrix_ui/features/auth/domain/entities/user.dart';
import 'package:chattrix_ui/features/contacts/presentation/providers/contact_providers.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_websocket_provider_new.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'online_users_notifier.g.dart';
@riverpod
class OnlineUsersNotifier extends _$OnlineUsersNotifier {
  StreamSubscription<dynamic>? _userStatusSubscription;

  @override
  FutureOr<List<User>> build() async {
    ref.keepAlive();

    final wsDataSource = ref.watch(chatWebSocketDataSourceProvider);
    _userStatusSubscription = wsDataSource.userStatusStream.listen((statusUpdate) {
      _handleUserStatusUpdate(userId: statusUpdate.userId, isOnline: statusUpdate.isOnline);
    });

    ref.onDispose(() {
      _userStatusSubscription?.cancel();
    });

    return _fetchOnlineUsers();
  }
  Future<List<User>> _fetchOnlineUsers() async {
    final contactsState = ref.read(contactProvider);
    final onlineUsers = contactsState.contacts
        .where((contact) => contact.online)
        .map(
          (contact) => User(
            id: contact.contactUserId,
            username: contact.username,
            email: '', // Not available in Contact entity
            emailVerified: false, // Not available in Contact entity
            fullName: contact.fullName,
            avatarUrl: contact.avatarUrl,
            online: contact.online,
            lastSeen: contact.lastSeen,
            createdAt: contact.createdAt,
          ),
        )
        .toList();
    if (onlineUsers.isEmpty) {
      return [
        User(
          id: 2,
          username: 'user2',
          email: 'user2@example.com',
          emailVerified: true,
          fullName: 'John Doe',
          avatarUrl: 'https://i.pravatar.cc/150?img=1',
          online: true,
          lastSeen: DateTime.now(),
          createdAt: DateTime.now(),
        ),
        User(
          id: 3,
          username: 'user3',
          email: 'user3@example.com',
          emailVerified: true,
          fullName: 'Jane Smith',
          avatarUrl: 'https://i.pravatar.cc/150?img=2',
          online: true,
          lastSeen: DateTime.now(),
          createdAt: DateTime.now(),
        ),
        User(
          id: 4,
          username: 'user4',
          email: 'user4@example.com',
          emailVerified: true,
          fullName: 'Bob Wilson',
          avatarUrl: 'https://i.pravatar.cc/150?img=3',
          online: true,
          lastSeen: DateTime.now(),
          createdAt: DateTime.now(),
        ),
      ];
    }

    return onlineUsers;
  }
  Future<void> refresh() async {
    await ref.read(contactProvider.notifier).loadContacts();
    state = await AsyncValue.guard(() => _fetchOnlineUsers());
  }
  void _handleUserStatusUpdate({required String userId, required bool isOnline}) {
    final currentState = state.value;
    if (currentState == null) return;

    final userIdInt = int.tryParse(userId);
    if (userIdInt == null) return;

    if (isOnline) {
      if (!currentState.any((user) => user.id == userIdInt)) {
        refresh();
      } else {
        final updatedUsers = currentState.map((user) {
          if (user.id == userIdInt) {
            return user.copyWith(online: true, lastSeen: null);
          }
          return user;
        }).toList();

        state = AsyncValue.data(updatedUsers);
      }
    } else {
      final updatedUsers = currentState.where((user) => user.id != userIdInt).toList();

      state = AsyncValue.data(updatedUsers);
    }
  }
  void updateUserStatus(String userId, bool isOnline) {
    _handleUserStatusUpdate(userId: userId, isOnline: isOnline);
  }
}

================================================================
FILE: lib/features/chat/presentation/utils/conversation_utils.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/enums.dart';
import 'package:chattrix_ui/features/auth/domain/entities/user.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/domain/entities/participant.dart';

class ConversationUtils {

  static String getConversationTitle(Conversation conversation, User? currentUser) {
    if (conversation.type == ConversationType.group) {

      if (conversation.name != null && conversation.name!.isNotEmpty) {
        return conversation.name!;
      }

      final otherParticipants = conversation.participants.where((p) => p.userId != currentUser?.id).take(3).toList();

      if (otherParticipants.isEmpty) {
        return 'Group Chat';
      }

      return otherParticipants.map((p) => p.fullName.isNotEmpty ? p.fullName : p.username).join(', ');
    } else {

      final otherParticipant = conversation.participants.firstWhere(
        (p) => p.userId != currentUser?.id,
        orElse: () => conversation.participants.first,
      );

      if (otherParticipant.nickname != null && otherParticipant.nickname!.isNotEmpty) {
        return otherParticipant.nickname!;
      }

      if (otherParticipant.fullName.isNotEmpty) {
        return otherParticipant.fullName;
      }

      return otherParticipant.username;
    }
  }

  static String formatLastMessage(Message? lastMessage, User? currentUser) {
    if (lastMessage == null) {
      return 'No messages yet';
    }

    String content;

    if (lastMessage.type.toUpperCase() == 'IMAGE') {
      content = 'üì∑ Photo';
    } else if (lastMessage.type.toUpperCase() == 'FILE') {
      content = 'üìé File';
    } else {
      content = lastMessage.content;
    }

    if (currentUser != null && lastMessage.senderId == currentUser.id) {
      return 'You: $content';
    }

    return content;
  }

  static String formatTimeAgo(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inMinutes < 60) {
      final minutes = difference.inMinutes;
      if (minutes < 1) {
        return '0m';
      }
      return '${minutes}m';
    }

    final isToday = now.year == dateTime.year && now.month == dateTime.month && now.day == dateTime.day;

    if (isToday) {

      final hour = dateTime.hour.toString().padLeft(2, '0');
      final minute = dateTime.minute.toString().padLeft(2, '0');
      return '$hour:$minute';
    }

    final yesterday = now.subtract(const Duration(days: 1));
    final isYesterday =
        yesterday.year == dateTime.year && yesterday.month == dateTime.month && yesterday.day == dateTime.day;

    if (isYesterday) {

      return 'Yesterday';
    }

    if (difference.inDays < 7) {

      const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

      return dayNames[dateTime.weekday - 1];
    }

    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    final month = monthNames[dateTime.month - 1];
    final day = dateTime.day;
    return '$month $day';
  }

  static String formatLastSeen(bool isOnline, DateTime? lastSeen) {
    if (isOnline) {
      return 'Active now';
    }

    if (lastSeen == null) {
      return 'Offline';
    }

    return 'Active ${formatTimeAgo(lastSeen)}';
  }

  static Participant? getOtherParticipant(Conversation conversation, User? currentUser) {
    if (conversation.type != ConversationType.direct) {
      return null;
    }

    try {
      return conversation.participants.firstWhere((p) => p.userId != currentUser?.id);
    } catch (e) {
      return conversation.participants.isNotEmpty ? conversation.participants.first : null;
    }
  }

  static String? getOtherParticipantId(Conversation? conversation, User? currentUser) {
    if (conversation == null) {
      return null;
    }

    final otherParticipant = getOtherParticipant(conversation, currentUser);
    return otherParticipant?.userId.toString();
  }

  static bool isUserOnline(Conversation conversation, User? currentUser) {
    final otherParticipant = getOtherParticipant(conversation, currentUser);
    return otherParticipant?.online ?? false;
  }

  static DateTime? getLastSeen(Conversation conversation, User? currentUser) {
    final otherParticipant = getOtherParticipant(conversation, currentUser);
    return otherParticipant?.lastSeen;
  }

  static User? getOtherUser(Conversation conversation, User? currentUser) {
    final otherParticipant = getOtherParticipant(conversation, currentUser);
    if (otherParticipant == null) {
      return null;
    }

    return User(
      id: otherParticipant.userId,
      username: otherParticipant.username,
      email: otherParticipant.email ?? '', // Use participant email if available
      fullName: otherParticipant.fullName,
      avatarUrl: otherParticipant.avatarUrl, // Now available in Participant
      online: otherParticipant.online ?? false,
      lastSeen: otherParticipant.lastSeen,
      emailVerified: false, // Not available in Participant
      createdAt: DateTime.now(), // Not available in Participant
    );
  }

  static String? getOtherParticipantAvatarUrl(Conversation conversation, User? currentUser) {
    final otherParticipant = getOtherParticipant(conversation, currentUser);
    return otherParticipant?.avatarUrl;
  }
}

================================================================
FILE: lib/features/chat/presentation/utils/format_utils.dart
================================================================
import 'package:flutter/material.dart';

class FormatUtils {

  static String formatFileSize(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    if (bytes < 1024 * 1024 * 1024) {
      return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
    }
    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(1)} GB';
  }

  static String formatDuration(int seconds) {
    final minutes = seconds ~/ 60;
    final remainingSeconds = seconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${remainingSeconds.toString().padLeft(2, '0')}';
  }

  static String formatDateTime(DateTime dateTime) {
    final day = dateTime.day.toString().padLeft(2, '0');
    final month = dateTime.month.toString().padLeft(2, '0');
    final year = dateTime.year.toString();
    final hour = dateTime.hour.toString().padLeft(2, '0');
    final minute = dateTime.minute.toString().padLeft(2, '0');
    return '$day/$month/$year $hour:$minute';
  }

  static String formatDate(DateTime dateTime) {
    final day = dateTime.day.toString().padLeft(2, '0');
    final month = dateTime.month.toString().padLeft(2, '0');
    final year = dateTime.year.toString();
    return '$day/$month/$year';
  }

  static String formatTimeAgo(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inMinutes < 1) {
      return 'just now';
    } else if (difference.inHours < 1) {
      final minutes = difference.inMinutes;
      return '$minutes ${minutes == 1 ? 'minute' : 'minutes'} ago';
    } else if (difference.inDays < 1) {
      final hours = difference.inHours;
      return '$hours ${hours == 1 ? 'hour' : 'hours'} ago';
    } else if (difference.inDays < 7) {
      final days = difference.inDays;
      return '$days ${days == 1 ? 'day' : 'days'} ago';
    } else {
      return formatDate(dateTime);
    }
  }

  static Color getTextColor(BuildContext context, bool isMe) {
    final theme = Theme.of(context);
    final colors = theme.colorScheme;
    final isDark = theme.brightness == Brightness.dark;

    return isMe ? (isDark ? colors.onPrimary : Colors.black) : (isDark ? colors.onSurface : Colors.white);
  }
}

================================================================
FILE: lib/features/chat/presentation/utils/typing_debouncer.dart
================================================================
import 'dart:async';
class TypingDebouncer {
  Timer? _debounceTimer;
  Timer? _stopTimer;
  bool _isTyping = false;

  final Duration debounceDuration;
  final Duration stopDuration;

  TypingDebouncer({
    this.debounceDuration = const Duration(milliseconds: 300),
    this.stopDuration = const Duration(seconds: 3),
  });
  void onTextChanged(String text, void Function() onStart, void Function() onStop) {
    _debounceTimer?.cancel();
    _stopTimer?.cancel();
    if (text.trim().isEmpty) {
      if (_isTyping) {
        onStop();
        _isTyping = false;
      }
      return;
    }
    _debounceTimer = Timer(debounceDuration, () {
      if (!_isTyping) {
        onStart();
        _isTyping = true;
      }
      _scheduleAutoStop(onStop);
    });
  }
  void _scheduleAutoStop(void Function() onStop) {
    _stopTimer?.cancel();
    _stopTimer = Timer(stopDuration, () {
      if (_isTyping) {
        onStop();
        _isTyping = false;
      }
    });
  }
  void stop(void Function() onStop) {
    _debounceTimer?.cancel();
    _stopTimer?.cancel();

    if (_isTyping) {
      onStop();
      _isTyping = false;
    }
  }
  bool get isTyping => _isTyping;
  void dispose() {
    _debounceTimer?.cancel();
    _stopTimer?.cancel();
    _debounceTimer = null;
    _stopTimer = null;
    _isTyping = false;
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/attachment_picker_bottom_sheet.dart
================================================================
import 'package:flutter/material.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';

class AttachmentPickerBottomSheet extends StatelessWidget {
  const AttachmentPickerBottomSheet({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colors = theme.colorScheme;

    return Container(
      padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 16),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: SafeArea(
        top: false,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [

            Container(
              width: 40,
              height: 4,
              margin: const EdgeInsets.only(bottom: 20),
              decoration: BoxDecoration(
                color: colors.onSurface.withValues(alpha: 0.3),
                borderRadius: BorderRadius.circular(2),
              ),
            ),

            Text('Send Attachment', style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold)),
            const SizedBox(height: 20),

            GridView.count(
              shrinkWrap: true,
              crossAxisCount: 3,
              mainAxisSpacing: 16,
              crossAxisSpacing: 16,
              physics: const NeverScrollableScrollPhysics(),
              children: [
                _AttachmentOption(
                  icon: FontAwesomeIcons.camera,
                  label: 'Camera',
                  color: Colors.pink,
                  onTap: () => Navigator.pop(context, AttachmentType.camera),
                ),
                _AttachmentOption(
                  icon: FontAwesomeIcons.image,
                  label: 'Gallery',
                  color: Colors.purple,
                  onTap: () => Navigator.pop(context, AttachmentType.gallery),
                ),
                _AttachmentOption(
                  icon: FontAwesomeIcons.video,
                  label: 'Video',
                  color: Colors.red,
                  onTap: () => Navigator.pop(context, AttachmentType.video),
                ),
                _AttachmentOption(
                  icon: FontAwesomeIcons.microphone,
                  label: 'Audio',
                  color: Colors.orange,
                  onTap: () => Navigator.pop(context, AttachmentType.audio),
                ),
                _AttachmentOption(
                  icon: FontAwesomeIcons.fileLines,
                  label: 'Document',
                  color: Colors.blue,
                  onTap: () => Navigator.pop(context, AttachmentType.document),
                ),
                _AttachmentOption(
                  icon: FontAwesomeIcons.locationDot,
                  label: 'Location',
                  color: Colors.green,
                  onTap: () => Navigator.pop(context, AttachmentType.location),
                ),
              ],
            ),
            const SizedBox(height: 10),
          ],
        ),
      ),
    );
  }

  static Future<AttachmentType?> show(BuildContext context) {
    return showModalBottomSheet<AttachmentType>(
      context: context,
      backgroundColor: Colors.transparent,
      isScrollControlled: true,
      builder: (context) => const AttachmentPickerBottomSheet(),
    );
  }
}

class _AttachmentOption extends StatelessWidget {
  const _AttachmentOption({required this.icon, required this.label, required this.color, required this.onTap});

  final IconData icon;
  final String label;
  final Color color;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            width: 60,
            height: 60,
            decoration: BoxDecoration(color: color.withValues(alpha: 0.15), borderRadius: BorderRadius.circular(12)),
            child: Icon(icon, color: color, size: 28),
          ),
          const SizedBox(height: 8),
          Text(
            label,
            style: theme.textTheme.bodySmall?.copyWith(fontWeight: FontWeight.w500),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}

enum AttachmentType { camera, gallery, video, audio, document, location }

================================================================
FILE: lib/features/chat/presentation/widgets/chat_info/chat_info_header.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/enums.dart';
import 'package:chattrix_ui/core/widgets/user_avatar.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/presentation/utils/conversation_utils.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class ChatInfoHeader extends ConsumerWidget {
  const ChatInfoHeader({super.key, required this.conversation});

  final Conversation conversation;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;
    final me = ref.watch(currentUserProvider);

    final isGroup = conversation.type == ConversationType.group;
    final displayName = isGroup
        ? (conversation.name ?? 'Group ${conversation.id}')
        : ConversationUtils.getConversationTitle(conversation, me);

    final memberCount = conversation.participants.length;

    final isOnline = !isGroup && ConversationUtils.isUserOnline(conversation, me);
    final lastSeen = !isGroup ? ConversationUtils.getLastSeen(conversation, me) : null;
    final statusText = !isGroup ? ConversationUtils.formatLastSeen(isOnline, lastSeen) : null;

    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: colors.surface,
        border: Border(bottom: BorderSide(color: colors.onSurface.withValues(alpha: 0.1))),
      ),
      child: Column(
        children: [

          UserAvatar(
            displayName: displayName,
            avatarUrl: null, // TODO: Add avatarUrl when backend supports it
            radius: 50,
            backgroundColor: colors.primary,
          ),
          const SizedBox(height: 16),

          Text(
            displayName,
            style: textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 8),

          if (isGroup)
            Text(
              '$memberCount members',
              style: textTheme.bodyMedium?.copyWith(color: colors.onSurface.withValues(alpha: 0.6)),
            )
          else if (statusText != null)
            Text(
              statusText,
              style: textTheme.bodyMedium?.copyWith(
                color: isOnline ? Colors.green : colors.onSurface.withValues(alpha: 0.6),
              ),
            ),

          const SizedBox(height: 16),

          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _QuickActionButton(
                icon: Icons.notifications_outlined,
                label: 'Mute',
                onTap: () {

                },
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class _QuickActionButton extends StatelessWidget {
  const _QuickActionButton({required this.icon, required this.label, required this.onTap});

  final IconData icon;
  final String label;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(color: colors.primary.withValues(alpha: 0.1), shape: BoxShape.circle),
              child: Icon(icon, color: colors.primary, size: 24),
            ),
            const SizedBox(height: 8),
            Text(label, style: textTheme.labelSmall),
          ],
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/chat_info/media_grid_item.dart
================================================================
import 'package:cached_network_image/cached_network_image.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/presentation/utils/format_utils.dart';
import 'package:flutter/material.dart';

class MediaGridItem extends StatelessWidget {
  const MediaGridItem({super.key, required this.message});

  final Message message;

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;

    return InkWell(
      onTap: () {

        _showMediaViewer(context);
      },
      child: Container(
        decoration: BoxDecoration(
          color: colors.surface,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: colors.onSurface.withValues(alpha: 0.1)),
        ),
        child: ClipRRect(borderRadius: BorderRadius.circular(8), child: _buildMediaPreview(context)),
      ),
    );
  }

  Widget _buildMediaPreview(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    switch (message.type.toUpperCase()) {
      case 'IMAGE':
        return Stack(
          fit: StackFit.expand,
          children: [
            CachedNetworkImage(
              imageUrl: message.thumbnailUrl ?? message.mediaUrl ?? '',
              fit: BoxFit.cover,
              placeholder: (context, url) => Container(
                color: colors.surface,
                child: const Center(child: CircularProgressIndicator()),
              ),
              errorWidget: (context, url, error) => Container(
                color: colors.surface,
                child: Icon(Icons.broken_image, color: colors.onSurface.withValues(alpha: 0.3)),
              ),
            ),
          ],
        );

      case 'VIDEO':
        return Stack(
          fit: StackFit.expand,
          children: [
            if (message.thumbnailUrl != null)
              CachedNetworkImage(
                imageUrl: message.thumbnailUrl!,
                fit: BoxFit.cover,
                placeholder: (context, url) => Container(color: colors.surface),
                errorWidget: (context, url, error) => Container(
                  color: colors.surface,
                  child: Icon(Icons.videocam, color: colors.onSurface.withValues(alpha: 0.3)),
                ),
              )
            else
              Container(
                color: colors.surface,
                child: Icon(Icons.videocam, color: colors.onSurface.withValues(alpha: 0.3)),
              ),
            Center(
              child: Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(color: Colors.black.withValues(alpha: 0.6), shape: BoxShape.circle),
                child: const Icon(Icons.play_arrow, color: Colors.white, size: 24),
              ),
            ),
            if (message.duration != null)
              Positioned(
                bottom: 4,
                right: 4,
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                  decoration: BoxDecoration(
                    color: Colors.black.withValues(alpha: 0.6),
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Text(
                    FormatUtils.formatDuration(message.duration!),
                    style: textTheme.labelSmall?.copyWith(color: Colors.white),
                  ),
                ),
              ),
          ],
        );

      case 'AUDIO':
        return Container(
          color: colors.primary.withValues(alpha: 0.1),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.audiotrack, color: colors.primary, size: 32),
              if (message.duration != null) ...[
                const SizedBox(height: 4),
                Text(
                  FormatUtils.formatDuration(message.duration!),
                  style: textTheme.labelSmall?.copyWith(color: colors.primary),
                ),
              ],
            ],
          ),
        );

      case 'DOCUMENT':
        return Container(
          color: colors.surface,
          padding: const EdgeInsets.all(8),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.insert_drive_file, color: colors.primary, size: 32),
              const SizedBox(height: 4),
              Text(
                message.fileName ?? 'File',
                style: textTheme.labelSmall,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
                textAlign: TextAlign.center,
              ),
            ],
          ),
        );

      default:
        return Container(
          color: colors.surface,
          child: Icon(Icons.attachment, color: colors.onSurface.withValues(alpha: 0.3)),
        );
    }
  }

  void _showMediaViewer(BuildContext context) {

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Media Viewer'),
        content: Text('View ${message.type}: ${message.mediaUrl}'),
        actions: [TextButton(onPressed: () => Navigator.pop(context), child: const Text('Close'))],
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/chat_info/media_grid_widget.dart
================================================================
import 'package:chattrix_ui/features/chat/presentation/providers/chat_providers.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/chat_info/media_grid_item.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class MediaGridWidget extends HookConsumerWidget {
  const MediaGridWidget({super.key, required this.conversationId});

  final String conversationId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedMediaType = useState<String>('ALL');
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    final messagesAsync = ref.watch(messagesProvider(conversationId));

    return Column(
      children: [

        Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          decoration: BoxDecoration(
            color: colors.surface,
            border: Border(bottom: BorderSide(color: colors.onSurface.withValues(alpha: 0.1))),
          ),
          child: SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              children: [
                _MediaTypeChip(
                  label: 'T·∫•t c·∫£',
                  isSelected: selectedMediaType.value == 'ALL',
                  onTap: () => selectedMediaType.value = 'ALL',
                ),
                const SizedBox(width: 8),
                _MediaTypeChip(
                  label: 'Photos',
                  icon: Icons.image,
                  isSelected: selectedMediaType.value == 'IMAGE',
                  onTap: () => selectedMediaType.value = 'IMAGE',
                ),
                const SizedBox(width: 8),
                _MediaTypeChip(
                  label: 'Videos',
                  icon: Icons.videocam,
                  isSelected: selectedMediaType.value == 'VIDEO',
                  onTap: () => selectedMediaType.value = 'VIDEO',
                ),
                const SizedBox(width: 8),
                _MediaTypeChip(
                  label: 'File',
                  icon: Icons.insert_drive_file,
                  isSelected: selectedMediaType.value == 'DOCUMENT',
                  onTap: () => selectedMediaType.value = 'DOCUMENT',
                ),
                const SizedBox(width: 8),
                _MediaTypeChip(
                  label: 'Audio',
                  icon: Icons.audiotrack,
                  isSelected: selectedMediaType.value == 'AUDIO',
                  onTap: () => selectedMediaType.value = 'AUDIO',
                ),
              ],
            ),
          ),
        ),

        Expanded(
          child: messagesAsync.when(
            data: (messages) {

              final mediaMessages = messages.where((m) {
                if (selectedMediaType.value == 'ALL') {
                  return m.mediaUrl != null;
                }
                return m.type.toUpperCase() == selectedMediaType.value;
              }).toList();

              if (mediaMessages.isEmpty) {
                return Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.photo_library_outlined, size: 64, color: colors.onSurface.withValues(alpha: 0.3)),
                      const SizedBox(height: 16),
                      Text(
                        'No media yet',
                        style: textTheme.bodyLarge?.copyWith(color: colors.onSurface.withValues(alpha: 0.6)),
                      ),
                    ],
                  ),
                );
              }

              return GridView.builder(
                padding: const EdgeInsets.all(16),
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 3,
                  crossAxisSpacing: 8,
                  mainAxisSpacing: 8,
                ),
                itemCount: mediaMessages.length,
                itemBuilder: (context, index) {
                  final message = mediaMessages[index];
                  return MediaGridItem(message: message);
                },
              );
            },
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, st) => Center(child: Text('Failed to load media', style: textTheme.bodyMedium)),
          ),
        ),
      ],
    );
  }
}

class _MediaTypeChip extends StatelessWidget {
  const _MediaTypeChip({required this.label, this.icon, required this.isSelected, required this.onTap});

  final String label;
  final IconData? icon;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(20),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        decoration: BoxDecoration(
          color: isSelected ? colors.primary : colors.surface,
          borderRadius: BorderRadius.circular(20),
          border: Border.all(color: isSelected ? colors.primary : colors.onSurface.withValues(alpha: 0.2)),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (icon != null) ...[
              Icon(icon, size: 16, color: isSelected ? colors.onPrimary : colors.onSurface),
              const SizedBox(width: 4),
            ],
            Text(
              label,
              style: textTheme.labelMedium?.copyWith(color: isSelected ? colors.onPrimary : colors.onSurface),
            ),
          ],
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/chat_info/members_list_widget.dart
================================================================
import 'package:chattrix_ui/core/widgets/user_avatar.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/domain/entities/participant.dart';
import 'package:chattrix_ui/features/chat/presentation/utils/format_utils.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class MembersListWidget extends HookConsumerWidget {
  const MembersListWidget({super.key, required this.conversation});

  final Conversation conversation;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final searchController = useTextEditingController();
    final searchQuery = useState('');
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;
    final me = ref.watch(currentUserProvider);

    final myParticipant = conversation.participants.firstWhere(
      (p) => p.userId == me?.id,
      orElse: () => conversation.participants.first,
    );
    final isAdmin = myParticipant.role.toUpperCase() == 'ADMIN';

    return Column(
      children: [

        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: colors.surface,
            border: Border(bottom: BorderSide(color: colors.onSurface.withValues(alpha: 0.1))),
          ),
          child: Column(
            children: [

              TextField(
                controller: searchController,
                onChanged: (value) => searchQuery.value = value,
                decoration: InputDecoration(
                  hintText: 'Search members...',
                  prefixIcon: const Icon(Icons.search),
                  suffixIcon: searchController.text.isNotEmpty
                      ? IconButton(
                          icon: const Icon(Icons.clear),
                          onPressed: () {
                            searchController.clear();
                            searchQuery.value = '';
                          },
                        )
                      : null,
                  filled: true,
                  fillColor: colors.surface.withValues(alpha: 0.6),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                    borderSide: BorderSide(color: colors.onSurface.withValues(alpha: 0.2)),
                  ),
                ),
              ),
              if (isAdmin) ...[
                const SizedBox(height: 12),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton.icon(
                    onPressed: () {

                      _showAddMemberDialog(context);
                    },
                    icon: const Icon(Icons.person_add),
                    label: const Text('Add Member'),
                  ),
                ),
              ],
            ],
          ),
        ),

        Expanded(
          child: Builder(
            builder: (context) {

              final filteredMembers = conversation.participants.where((p) {
                if (searchQuery.value.isEmpty) return true;
                final query = searchQuery.value.toLowerCase();
                return p.fullName.toLowerCase().contains(query) || p.username.toLowerCase().contains(query);
              }).toList();

              filteredMembers.sort((a, b) {
                if (a.role.toUpperCase() == 'ADMIN' && b.role.toUpperCase() != 'ADMIN') {
                  return -1;
                }
                if (a.role.toUpperCase() != 'ADMIN' && b.role.toUpperCase() == 'ADMIN') {
                  return 1;
                }
                return a.fullName.compareTo(b.fullName);
              });

              if (filteredMembers.isEmpty) {
                return Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.people_outline, size: 64, color: colors.onSurface.withValues(alpha: 0.3)),
                      const SizedBox(height: 16),
                      Text(
                        'No members found',
                        style: textTheme.bodyLarge?.copyWith(color: colors.onSurface.withValues(alpha: 0.6)),
                      ),
                    ],
                  ),
                );
              }

              return ListView.builder(
                padding: const EdgeInsets.all(16),
                itemCount: filteredMembers.length,
                itemBuilder: (context, index) {
                  final member = filteredMembers[index];
                  final isMe = member.userId == me?.id;
                  final isMemberAdmin = member.role.toUpperCase() == 'ADMIN';

                  return _MemberListItem(
                    member: member,
                    isMe: isMe,
                    isAdmin: isMemberAdmin,
                    canManage: isAdmin && !isMe,
                    onTap: () {

                    },
                    onManage: isAdmin && !isMe
                        ? () {
                            _showMemberManagementDialog(context, member, isMemberAdmin);
                          }
                        : null,
                  );
                },
              );
            },
          ),
        ),
      ],
    );
  }

  void _showAddMemberDialog(BuildContext context) {

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Add Member'),
        content: const Text('Feature in development'),
        actions: [TextButton(onPressed: () => Navigator.pop(context), child: const Text('Close'))],
      ),
    );
  }

  void _showMemberManagementDialog(BuildContext context, Participant member, bool isAdmin) {
    showModalBottomSheet(
      context: context,
      builder: (context) => Container(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: CircleAvatar(
                child: Text(member.fullName.isNotEmpty ? member.fullName.substring(0, 1).toUpperCase() : '?'),
              ),
              title: Text(member.fullName),
              subtitle: Text('@${member.username}'),
            ),
            const Divider(),
            if (!isAdmin)
              ListTile(
                leading: const Icon(Icons.admin_panel_settings),
                title: const Text('Make Admin'),
                onTap: () {
                  Navigator.pop(context);
                  _confirmPromoteToAdmin(context, member);
                },
              ),
            if (isAdmin)
              ListTile(
                leading: const Icon(Icons.remove_moderator),
                title: const Text('Remove Admin'),
                onTap: () {
                  Navigator.pop(context);
                  _confirmDemoteFromAdmin(context, member);
                },
              ),
            ListTile(
              leading: const Icon(Icons.person_remove, color: Colors.red),
              title: const Text('Remove from group', style: TextStyle(color: Colors.red)),
              onTap: () {
                Navigator.pop(context);
                _confirmRemoveMember(context, member);
              },
            ),
          ],
        ),
      ),
    );
  }

  void _confirmPromoteToAdmin(BuildContext context, Participant member) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Make Admin'),
        content: Text('Are you sure you want to make ${member.fullName} an admin?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
          TextButton(
            onPressed: () {

              Navigator.pop(context);
            },
            child: const Text('Confirm'),
          ),
        ],
      ),
    );
  }

  void _confirmDemoteFromAdmin(BuildContext context, Participant member) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remove Admin'),
        content: Text('Are you sure you want to remove admin privileges from ${member.fullName}?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
          TextButton(
            onPressed: () {

              Navigator.pop(context);
            },
            child: const Text('Confirm'),
          ),
        ],
      ),
    );
  }

  void _confirmRemoveMember(BuildContext context, Participant member) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remove Member'),
        content: Text('Are you sure you want to remove ${member.fullName} from the group?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
          TextButton(
            onPressed: () {

              Navigator.pop(context);
            },
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Remove'),
          ),
        ],
      ),
    );
  }
}

class _MemberListItem extends StatelessWidget {
  const _MemberListItem({
    required this.member,
    required this.isMe,
    required this.isAdmin,
    required this.canManage,
    required this.onTap,
    this.onManage,
  });

  final Participant member;
  final bool isMe;
  final bool isAdmin;
  final bool canManage;
  final VoidCallback onTap;
  final VoidCallback? onManage;

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: colors.onSurface.withValues(alpha: 0.1)),
      ),
      child: ListTile(
        leading: Stack(
          children: [
            UserAvatar(
              displayName: member.fullName,
              avatarUrl: null, // TODO: Add avatarUrl when backend supports it
              radius: 20,
              backgroundColor: colors.primary,
            ),
            if (member.online ?? false)
              Positioned(
                right: 0,
                bottom: 0,
                child: Container(
                  width: 12,
                  height: 12,
                  decoration: BoxDecoration(
                    color: Colors.green,
                    shape: BoxShape.circle,
                    border: Border.all(color: colors.surface, width: 2),
                  ),
                ),
              ),
          ],
        ),
        title: Row(
          children: [
            Expanded(child: Text(member.fullName, style: textTheme.bodyLarge)),
            if (isAdmin)
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: colors.primary.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  'Admin',
                  style: textTheme.labelSmall?.copyWith(color: colors.primary, fontWeight: FontWeight.bold),
                ),
              ),
            if (isMe)
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: colors.secondary.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  'You',
                  style: textTheme.labelSmall?.copyWith(color: colors.secondary, fontWeight: FontWeight.bold),
                ),
              ),
          ],
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('@${member.username}'),
            if (member.online ?? false)
              Text('Active now', style: textTheme.labelSmall?.copyWith(color: Colors.green))
            else if (member.lastSeen != null)
              Text(
                'Active ${FormatUtils.formatTimeAgo(member.lastSeen!)}',
                style: textTheme.labelSmall?.copyWith(color: colors.onSurface.withValues(alpha: 0.6)),
              ),
          ],
        ),
        trailing: canManage ? IconButton(icon: const Icon(Icons.more_vert), onPressed: onManage) : null,
        onTap: onTap,
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/chat_info/message_search_widget.dart
================================================================
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/presentation/providers/chat_providers.dart';
import 'package:chattrix_ui/features/chat/presentation/utils/format_utils.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class MessageSearchWidget extends HookConsumerWidget {
  const MessageSearchWidget({super.key, required this.conversationId});

  final String conversationId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final searchController = useTextEditingController();
    final searchQuery = useState('');
    final selectedMessageType = useState<String?>('ALL');
    final sortOrder = useState<String>('DESC'); // DESC = newest first
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    final messagesAsync = ref.watch(messagesProvider(conversationId));
    final me = ref.watch(currentUserProvider);

    useEffect(() {
      Future.delayed(const Duration(milliseconds: 300), () {
        searchQuery.value = searchController.text;
      });
      return () {};
    }, [searchController.text]);

    return Column(
      children: [

        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: colors.surface,
            border: Border(bottom: BorderSide(color: colors.onSurface.withValues(alpha: 0.1))),
          ),
          child: Column(
            children: [

              TextField(
                controller: searchController,
                decoration: InputDecoration(
                  hintText: 'Search messages...',
                  prefixIcon: const Icon(Icons.search),
                  suffixIcon: searchController.text.isNotEmpty
                      ? IconButton(
                          icon: const Icon(Icons.clear),
                          onPressed: () {
                            searchController.clear();
                            searchQuery.value = '';
                          },
                        )
                      : null,
                  filled: true,
                  fillColor: colors.surface.withValues(alpha: 0.6),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                    borderSide: BorderSide(color: colors.onSurface.withValues(alpha: 0.2)),
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                    borderSide: BorderSide(color: colors.onSurface.withValues(alpha: 0.2)),
                  ),
                ),
              ),
              const SizedBox(height: 12),

              Row(
                children: [

                  Expanded(
                    child: DropdownButtonFormField<String>(
                      initialValue: selectedMessageType.value,
                      decoration: InputDecoration(
                        labelText: 'Lo·∫°i tin nh·∫Øn',
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                        contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                      ),
                      items: const [
                        DropdownMenuItem(value: 'ALL', child: Text('T·∫•t c·∫£')),
                        DropdownMenuItem(value: 'TEXT', child: Text('VƒÉn b·∫£n')),
                        DropdownMenuItem(value: 'IMAGE', child: Text('H√¨nh ·∫£nh')),
                        DropdownMenuItem(value: 'VIDEO', child: Text('Video')),
                        DropdownMenuItem(value: 'AUDIO', child: Text('Audio')),
                        DropdownMenuItem(value: 'DOCUMENT', child: Text('T√†i li·ªáu')),
                        DropdownMenuItem(value: 'LOCATION', child: Text('V·ªã tr√≠')),
                      ],
                      onChanged: (value) {
                        selectedMessageType.value = value;
                      },
                    ),
                  ),
                  const SizedBox(width: 12),

                  IconButton(
                    icon: Icon(sortOrder.value == 'DESC' ? Icons.arrow_downward : Icons.arrow_upward),
                    tooltip: sortOrder.value == 'DESC' ? 'M·ªõi nh·∫•t tr∆∞·ªõc' : 'C≈© nh·∫•t tr∆∞·ªõc',
                    onPressed: () {
                      sortOrder.value = sortOrder.value == 'DESC' ? 'ASC' : 'DESC';
                    },
                  ),
                ],
              ),
            ],
          ),
        ),

        Expanded(
          child: messagesAsync.when(
            data: (messages) {

              var filteredMessages = messages.where((m) {

                if (searchQuery.value.isNotEmpty) {
                  final query = searchQuery.value.toLowerCase();
                  if (!m.content.toLowerCase().contains(query)) {
                    return false;
                  }
                }

                if (selectedMessageType.value != null && selectedMessageType.value != 'ALL') {
                  if (m.type.toUpperCase() != selectedMessageType.value) {
                    return false;
                  }
                }

                return true;
              }).toList();

              if (sortOrder.value == 'ASC') {
                filteredMessages = filteredMessages.reversed.toList();
              }

              if (filteredMessages.isEmpty) {
                return Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.search_off, size: 64, color: colors.onSurface.withValues(alpha: 0.3)),
                      const SizedBox(height: 16),
                      Text(
                        searchQuery.value.isEmpty ? 'Enter keywords to search' : 'No messages found',
                        style: textTheme.bodyLarge?.copyWith(color: colors.onSurface.withValues(alpha: 0.6)),
                      ),
                    ],
                  ),
                );
              }

              return ListView.builder(
                padding: const EdgeInsets.all(16),
                itemCount: filteredMessages.length,
                itemBuilder: (context, index) {
                  final message = filteredMessages[index];
                  return _SearchResultItem(
                    message: message,
                    searchQuery: searchQuery.value,
                    isMe: message.senderId == me?.id,
                    onTap: () {

                      context.pop();

                    },
                  );
                },
              );
            },
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, st) => Center(child: Text('Failed to load messages', style: textTheme.bodyMedium)),
          ),
        ),
      ],
    );
  }
}

class _SearchResultItem extends StatelessWidget {
  const _SearchResultItem({required this.message, required this.searchQuery, required this.isMe, required this.onTap});

  final Message message;
  final String searchQuery;
  final bool isMe;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    return InkWell(
      onTap: onTap,
      child: Container(
        margin: const EdgeInsets.only(bottom: 12),
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: colors.surface,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: colors.onSurface.withValues(alpha: 0.1)),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [

            Row(
              children: [
                Expanded(
                  child: Text(
                    isMe ? 'B·∫°n' : (message.senderFullName ?? message.senderUsername ?? 'User'),
                    style: textTheme.labelMedium?.copyWith(fontWeight: FontWeight.bold, color: colors.primary),
                  ),
                ),
                Text(
                  FormatUtils.formatDateTime(message.createdAt),
                  style: textTheme.labelSmall?.copyWith(color: colors.onSurface.withValues(alpha: 0.6)),
                ),
              ],
            ),
            const SizedBox(height: 8),

            _buildHighlightedContent(context),

            if (message.type.toUpperCase() != 'TEXT') ...[
              const SizedBox(height: 8),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: colors.primary.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(_getMessageTypeIcon(), size: 14, color: colors.primary),
                    const SizedBox(width: 4),
                    Text(_getMessageTypeLabel(), style: textTheme.labelSmall?.copyWith(color: colors.primary)),
                  ],
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildHighlightedContent(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    if (searchQuery.isEmpty) {
      return Text(message.content, style: textTheme.bodyMedium, maxLines: 3, overflow: TextOverflow.ellipsis);
    }

    final content = message.content;
    final query = searchQuery.toLowerCase();
    final lowerContent = content.toLowerCase();
    final index = lowerContent.indexOf(query);

    if (index == -1) {
      return Text(content, style: textTheme.bodyMedium, maxLines: 3, overflow: TextOverflow.ellipsis);
    }

    return RichText(
      maxLines: 3,
      overflow: TextOverflow.ellipsis,
      text: TextSpan(
        style: textTheme.bodyMedium,
        children: [
          TextSpan(text: content.substring(0, index)),
          TextSpan(
            text: content.substring(index, index + query.length),
            style: TextStyle(backgroundColor: colors.primary.withValues(alpha: 0.3), fontWeight: FontWeight.bold),
          ),
          TextSpan(text: content.substring(index + query.length)),
        ],
      ),
    );
  }

  IconData _getMessageTypeIcon() {
    switch (message.type.toUpperCase()) {
      case 'IMAGE':
        return Icons.image;
      case 'VIDEO':
        return Icons.videocam;
      case 'AUDIO':
        return Icons.audiotrack;
      case 'DOCUMENT':
        return Icons.insert_drive_file;
      case 'LOCATION':
        return Icons.location_on;
      default:
        return Icons.message;
    }
  }

  String _getMessageTypeLabel() {
    switch (message.type.toUpperCase()) {
      case 'IMAGE':
        return 'H√¨nh ·∫£nh';
      case 'VIDEO':
        return 'Video';
      case 'AUDIO':
        return 'Audio';
      case 'DOCUMENT':
        return 'T√†i li·ªáu';
      case 'LOCATION':
        return 'V·ªã tr√≠';
      default:
        return message.type;
    }
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/chat_info/settings_section_widget.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/enums.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class SettingsSectionWidget extends HookConsumerWidget {
  const SettingsSectionWidget({super.key, required this.conversation});

  final Conversation conversation;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isMuted = useState(false);
    final isBlocked = useState(false);
    final notificationsEnabled = useState(true);

    final isGroup = conversation.type == ConversationType.group;

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [

        _SectionHeader(title: 'Customization'),
        const SizedBox(height: 8),
        _SettingsTile(
          icon: Icons.color_lens_outlined,
          title: 'Theme & Colors',
          subtitle: 'Change conversation appearance',
          onTap: () {

            _showThemeCustomization(context);
          },
        ),
        if (!isGroup)
          _SettingsTile(
            icon: Icons.edit_outlined,
            title: 'Nickname',
            subtitle: 'Set a nickname for this person',
            onTap: () {

              _showNicknameDialog(context);
            },
          ),
        if (isGroup)
          _SettingsTile(
            icon: Icons.image_outlined,
            title: 'Change Group Photo',
            subtitle: 'Update group avatar',
            onTap: () {

            },
          ),
        if (isGroup)
          _SettingsTile(
            icon: Icons.edit_outlined,
            title: 'Rename Group',
            subtitle: 'Change group name',
            onTap: () {

              _showRenameGroupDialog(context);
            },
          ),

        const SizedBox(height: 24),

        _SectionHeader(title: 'Notifications'),
        const SizedBox(height: 8),
        _SettingsSwitchTile(
          icon: Icons.notifications_outlined,
          title: 'Notifications',
          subtitle: notificationsEnabled.value
              ? 'Receive notifications from this conversation'
              : 'Notifications disabled',
          value: notificationsEnabled.value,
          onChanged: (value) {
            notificationsEnabled.value = value;

          },
        ),
        _SettingsSwitchTile(
          icon: Icons.volume_off_outlined,
          title: 'Mute',
          subtitle: isMuted.value ? 'Conversation is muted' : 'Mute notification sounds',
          value: isMuted.value,
          onChanged: (value) {
            isMuted.value = value;

          },
        ),

        const SizedBox(height: 24),

        _SectionHeader(title: 'Privacy & Support'),
        const SizedBox(height: 8),
        if (!isGroup)
          _SettingsSwitchTile(
            icon: Icons.block_outlined,
            title: 'Block',
            subtitle: isBlocked.value ? 'User is blocked' : 'Block messages and calls',
            value: isBlocked.value,
            onChanged: (value) {
              isBlocked.value = value;

              _confirmBlock(context, value);
            },
            isDestructive: true,
          ),
        _SettingsTile(
          icon: Icons.report_outlined,
          title: 'Report',
          subtitle: 'Report spam or abuse',
          onTap: () {

            _showReportDialog(context);
          },
        ),

        const SizedBox(height: 24),

        _SectionHeader(title: 'Danger Zone', isDestructive: true),
        const SizedBox(height: 8),
        if (isGroup)
          _SettingsTile(
            icon: Icons.exit_to_app_outlined,
            title: 'Leave Group',
            subtitle: 'You will no longer be a member',
            onTap: () {

              _confirmLeaveGroup(context);
            },
            isDestructive: true,
          ),
        _SettingsTile(
          icon: Icons.delete_outline,
          title: 'Delete Conversation',
          subtitle: 'Delete all message history',
          onTap: () {

            _confirmDeleteConversation(context);
          },
          isDestructive: true,
        ),
      ],
    );
  }

  void _showThemeCustomization(BuildContext context) {
    showModalBottomSheet(
      context: context,
      builder: (context) => Container(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text('Choose Theme Color'),
            const SizedBox(height: 16),
            Wrap(
              spacing: 12,
              children: [Colors.blue, Colors.green, Colors.red, Colors.purple, Colors.orange].map((color) {
                return InkWell(
                  onTap: () {

                    Navigator.pop(context);
                  },
                  child: Container(
                    width: 50,
                    height: 50,
                    decoration: BoxDecoration(color: color, shape: BoxShape.circle),
                  ),
                );
              }).toList(),
            ),
          ],
        ),
      ),
    );
  }

  void _showNicknameDialog(BuildContext context) {
    final controller = TextEditingController();
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Set Nickname'),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(hintText: 'Enter nickname...'),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
          TextButton(
            onPressed: () {

              Navigator.pop(context);
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  void _showRenameGroupDialog(BuildContext context) {
    final controller = TextEditingController(text: conversation.name);
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Rename Group'),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(hintText: 'Enter group name...'),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
          TextButton(
            onPressed: () {

              Navigator.pop(context);
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  void _confirmBlock(BuildContext context, bool block) {
    if (!block) return; // No confirmation needed for unblock

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Block User'),
        content: const Text(
          'You will not receive messages and calls from this person. '
          'They will not be notified that you blocked them.',
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
          TextButton(
            onPressed: () {

              Navigator.pop(context);
            },
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Block'),
          ),
        ],
      ),
    );
  }

  void _showReportDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Report'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              title: const Text('Spam'),
              onTap: () {

                Navigator.pop(context);
              },
            ),
            ListTile(
              title: const Text('Abuse'),
              onTap: () {

                Navigator.pop(context);
              },
            ),
            ListTile(
              title: const Text('Inappropriate Content'),
              onTap: () {

                Navigator.pop(context);
              },
            ),
          ],
        ),
      ),
    );
  }

  void _confirmLeaveGroup(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Leave Group'),
        content: const Text(
          'Are you sure you want to leave this group? '
          'You will not be able to see new messages.',
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
          TextButton(
            onPressed: () {

              Navigator.pop(context);
              context.pop(); // Go back to conversations list
            },
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Leave'),
          ),
        ],
      ),
    );
  }

  void _confirmDeleteConversation(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Conversation'),
        content: const Text(
          'Are you sure you want to delete this conversation? '
          'All message history will be permanently deleted.',
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
          TextButton(
            onPressed: () {

              Navigator.pop(context);
              context.pop(); // Go back to conversations list
            },
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }
}

class _SectionHeader extends StatelessWidget {
  const _SectionHeader({required this.title, this.isDestructive = false});

  final String title;
  final bool isDestructive;

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;

    return Text(
      title.toUpperCase(),
      style: textTheme.labelMedium?.copyWith(fontWeight: FontWeight.bold, color: isDestructive ? Colors.red : null),
    );
  }
}

class _SettingsTile extends StatelessWidget {
  const _SettingsTile({
    required this.icon,
    required this.title,
    this.subtitle,
    required this.onTap,
    this.isDestructive = false,
  });

  final IconData icon;
  final String title;
  final String? subtitle;
  final VoidCallback onTap;
  final bool isDestructive;

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    return ListTile(
      leading: Icon(icon, color: isDestructive ? Colors.red : colors.primary),
      title: Text(title, style: textTheme.bodyLarge?.copyWith(color: isDestructive ? Colors.red : null)),
      subtitle: subtitle != null ? Text(subtitle!, style: textTheme.bodySmall) : null,
      trailing: const Icon(Icons.chevron_right),
      onTap: onTap,
    );
  }
}

class _SettingsSwitchTile extends StatelessWidget {
  const _SettingsSwitchTile({
    required this.icon,
    required this.title,
    this.subtitle,
    required this.value,
    required this.onChanged,
    this.isDestructive = false,
  });

  final IconData icon;
  final String title;
  final String? subtitle;
  final bool value;
  final ValueChanged<bool> onChanged;
  final bool isDestructive;

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    return SwitchListTile(
      secondary: Icon(icon, color: isDestructive && value ? Colors.red : colors.primary),
      title: Text(title, style: textTheme.bodyLarge?.copyWith(color: isDestructive && value ? Colors.red : null)),
      subtitle: subtitle != null ? Text(subtitle!, style: textTheme.bodySmall) : null,
      value: value,
      onChanged: onChanged,
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/conversation_list_item.dart
================================================================
import 'package:flutter/material.dart';
import 'package:chattrix_ui/core/widgets/user_avatar.dart';
import 'package:chattrix_ui/core/domain/enums/enums.dart';
import 'package:chattrix_ui/features/auth/domain/entities/user.dart';
import 'package:chattrix_ui/features/chat/domain/entities/conversation.dart';
import 'package:chattrix_ui/features/chat/presentation/utils/conversation_utils.dart';
class ConversationListItem extends StatelessWidget {
  final Conversation conversation;
  final User? currentUser;
  final VoidCallback onTap;
  final bool isTyping;

  const ConversationListItem({
    super.key,
    required this.conversation,
    required this.currentUser,
    required this.onTap,
    this.isTyping = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final title = ConversationUtils.getConversationTitle(conversation, currentUser);
    final lastMessagePreview = _getLastMessagePreview();
    final timestamp = _getTimestamp();
    final isOnline =
        conversation.type == ConversationType.direct && ConversationUtils.isUserOnline(conversation, currentUser);
    final semanticLabel = _buildSemanticLabel(title, lastMessagePreview, timestamp, isOnline);

    return Semantics(
      label: semanticLabel,
      button: true,
      enabled: true,
      child: InkWell(
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Row(
            children: [
              Stack(
                children: [
                  _buildAvatar(title),
                  if (isOnline)
                    Positioned(
                      bottom: 0,
                      right: 0,
                      child: Container(
                        width: 14,
                        height: 14,
                        decoration: BoxDecoration(
                          color: const Color(0xFF31A24C),
                          shape: BoxShape.circle,
                          border: Border.all(color: theme.scaffoldBackgroundColor, width: 2),
                        ),
                      ),
                    ),
                ],
              ),

              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            title,
                            style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w700),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),

                        const SizedBox(width: 8),
                        Text(
                          timestamp,
                          style: TextStyle(fontSize: 12, color: isDark ? Colors.grey[400] : Colors.grey[600]),
                        ),
                      ],
                    ),

                    const SizedBox(height: 4),
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            lastMessagePreview,
                            style: TextStyle(
                              fontSize: 14,
                              color: isDark ? Colors.grey[400] : Colors.grey[600],
                              fontStyle: isTyping ? FontStyle.italic : FontStyle.normal,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        if (conversation.unreadCount > 0) ...[
                          const SizedBox(width: 8),
                          Container(
                            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                            decoration: BoxDecoration(
                              color: theme.colorScheme.primary,
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: Text(
                              conversation.unreadCount > 99 ? '99+' : conversation.unreadCount.toString(),
                              style: const TextStyle(fontSize: 12, color: Colors.white, fontWeight: FontWeight.w600),
                            ),
                          ),
                        ],
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  Widget _buildAvatar(String title) {
    if (conversation.type == ConversationType.direct) {
      final otherParticipant = ConversationUtils.getOtherParticipant(conversation, currentUser);

      return UserAvatar(avatarUrl: otherParticipant?.avatarUrl, displayName: title, radius: 24);
    } else {
      return UserAvatar(avatarUrl: conversation.avatarUrl, displayName: title, radius: 24);
    }
  }
  String _getLastMessagePreview() {
    if (isTyping) {
      return 'ƒêang so·∫°n tin...';
    }
    if (conversation.lastMessage == null) {
      return 'No messages yet';
    }

    final lastMessage = conversation.lastMessage!;
    String content;
    switch (lastMessage.type.toUpperCase()) {
      case 'IMAGE':
        content = 'üì∑ Photo';
        break;
      case 'VIDEO':
        content = 'üé• Video';
        break;
      case 'AUDIO':
        content = 'üéµ Audio';
        break;
      case 'FILE':
        content = 'üìé File';
        break;
      case 'LOCATION':
        content = 'üìç Location';
        break;
      default:
        content = lastMessage.content;
    }
    if (conversation.type == ConversationType.group) {
      final senderName = _getSenderName(lastMessage);
      if (senderName != null) {
        return '$senderName: $content';
      }
    }
    if (currentUser != null && lastMessage.senderId == currentUser!.id) {
      return 'You: $content';
    }

    return content;
  }
  String? _getSenderName(dynamic lastMessage) {
    if (currentUser != null && lastMessage.senderId == currentUser!.id) {
      return 'You';
    }
    if (lastMessage.senderFullName != null && lastMessage.senderFullName!.isNotEmpty) {
      final parts = lastMessage.senderFullName!.split(' ');
      return parts.first;
    }

    if (lastMessage.senderUsername != null && lastMessage.senderUsername!.isNotEmpty) {
      return lastMessage.senderUsername;
    }

    return null;
  }
  String _getTimestamp() {
    if (conversation.lastMessage == null) {
      return ConversationUtils.formatTimeAgo(conversation.updatedAt);
    }

    return ConversationUtils.formatTimeAgo(conversation.lastMessage!.createdAt);
  }
  String _buildSemanticLabel(String title, String lastMessage, String timestamp, bool isOnline) {
    final buffer = StringBuffer();
    buffer.write('Conversation with $title. ');
    if (conversation.type == ConversationType.direct) {
      buffer.write(isOnline ? 'Online. ' : 'Offline. ');
    }
    if (isTyping) {
      buffer.write('Typing. ');
    } else {
      buffer.write('Last message: $lastMessage. ');
    }
    buffer.write('$timestamp. ');
    if (conversation.unreadCount > 0) {
      buffer.write('${conversation.unreadCount} unread ${conversation.unreadCount == 1 ? 'message' : 'messages'}. ');
    }

    buffer.write('Double tap to open.');

    return buffer.toString();
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/edit_message_dialog.dart
================================================================
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
class EditMessageDialog extends HookWidget {
  const EditMessageDialog({super.key, required this.initialContent});

  final String initialContent;

  @override
  Widget build(BuildContext context) {
    final controller = useTextEditingController(text: initialContent);

    return AlertDialog(
      title: const Text('Edit Message'),
      content: TextField(
        controller: controller,
        autofocus: true,
        maxLines: null,
        keyboardType: TextInputType.multiline,
        decoration: const InputDecoration(hintText: 'Enter message', border: OutlineInputBorder()),
      ),
      actions: [
        TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text('Cancel')),
        FilledButton(
          onPressed: () {
            final newContent = controller.text.trim();
            if (newContent.isNotEmpty && newContent != initialContent) {
              Navigator.of(context).pop(newContent);
            } else {
              Navigator.of(context).pop();
            }
          },
          child: const Text('Save'),
        ),
      ],
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/filter_chip_widget.dart
================================================================
import 'package:flutter/material.dart';
class FilterChipWidget extends StatelessWidget {
  final String label;
  final bool isSelected;
  final VoidCallback onTap;

  const FilterChipWidget({super.key, required this.label, required this.isSelected, required this.onTap});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final semanticLabel = isSelected ? '$label filter selected' : '$label filter. Double tap to select.';

    return Semantics(
      label: semanticLabel,
      button: true,
      enabled: true,
      selected: isSelected,
      child: GestureDetector(
        onTap: onTap,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          curve: Curves.easeInOut,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          decoration: BoxDecoration(
            color: isSelected
                ? theme.colorScheme.primary
                : (isDark ? const Color(0xFF2C2C2E) : const Color(0xFFF3F4F6)),
            borderRadius: BorderRadius.circular(20),
          ),
          child: AnimatedDefaultTextStyle(
            duration: const Duration(milliseconds: 200),
            curve: Curves.easeInOut,
            style: TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w600,
              color: isSelected ? Colors.white : (isDark ? Colors.white : Colors.black87),
            ),
            child: Text(label),
          ),
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/lazy_media_loader.dart
================================================================
import 'package:flutter/material.dart';
import 'package:visibility_detector/visibility_detector.dart';
class LazyMediaLoader extends StatefulWidget {
  const LazyMediaLoader({super.key, required this.child, required this.placeholder, this.visibilityThreshold = 0.1});
  final Widget child;
  final Widget placeholder;
  final double visibilityThreshold;

  @override
  State<LazyMediaLoader> createState() => _LazyMediaLoaderState();
}

class _LazyMediaLoaderState extends State<LazyMediaLoader> {
  bool _isVisible = false;
  bool _hasBeenVisible = false;

  void _onVisibilityChanged(VisibilityInfo info) {
    if (!_hasBeenVisible && info.visibleFraction >= widget.visibilityThreshold) {
      setState(() {
        _isVisible = true;
        _hasBeenVisible = true;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return VisibilityDetector(
      key: widget.key ?? UniqueKey(),
      onVisibilityChanged: _onVisibilityChanged,
      child: _isVisible ? widget.child : widget.placeholder,
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/mention_text_field.dart
================================================================
import 'package:chattrix_ui/core/widgets/user_avatar.dart';
import 'package:flutter/material.dart';
import 'package:flutter/gestures.dart';

class MentionableUser {
  final int id;
  final String name;
  final String? avatarUrl;

  const MentionableUser({required this.id, required this.name, this.avatarUrl});
}

class MentionTextField extends StatefulWidget {
  const MentionTextField({
    super.key,
    required this.controller,
    required this.users,
    this.onMentionAdded,
    this.focusNode,
    this.decoration,
    this.maxLines,
    this.minLines,
    this.textInputAction,
    this.onSubmitted,
  });

  final TextEditingController controller;
  final List<MentionableUser> users;
  final Function(MentionableUser user)? onMentionAdded;
  final FocusNode? focusNode;
  final InputDecoration? decoration;
  final int? maxLines;
  final int? minLines;
  final TextInputAction? textInputAction;
  final Function(String)? onSubmitted;

  @override
  State<MentionTextField> createState() => _MentionTextFieldState();
}

class _MentionTextFieldState extends State<MentionTextField> {
  final LayerLink _layerLink = LayerLink();
  OverlayEntry? _overlayEntry;
  List<MentionableUser> _filteredUsers = [];
  int _mentionStartPosition = -1;

  @override
  void initState() {
    super.initState();
    widget.controller.addListener(_onTextChanged);
  }

  @override
  void dispose() {
    widget.controller.removeListener(_onTextChanged);
    _removeOverlay();
    super.dispose();
  }

  void _onTextChanged() {
    final text = widget.controller.text;
    final cursorPosition = widget.controller.selection.baseOffset;

    if (cursorPosition > 0) {

      int atPosition = -1;
      for (int i = cursorPosition - 1; i >= 0; i--) {
        if (text[i] == '@') {
          atPosition = i;
          break;
        }
        if (text[i] == ' ' || text[i] == '\n') {
          break;
        }
      }

      if (atPosition != -1) {

        final query = text.substring(atPosition + 1, cursorPosition);
        _mentionStartPosition = atPosition;
        _filterUsers(query);
        return;
      }
    }

    _removeOverlay();
  }

  void _filterUsers(String query) {
    final filtered = widget.users.where((user) {
      return user.name.toLowerCase().contains(query.toLowerCase());
    }).toList();

    if (filtered.isEmpty) {
      _removeOverlay();
      return;
    }

    setState(() {
      _filteredUsers = filtered;
    });

    if (_overlayEntry == null) {
      _showOverlay();
    } else {
      _overlayEntry!.markNeedsBuild();
    }
  }

  void _showOverlay() {
    _overlayEntry = OverlayEntry(
      builder: (context) => Positioned(
        width: MediaQuery.of(context).size.width - 32,
        child: CompositedTransformFollower(
          link: _layerLink,
          showWhenUnlinked: false,
          offset: const Offset(0, -200), // Show above the text field
          child: Material(
            elevation: 4,
            borderRadius: BorderRadius.circular(8),
            child: Container(
              constraints: const BoxConstraints(maxHeight: 200),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.surface,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Theme.of(context).colorScheme.outlineVariant),
              ),
              child: ListView.builder(
                padding: EdgeInsets.zero,
                shrinkWrap: true,
                itemCount: _filteredUsers.length,
                itemBuilder: (context, index) {
                  final user = _filteredUsers[index];
                  return ListTile(
                    dense: true,
                    leading: UserAvatar(displayName: user.name, avatarUrl: user.avatarUrl, radius: 16),
                    title: Text(user.name, style: Theme.of(context).textTheme.bodyMedium),
                    onTap: () => _insertMention(user),
                  );
                },
              ),
            ),
          ),
        ),
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  void _removeOverlay() {
    _overlayEntry?.remove();
    _overlayEntry = null;
    _filteredUsers = [];
    _mentionStartPosition = -1;
  }

  void _insertMention(MentionableUser user) {
    final text = widget.controller.text;
    final cursorPosition = widget.controller.selection.baseOffset;

    final newText = '${text.substring(0, _mentionStartPosition)}@${user.name} ${text.substring(cursorPosition)}';

    widget.controller.text = newText;
    widget.controller.selection = TextSelection.collapsed(offset: _mentionStartPosition + user.name.length + 2);

    widget.onMentionAdded?.call(user);
    _removeOverlay();
  }

  @override
  Widget build(BuildContext context) {
    return CompositedTransformTarget(
      link: _layerLink,
      child: TextField(
        controller: widget.controller,
        focusNode: widget.focusNode,
        decoration: widget.decoration,
        maxLines: widget.maxLines,
        minLines: widget.minLines,
        textInputAction: widget.textInputAction,
        onSubmitted: widget.onSubmitted,
      ),
    );
  }
}

class MentionText extends StatelessWidget {
  const MentionText({
    super.key,
    required this.text,
    this.style,
    this.mentionStyle,
    this.onMentionTap,
    this.maxLines,
    this.overflow,
  });

  final String text;
  final TextStyle? style;
  final TextStyle? mentionStyle;
  final Function(String username)? onMentionTap;
  final int? maxLines;
  final TextOverflow? overflow;

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    final defaultMentionStyle = TextStyle(color: colors.primary, fontWeight: FontWeight.w600);

    final spans = <InlineSpan>[];
    final regex = RegExp(r'@(\w+)');
    int lastMatchEnd = 0;

    for (final match in regex.allMatches(text)) {

      if (match.start > lastMatchEnd) {
        spans.add(TextSpan(text: text.substring(lastMatchEnd, match.start), style: style));
      }

      final username = match.group(1)!;
      spans.add(
        TextSpan(
          text: '@$username',
          style: mentionStyle ?? defaultMentionStyle,
          recognizer: onMentionTap != null ? (TapGestureRecognizer()..onTap = () => onMentionTap!(username)) : null,
        ),
      );

      lastMatchEnd = match.end;
    }

    if (lastMatchEnd < text.length) {
      spans.add(TextSpan(text: text.substring(lastMatchEnd), style: style));
    }

    return Text.rich(
      TextSpan(children: spans),
      maxLines: maxLines,
      overflow: overflow,
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/message_action_overlay.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:flutter/material.dart';

class MessageActionOverlay extends StatefulWidget {
  const MessageActionOverlay({
    super.key,
    required this.message,
    required this.isMe,
    required this.messageWidget,
    required this.messagePosition,
    required this.onReply,
    required this.onReaction,
    this.onEdit,
    this.onDelete,
    this.onCopy,
  });

  final Message message;
  final bool isMe;
  final Widget messageWidget;
  final Offset messagePosition;
  final VoidCallback? onReply;
  final Function(String emoji) onReaction;
  final VoidCallback? onEdit;
  final VoidCallback? onDelete;
  final VoidCallback? onCopy;

  @override
  State<MessageActionOverlay> createState() => _MessageActionOverlayState();
}

class _MessageActionOverlayState extends State<MessageActionOverlay> with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _fadeAnimation;
  late Animation<double> _scaleAnimation;

  static const List<String> _quickEmojis = ['‚ù§Ô∏è', 'üëç', 'üòÇ', 'üòÆ', 'üò¢', 'üôè'];

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(duration: const Duration(milliseconds: 250), vsync: this);

    _fadeAnimation = CurvedAnimation(parent: _controller, curve: Curves.easeOut);

    _scaleAnimation = Tween<double>(
      begin: 0.8,
      end: 1.0,
    ).animate(CurvedAnimation(parent: _controller, curve: Curves.easeOutBack));

    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _close() {
    _controller.reverse().then((_) {
      if (mounted) {
        Navigator.of(context).pop();
      }
    });
  }

  void _handleEmojiTap(String emoji) {
    debugPrint('üéØ [MessageActionOverlay] Emoji tapped: $emoji');
    widget.onReaction(emoji);
    _close();
  }

  void _handleAction(VoidCallback? action, String actionName) async {
    debugPrint('üéØ [MessageActionOverlay] Action tapped: $actionName');
    if (action != null) {
      debugPrint('‚úÖ [MessageActionOverlay] Executing $actionName action');

      await _controller.reverse();
      if (mounted) {
        Navigator.of(context).pop();
      }

      await Future.delayed(const Duration(milliseconds: 100));
      action();
    } else {
      debugPrint('‚ùå [MessageActionOverlay] $actionName action is null!');
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colors = theme.colorScheme;

    return Material(
      type: MaterialType.transparency,
      child: GestureDetector(
        onTap: _close,
        child: Stack(
          children: [

            Container(color: Colors.black.withValues(alpha: 0.5)),

            FadeTransition(
              opacity: _fadeAnimation,
              child: Center(
                child: SingleChildScrollView(
                  child: Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 40),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      crossAxisAlignment: widget.isMe ? CrossAxisAlignment.end : CrossAxisAlignment.start,
                      children: [

                        ScaleTransition(
                          scale: _scaleAnimation,
                          child: Container(
                            margin: const EdgeInsets.only(bottom: 8),
                            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                            decoration: BoxDecoration(
                              color: colors.surface,
                              borderRadius: BorderRadius.circular(24),
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.black.withValues(alpha: 0.2),
                                  blurRadius: 8,
                                  offset: const Offset(0, 2),
                                ),
                              ],
                            ),
                            child: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: _quickEmojis.map((emoji) {
                                return InkWell(
                                  onTap: () => _handleEmojiTap(emoji),
                                  borderRadius: BorderRadius.circular(20),
                                  child: Container(
                                    margin: const EdgeInsets.symmetric(horizontal: 4),
                                    padding: const EdgeInsets.all(8),
                                    decoration: BoxDecoration(
                                      color: colors.surfaceContainerHighest,
                                      shape: BoxShape.circle,
                                    ),
                                    child: Text(
                                      emoji,
                                      style: TextStyle(
                                        fontSize: 24,
                                        fontFamily: 'NotoColorEmoji',
                                        color: Colors.transparent,
                                        shadows: [Shadow(offset: Offset.zero, blurRadius: 0, color: Color(0xFF000000))],
                                      ),
                                    ),
                                  ),
                                );
                              }).toList(),
                            ),
                          ),
                        ),

                        Container(
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(16),
                            boxShadow: [
                              BoxShadow(color: colors.primary.withValues(alpha: 0.3), blurRadius: 12, spreadRadius: 2),
                            ],
                          ),
                          child: widget.messageWidget,
                        ),

                        const SizedBox(height: 8),

                        ScaleTransition(
                          scale: _scaleAnimation,
                          child: Container(
                            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
                            decoration: BoxDecoration(
                              color: colors.surface,
                              borderRadius: BorderRadius.circular(16),
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.black.withValues(alpha: 0.2),
                                  blurRadius: 8,
                                  offset: const Offset(0, 2),
                                ),
                              ],
                            ),
                            child: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [

                                if (widget.onReply != null)
                                  _ActionButton(
                                    icon: Icons.reply,
                                    label: 'Reply',
                                    onTap: () => _handleAction(widget.onReply, 'Reply'),
                                  ),

                                if (widget.onCopy != null)
                                  _ActionButton(
                                    icon: Icons.copy,
                                    label: 'Copy',
                                    onTap: () => _handleAction(widget.onCopy, 'Copy'),
                                  ),

                                if (widget.isMe && widget.onEdit != null && widget.message.type == 'TEXT')
                                  _ActionButton(
                                    icon: Icons.edit,
                                    label: 'Edit',
                                    onTap: () => _handleAction(widget.onEdit, 'Edit'),
                                  ),

                                if (widget.isMe && widget.onDelete != null)
                                  _ActionButton(
                                    icon: Icons.delete,
                                    label: 'Delete',
                                    color: Colors.red,
                                    onTap: () => _handleAction(widget.onDelete, 'Delete'),
                                  ),
                              ],
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _ActionButton extends StatelessWidget {
  const _ActionButton({required this.icon, required this.label, required this.onTap, this.color});

  final IconData icon;
  final String label;
  final VoidCallback onTap;
  final Color? color;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colors = theme.colorScheme;
    final isDark = theme.brightness == Brightness.dark;

    final buttonColor = color ?? (isDark ? colors.onSurface : colors.onSurface);

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        margin: const EdgeInsets.symmetric(horizontal: 4),
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 22, color: buttonColor),
            const SizedBox(height: 4),
            Text(
              label,
              style: TextStyle(fontSize: 12, color: buttonColor, fontWeight: FontWeight.w500),
            ),
          ],
        ),
      ),
    );
  }
}

Future<void> showMessageActionOverlay({
  required BuildContext context,
  required Message message,
  required bool isMe,
  required Widget messageWidget,
  required Offset messagePosition,
  required VoidCallback? onReply,
  required Function(String emoji) onReaction,
  VoidCallback? onEdit,
  VoidCallback? onDelete,
  VoidCallback? onCopy,
}) {
  return Navigator.of(context).push(
    PageRouteBuilder(
      opaque: false,
      barrierDismissible: true,
      barrierColor: Colors.transparent,
      pageBuilder: (context, animation, secondaryAnimation) {
        return MessageActionOverlay(
          message: message,
          isMe: isMe,
          messageWidget: messageWidget,
          messagePosition: messagePosition,
          onReply: onReply,
          onReaction: onReaction,
          onEdit: onEdit,
          onDelete: onDelete,
          onCopy: onCopy,
        );
      },
    ),
  );
}

================================================================
FILE: lib/features/chat/presentation/widgets/message_bubble.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_bubbles/audio_message_bubble.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_bubbles/document_message_bubble.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_bubbles/image_message_bubble.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_bubbles/location_message_bubble.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_bubbles/text_message_bubble.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_bubbles/video_message_bubble.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_long_press_overlay.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_reactions.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/reply_message_preview.dart';
import 'package:flutter/material.dart';
class MessageBubble extends StatelessWidget {
  const MessageBubble({
    super.key,
    required this.message,
    required this.isMe,
    this.onReply,
    this.onReactionTap,
    this.onAddReaction,
    this.currentUserId,
    this.replyToMessage,
    this.onEdit,
    this.onDelete,
  });

  final Message message;
  final bool isMe;
  final VoidCallback? onReply;
  final Function(String emoji)? onReactionTap;
  final VoidCallback? onAddReaction;
  final int? currentUserId;
  final Message? replyToMessage;
  final VoidCallback? onEdit;
  final VoidCallback? onDelete;

  @override
  Widget build(BuildContext context) {
    final messageType = message.type.toUpperCase();
    return RepaintBoundary(
      child: switch (messageType) {
        'IMAGE' => ImageMessageBubble(
          message: message,
          isMe: isMe,
          onReply: onReply,
          onReactionTap: onReactionTap,
          onAddReaction: onAddReaction,
          currentUserId: currentUserId,
          replyToMessage: replyToMessage,
          onEdit: onEdit,
          onDelete: onDelete,
        ),
        'VIDEO' => VideoMessageBubble(
          message: message,
          isMe: isMe,
          onReply: onReply,
          onReactionTap: onReactionTap,
          onAddReaction: onAddReaction,
          currentUserId: currentUserId,
          replyToMessage: replyToMessage,
          onEdit: onEdit,
          onDelete: onDelete,
        ),
        'AUDIO' || 'VOICE' => AudioMessageBubble(
          message: message,
          isMe: isMe,
          onReply: onReply,
          onReactionTap: onReactionTap,
          onAddReaction: onAddReaction,
          currentUserId: currentUserId,
          replyToMessage: replyToMessage,
          onEdit: onEdit,
          onDelete: onDelete,
        ),
        'DOCUMENT' || 'FILE' => DocumentMessageBubble(
          message: message,
          isMe: isMe,
          onReply: onReply,
          onReactionTap: onReactionTap,
          onAddReaction: onAddReaction,
          currentUserId: currentUserId,
          replyToMessage: replyToMessage,
          onEdit: onEdit,
          onDelete: onDelete,
        ),
        'LOCATION' => LocationMessageBubble(
          message: message,
          isMe: isMe,
          onReply: onReply,
          onReactionTap: onReactionTap,
          onAddReaction: onAddReaction,
          currentUserId: currentUserId,
          replyToMessage: replyToMessage,
          onEdit: onEdit,
          onDelete: onDelete,
        ),
        _ => TextMessageBubble(
          message: message,
          isMe: isMe,
          onReply: onReply,
          onReactionTap: onReactionTap,
          onAddReaction: onAddReaction,
          currentUserId: currentUserId,
          replyToMessage: replyToMessage,
          onEdit: onEdit,
          onDelete: onDelete,
        ),
      },
    );
  }
}
class BaseBubbleContainer extends StatefulWidget {
  const BaseBubbleContainer({
    super.key,
    required this.isMe,
    required this.child,
    this.maxWidth = 280,
    this.message,
    this.onReply,
    this.onReactionTap,
    this.onAddReaction,
    this.currentUserId,
    this.replyToMessage,
    this.onEdit,
    this.onDelete,
  });

  final bool isMe;
  final Widget child;
  final double maxWidth;
  final Message? message;
  final VoidCallback? onReply;
  final Function(String emoji)? onReactionTap;
  final VoidCallback? onAddReaction;
  final int? currentUserId;
  final Message? replyToMessage;
  final VoidCallback? onEdit;
  final VoidCallback? onDelete;

  @override
  State<BaseBubbleContainer> createState() => _BaseBubbleContainerState();
}

class _BaseBubbleContainerState extends State<BaseBubbleContainer> with AutomaticKeepAliveClientMixin {
  final GlobalKey _messageKey = GlobalKey();
  double _dragDistance = 0;
  double _initialDragDirection = 0;
  bool _isDragging = false;
  static final _greyLight = Colors.grey.shade200;
  static final _greyBorder = Colors.grey.shade300;

  @override
  bool get wantKeepAlive => true;

  void _handleQuickReaction(String emoji) {
    if (widget.onReactionTap != null) {
      widget.onReactionTap!(emoji);
    }
  }

  void _handleSwipeReply() {
    if (widget.onReply != null) {
      widget.onReply!();
    }
  }

  @override
  Widget build(BuildContext context) {
    super.build(context); // Required for AutomaticKeepAliveClientMixin

    final theme = Theme.of(context);
    final colors = theme.colorScheme;
    final isDark = theme.brightness == Brightness.dark;

    final bg = widget.isMe ? (isDark ? colors.primary : _greyLight) : (isDark ? colors.surface : Colors.black);

    return Container(
      key: _messageKey,
      margin: EdgeInsets.only(left: widget.isMe ? 48 : 8, right: widget.isMe ? 8 : 48, top: 6, bottom: 6),
      constraints: BoxConstraints(maxWidth: widget.maxWidth),
      child: GestureDetector(
        onDoubleTap: () {
          if (widget.onReactionTap != null) {
            widget.onReactionTap!('‚ù§Ô∏è');
          }
        },
        onHorizontalDragStart: (details) {
          if (widget.onReply == null) return;
          setState(() {
            _isDragging = true;
            _initialDragDirection = 0;
          });
        },
        onHorizontalDragUpdate: (details) {
          if (widget.onReply == null || !_isDragging) return;

          setState(() {
            if (_initialDragDirection == 0 && details.delta.dx.abs() > 2) {
              _initialDragDirection = details.delta.dx > 0 ? 1 : -1;
            }
            final currentDirection = details.delta.dx > 0 ? 1 : -1;
            if (_initialDragDirection != 0 && currentDirection == _initialDragDirection) {
              _dragDistance += details.delta.dx;
              _dragDistance = _dragDistance.clamp(-100.0, 100.0);
            } else if (_initialDragDirection != 0 && currentDirection != _initialDragDirection) {
              _dragDistance += details.delta.dx * 1.5;
              if ((_initialDragDirection > 0 && _dragDistance < 0) ||
                  (_initialDragDirection < 0 && _dragDistance > 0)) {
                _dragDistance = 0;
                _initialDragDirection = 0;
              }
            }
          });
        },
        onHorizontalDragEnd: (details) {
          if (widget.onReply == null) return;
          if (_dragDistance.abs() > 50 &&
              ((_initialDragDirection > 0 && _dragDistance > 0) || (_initialDragDirection < 0 && _dragDistance < 0))) {
            _handleSwipeReply();
          }

          setState(() {
            _dragDistance = 0;
            _initialDragDirection = 0;
            _isDragging = false;
          });
        },
        onLongPress: () {
          if (widget.onReply == null &&
              widget.onAddReaction == null &&
              widget.onEdit == null &&
              widget.onDelete == null) {
            return;
          }

          showMessageLongPressOverlay(
            context: context,
            messageKey: _messageKey,
            isMe: widget.isMe,
            onReply: widget.onReply,
            onAddReaction: widget.onAddReaction,
            onEdit: widget.onEdit,
            onDelete: widget.onDelete,
            onQuickReaction: _handleQuickReaction,
            canEdit: widget.message?.type == 'TEXT',
          );
        },
        child: Stack(
          children: [
            if (_dragDistance.abs() > 10)
              Positioned(
                left: widget.isMe ? null : 0,
                right: widget.isMe ? 0 : null,
                top: 0,
                bottom: 0,
                child: Center(
                  child: Opacity(
                    opacity: (_dragDistance.abs() / 50).clamp(0.0, 1.0),
                    child: Icon(Icons.reply, color: colors.primary, size: 24),
                  ),
                ),
              ),
            Transform.translate(
              offset: Offset(_dragDistance * 0.5, 0),
              child: Column(
                crossAxisAlignment: widget.isMe ? CrossAxisAlignment.end : CrossAxisAlignment.start,
                children: [
                  Container(
                    decoration: BoxDecoration(
                      color: bg,
                      borderRadius: BorderRadius.only(
                        topLeft: const Radius.circular(16),
                        topRight: const Radius.circular(16),
                        bottomLeft: Radius.circular(widget.isMe ? 16 : 4),
                        bottomRight: Radius.circular(widget.isMe ? 4 : 16),
                      ),
                      border: widget.isMe ? Border.all(color: _greyBorder) : null,
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        if (widget.replyToMessage != null)
                          Padding(
                            padding: const EdgeInsets.fromLTRB(12, 8, 12, 0),
                            child: QuotedMessageWidget(replyToMessage: widget.replyToMessage!, onTap: null),
                          ),
                        widget.child,
                      ],
                    ),
                  ),
                  if (widget.message != null && widget.currentUserId != null)
                    MessageReactions(
                      reactions: widget.message!.reactions,
                      currentUserId: widget.currentUserId!,
                      onReactionTap: widget.onReactionTap ?? (_) {},
                      onAddReaction: widget.onAddReaction ?? () {},
                    ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/message_bubbles/audio_message_bubble.dart
================================================================
import 'package:audioplayers/audioplayers.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/presentation/utils/format_utils.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_bubble.dart';
import 'package:flutter/material.dart';

class AudioMessageBubble extends StatefulWidget {
  const AudioMessageBubble({
    super.key,
    required this.message,
    required this.isMe,
    this.onReply,
    this.onReactionTap,
    this.onAddReaction,
    this.currentUserId,
    this.replyToMessage,
    this.onEdit,
    this.onDelete,
  });

  final Message message;
  final bool isMe;
  final VoidCallback? onReply;
  final Function(String emoji)? onReactionTap;
  final VoidCallback? onAddReaction;
  final int? currentUserId;
  final Message? replyToMessage;
  final VoidCallback? onEdit;
  final VoidCallback? onDelete;

  @override
  State<AudioMessageBubble> createState() => _AudioMessageBubbleState();
}

class _AudioMessageBubbleState extends State<AudioMessageBubble> with AutomaticKeepAliveClientMixin {
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isPlaying = false;
  Duration _currentPosition = Duration.zero;
  Duration _totalDuration = Duration.zero;

  @override
  bool get wantKeepAlive => true; // Keep audio player state when scrolling

  @override
  void initState() {
    super.initState();
    _initializeAudio();
  }

  Future<void> _initializeAudio() async {
    if (widget.message.mediaUrl == null) return;

    try {

      _audioPlayer.onPlayerStateChanged.listen((state) {
        if (mounted) {
          setState(() {
            _isPlaying = state == PlayerState.playing;
          });
        }
      });

      _audioPlayer.onPositionChanged.listen((position) {
        if (mounted) {
          setState(() {
            _currentPosition = position;
          });
        }
      });

      _audioPlayer.onDurationChanged.listen((duration) {
        if (mounted) {
          setState(() {
            _totalDuration = duration;
          });
        }
      });

      _audioPlayer.onPlayerComplete.listen((_) {
        if (mounted) {
          setState(() {
            _isPlaying = false;
            _currentPosition = Duration.zero;
          });
        }
      });
    } catch (e) {
      debugPrint('‚ùå Failed to initialize audio: $e');
    }
  }

  @override
  void dispose() {
    _audioPlayer.dispose();
    super.dispose();
  }

  Future<void> _togglePlayPause() async {
    if (widget.message.mediaUrl == null) return;

    try {
      if (_isPlaying) {
        await _audioPlayer.pause();
      } else {
        if (_currentPosition == Duration.zero) {
          await _audioPlayer.play(UrlSource(widget.message.mediaUrl!));
        } else {
          await _audioPlayer.resume();
        }
      }
    } catch (e) {
      debugPrint('‚ùå Failed to play/pause audio: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed to play audio: $e')));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    super.build(context); // Required for AutomaticKeepAliveClientMixin

    final textColor = FormatUtils.getTextColor(context, widget.isMe);
    final textTheme = Theme.of(context).textTheme;

    final displayDuration = _totalDuration.inSeconds > 0
        ? _totalDuration
        : (widget.message.duration != null ? Duration(seconds: widget.message.duration!) : Duration.zero);

    return BaseBubbleContainer(
      isMe: widget.isMe,
      message: widget.message,
      onReply: widget.onReply,
      onReactionTap: widget.onReactionTap,
      onAddReaction: widget.onAddReaction,
      currentUserId: widget.currentUserId,
      replyToMessage: widget.replyToMessage,
      onEdit: widget.onEdit,
      onDelete: widget.onDelete,
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [

            GestureDetector(
              onTap: _togglePlayPause,
              child: Container(
                width: 40,
                height: 40,
                decoration: BoxDecoration(color: textColor.withValues(alpha: 0.2), shape: BoxShape.circle),
                child: Icon(_isPlaying ? Icons.pause : Icons.play_arrow, color: textColor, size: 24),
              ),
            ),
            const SizedBox(width: 12),

            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [

                  Row(
                    children: List.generate(20, (index) {

                      final progress = displayDuration.inSeconds > 0
                          ? _currentPosition.inSeconds / displayDuration.inSeconds
                          : 0.0;
                      final isActive = (index / 20) <= progress;

                      return Expanded(
                        child: Container(
                          margin: const EdgeInsets.symmetric(horizontal: 1),
                          height: (index % 3 + 1) * 8.0,
                          decoration: BoxDecoration(
                            color: textColor.withValues(alpha: isActive ? 0.8 : 0.3),
                            borderRadius: BorderRadius.circular(2),
                          ),
                        ),
                      );
                    }),
                  ),
                  const SizedBox(height: 4),

                  Text(
                    _isPlaying
                        ? '${FormatUtils.formatDuration(_currentPosition.inSeconds)} / ${FormatUtils.formatDuration(displayDuration.inSeconds)}'
                        : FormatUtils.formatDuration(displayDuration.inSeconds),
                    style: textTheme.bodySmall?.copyWith(color: textColor.withValues(alpha: 0.7)),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/message_bubbles/document_message_bubble.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/presentation/utils/format_utils.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_bubble.dart';
import 'package:flutter/material.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';
import 'package:url_launcher/url_launcher.dart';

class DocumentMessageBubble extends StatelessWidget {
  const DocumentMessageBubble({
    super.key,
    required this.message,
    required this.isMe,
    this.onReply,
    this.onReactionTap,
    this.onAddReaction,
    this.currentUserId,
    this.replyToMessage,
    this.onEdit,
    this.onDelete,
  });

  final Message message;
  final bool isMe;
  final VoidCallback? onReply;
  final Function(String emoji)? onReactionTap;
  final VoidCallback? onAddReaction;
  final int? currentUserId;
  final Message? replyToMessage;
  final VoidCallback? onEdit;
  final VoidCallback? onDelete;

  IconData _getFileIcon(String? fileName) {
    if (fileName == null) return FontAwesomeIcons.file;

    final ext = fileName.split('.').last.toLowerCase();
    switch (ext) {
      case 'pdf':
        return FontAwesomeIcons.filePdf;
      case 'doc':
      case 'docx':
        return FontAwesomeIcons.fileWord;
      case 'xls':
      case 'xlsx':
        return FontAwesomeIcons.fileExcel;
      case 'ppt':
      case 'pptx':
        return FontAwesomeIcons.filePowerpoint;
      case 'zip':
      case 'rar':
        return FontAwesomeIcons.fileZipper;
      default:
        return FontAwesomeIcons.file;
    }
  }

  Future<void> _openDocument(BuildContext context) async {
    if (message.mediaUrl == null) return;

    try {
      final uri = Uri.parse(message.mediaUrl!);
      if (await canLaunchUrl(uri)) {
        await launchUrl(uri, mode: LaunchMode.externalApplication);
      } else {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Cannot open document')));
        }
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed to open document: $e')));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final textColor = FormatUtils.getTextColor(context, isMe);
    final textTheme = Theme.of(context).textTheme;

    return BaseBubbleContainer(
      isMe: isMe,
      message: message,
      onReply: onReply,
      onReactionTap: onReactionTap,
      onAddReaction: onAddReaction,
      currentUserId: currentUserId,
      replyToMessage: replyToMessage,
      onEdit: onEdit,
      onDelete: onDelete,
      child: InkWell(
        onTap: () => _openDocument(context),
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [

              Container(
                width: 48,
                height: 48,
                decoration: BoxDecoration(
                  color: textColor.withValues(alpha: 0.2),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(_getFileIcon(message.fileName), color: textColor, size: 24),
              ),
              const SizedBox(width: 12),

              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [

                    Text(
                      message.fileName ?? 'Document',
                      style: textTheme.bodyMedium?.copyWith(color: textColor, fontWeight: FontWeight.w500),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 4),

                    if (message.fileSize != null)
                      Text(
                        FormatUtils.formatFileSize(message.fileSize!),
                        style: textTheme.bodySmall?.copyWith(color: textColor.withValues(alpha: 0.7)),
                      ),
                  ],
                ),
              ),

              Icon(Icons.download, color: textColor, size: 20),
            ],
          ),
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/message_bubbles/image_message_bubble.dart
================================================================
import 'package:cached_network_image/cached_network_image.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/presentation/utils/format_utils.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/lazy_media_loader.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_bubble.dart';
import 'package:flutter/material.dart';

class ImageMessageBubble extends StatelessWidget {
  const ImageMessageBubble({
    super.key,
    required this.message,
    required this.isMe,
    this.onReply,
    this.onReactionTap,
    this.onAddReaction,
    this.currentUserId,
    this.replyToMessage,
    this.onEdit,
    this.onDelete,
  });

  final Message message;
  final bool isMe;
  final VoidCallback? onReply;
  final Function(String emoji)? onReactionTap;
  final VoidCallback? onAddReaction;
  final int? currentUserId;
  final Message? replyToMessage;
  final VoidCallback? onEdit;
  final VoidCallback? onDelete;

  void _openFullScreenImage(BuildContext context) {
    if (message.mediaUrl == null) return;

    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => _FullScreenImageViewer(imageUrl: message.mediaUrl!, caption: message.content),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final textColor = FormatUtils.getTextColor(context, isMe);
    final textTheme = Theme.of(context).textTheme;

    return BaseBubbleContainer(
      isMe: isMe,
      maxWidth: 280,
      message: message,
      onReply: onReply,
      onReactionTap: onReactionTap,
      onAddReaction: onAddReaction,
      currentUserId: currentUserId,
      replyToMessage: replyToMessage,
      onEdit: onEdit,
      onDelete: onDelete,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [

          if (message.mediaUrl != null)
            LazyMediaLoader(
              key: ValueKey('image_${message.id}'),
              placeholder: Container(
                width: 280,
                height: 200,
                color: Colors.grey.shade300,
                child: const Center(child: Icon(Icons.image, size: 48, color: Colors.grey)),
              ),
              child: GestureDetector(
                onTap: () => _openFullScreenImage(context),
                child: ClipRRect(
                  borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
                  child: CachedNetworkImage(
                    imageUrl: message.mediaUrl!,
                    width: 280,
                    fit: BoxFit.cover,
                    placeholder: (context, url) => Container(
                      width: 280,
                      height: 200,
                      color: Colors.grey.shade300,
                      child: const Center(child: CircularProgressIndicator()),
                    ),
                    errorWidget: (context, url, error) {
                      return Container(
                        width: 280,
                        height: 200,
                        color: Colors.grey.shade300,
                        child: const Icon(Icons.broken_image, size: 48),
                      );
                    },

                    memCacheWidth: 560, // 2x for retina displays
                    maxWidthDiskCache: 560,
                    fadeInDuration: const Duration(milliseconds: 200),
                    fadeOutDuration: const Duration(milliseconds: 100),
                  ),
                ),
              ),
            ),

          if (message.content.isNotEmpty)
            Padding(
              padding: const EdgeInsets.all(12),
              child: Text(message.content, style: textTheme.bodyMedium?.copyWith(color: textColor)),
            ),
        ],
      ),
    );
  }
}

class _FullScreenImageViewer extends StatelessWidget {
  const _FullScreenImageViewer({required this.imageUrl, this.caption});

  final String imageUrl;
  final String? caption;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        backgroundColor: Colors.black,
        iconTheme: const IconThemeData(color: Colors.white),
        title: caption != null && caption!.isNotEmpty
            ? Text(caption!, style: const TextStyle(color: Colors.white))
            : null,
      ),
      body: InteractiveViewer(
        minScale: 0.5,
        maxScale: 4.0,
        child: Center(
          child: CachedNetworkImage(
            imageUrl: imageUrl,
            fit: BoxFit.contain,
            placeholder: (context, url) => const Center(child: CircularProgressIndicator(color: Colors.white)),
            errorWidget: (context, url, error) => const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.broken_image, size: 64, color: Colors.white),
                  SizedBox(height: 16),
                  Text('Failed to load image', style: TextStyle(color: Colors.white)),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/message_bubbles/location_message_bubble.dart
================================================================
import 'package:cached_network_image/cached_network_image.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/presentation/utils/format_utils.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_bubble.dart';
import 'package:flutter/material.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';
import 'package:url_launcher/url_launcher.dart';

class LocationMessageBubble extends StatelessWidget {
  const LocationMessageBubble({
    super.key,
    required this.message,
    required this.isMe,
    this.onReply,
    this.onReactionTap,
    this.onAddReaction,
    this.currentUserId,
    this.replyToMessage,
    this.onEdit,
    this.onDelete,
  });

  final Message message;
  final bool isMe;
  final VoidCallback? onReply;
  final Function(String emoji)? onReactionTap;
  final VoidCallback? onAddReaction;
  final int? currentUserId;
  final Message? replyToMessage;
  final VoidCallback? onEdit;
  final VoidCallback? onDelete;

  Future<void> _openInMaps() async {
    if (message.latitude == null || message.longitude == null) return;

    final lat = message.latitude!;
    final lng = message.longitude!;

    final googleMapsUrl = Uri.parse('https://www.google.com/maps/search/?api=1&query=$lat,$lng');

    try {
      if (await canLaunchUrl(googleMapsUrl)) {
        await launchUrl(googleMapsUrl, mode: LaunchMode.externalApplication);
      }
    } catch (e) {

    }
  }

  @override
  Widget build(BuildContext context) {
    final textColor = FormatUtils.getTextColor(context, isMe);
    final textTheme = Theme.of(context).textTheme;

    return GestureDetector(
      onTap: _openInMaps,
      child: BaseBubbleContainer(
        isMe: isMe,
        maxWidth: 280,
        message: message,
        onReply: onReply,
        onReactionTap: onReactionTap,
        onAddReaction: onAddReaction,
        currentUserId: currentUserId,
        replyToMessage: replyToMessage,
        onEdit: onEdit,
        onDelete: onDelete,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [

            ClipRRect(
              borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
              child: Stack(
                alignment: Alignment.center,
                children: [

                  if (message.latitude != null && message.longitude != null)
                    Builder(
                      builder: (context) {
                        final apiKey = dotenv.env['GOOGLE_MAPS_API_KEY'] ?? '';
                        final mapUrl =
                            'https://maps.googleapis.com/maps/api/staticmap?'
                            'center=${message.latitude},${message.longitude}'
                            '&zoom=15'
                            '&size=280x150'
                            '&markers=color:red%7C${message.latitude},${message.longitude}'
                            '&key=$apiKey';

                        return CachedNetworkImage(
                          imageUrl: mapUrl,
                          width: 280,
                          height: 150,
                          fit: BoxFit.cover,
                          memCacheWidth: 560,
                          maxWidthDiskCache: 560,
                          placeholder: (context, url) => Container(
                            width: 280,
                            height: 150,
                            color: Colors.grey.shade300,
                            child: const Center(child: CircularProgressIndicator()),
                          ),
                          errorWidget: (context, url, error) {
                            return Container(
                              width: 280,
                              height: 150,
                              color: Colors.grey.shade300,
                              child: Column(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  const Icon(FontAwesomeIcons.mapLocationDot, size: 48, color: Colors.red),
                                  const SizedBox(height: 8),
                                  Text('Map load failed', style: TextStyle(fontSize: 12, color: Colors.grey.shade600)),
                                ],
                              ),
                            );
                          },
                        );
                      },
                    )
                  else
                    Container(
                      width: 280,
                      height: 150,
                      color: Colors.grey.shade300,
                      child: const Icon(FontAwesomeIcons.mapLocationDot, size: 48, color: Colors.red),
                    ),

                  const Icon(FontAwesomeIcons.locationDot, color: Colors.red, size: 36),
                ],
              ),
            ),

            Padding(
              padding: const EdgeInsets.all(12),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [

                  if (message.locationName != null)
                    Text(
                      message.locationName!,
                      style: textTheme.bodyMedium?.copyWith(color: textColor, fontWeight: FontWeight.w500),
                    ),
                  const SizedBox(height: 4),

                  Text(
                    '${message.latitude?.toStringAsFixed(6)}, ${message.longitude?.toStringAsFixed(6)}',
                    style: textTheme.bodySmall?.copyWith(color: textColor.withValues(alpha: 0.7)),
                  ),
                  const SizedBox(height: 8),

                  Row(
                    children: [
                      Icon(FontAwesomeIcons.mapPin, size: 14, color: textColor),
                      const SizedBox(width: 6),
                      Text(
                        'View on map',
                        style: textTheme.bodySmall?.copyWith(color: textColor, fontWeight: FontWeight.w500),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/message_bubbles/text_message_bubble.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/presentation/utils/format_utils.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_bubble.dart';
import 'package:flutter/material.dart';

class TextMessageBubble extends StatelessWidget {
  const TextMessageBubble({
    super.key,
    required this.message,
    required this.isMe,
    this.onReply,
    this.onReactionTap,
    this.onAddReaction,
    this.currentUserId,
    this.replyToMessage,
    this.onEdit,
    this.onDelete,
  });

  final Message message;
  final bool isMe;
  final VoidCallback? onReply;
  final Function(String emoji)? onReactionTap;
  final VoidCallback? onAddReaction;
  final int? currentUserId;
  final Message? replyToMessage;
  final VoidCallback? onEdit;
  final VoidCallback? onDelete;

  @override
  Widget build(BuildContext context) {
    final textColor = FormatUtils.getTextColor(context, isMe);
    final textTheme = Theme.of(context).textTheme;

    return BaseBubbleContainer(
      isMe: isMe,
      message: message,
      onReply: onReply,
      onReactionTap: onReactionTap,
      onAddReaction: onAddReaction,
      currentUserId: currentUserId,
      replyToMessage: replyToMessage,
      onEdit: onEdit,
      onDelete: onDelete,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        child: Text(message.content, style: textTheme.bodyMedium?.copyWith(color: textColor)),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/message_bubbles/video_message_bubble.dart
================================================================
import 'package:cached_network_image/cached_network_image.dart';
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:chattrix_ui/features/chat/presentation/utils/format_utils.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/lazy_media_loader.dart';
import 'package:chattrix_ui/features/chat/presentation/widgets/message_bubble.dart';
import 'package:flutter/material.dart';
import 'package:video_player/video_player.dart';

class VideoMessageBubble extends StatefulWidget {
  const VideoMessageBubble({
    super.key,
    required this.message,
    required this.isMe,
    this.onReply,
    this.onReactionTap,
    this.onAddReaction,
    this.currentUserId,
    this.replyToMessage,
    this.onEdit,
    this.onDelete,
  });

  final Message message;
  final bool isMe;
  final VoidCallback? onReply;
  final Function(String emoji)? onReactionTap;
  final VoidCallback? onAddReaction;
  final int? currentUserId;
  final Message? replyToMessage;
  final VoidCallback? onEdit;
  final VoidCallback? onDelete;

  @override
  State<VideoMessageBubble> createState() => _VideoMessageBubbleState();
}

class _VideoMessageBubbleState extends State<VideoMessageBubble> with AutomaticKeepAliveClientMixin {
  VideoPlayerController? _controller;
  bool _isInitialized = false;
  bool _isPlaying = false;

  @override
  bool get wantKeepAlive => true; // Keep state when scrolling

  Future<void> _initializeVideo() async {
    if (widget.message.mediaUrl == null || _isInitialized || _controller != null) return;

    try {
      _controller = VideoPlayerController.networkUrl(Uri.parse(widget.message.mediaUrl!));

      await _controller!.initialize();

      if (mounted) {
        setState(() {
          _isInitialized = true;
        });
      }

      _controller!.addListener(() {
        if (mounted) {
          setState(() {
            _isPlaying = _controller!.value.isPlaying;
          });
        }
      });
    } catch (e) {
      debugPrint('‚ùå Failed to initialize video: $e');
    }
  }

  @override
  void dispose() {
    _controller?.dispose();
    super.dispose();
  }

  Future<void> _togglePlayPause() async {

    if (!_isInitialized && _controller == null) {
      await _initializeVideo();
    }

    if (_controller == null || !_isInitialized) return;

    setState(() {
      if (_controller!.value.isPlaying) {
        _controller!.pause();
      } else {
        _controller!.play();
      }
    });
  }

  void _openFullScreenVideo(BuildContext context) {
    if (widget.message.mediaUrl == null) return;

    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) =>
            _FullScreenVideoPlayer(videoUrl: widget.message.mediaUrl!, caption: widget.message.content),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    super.build(context); // Required for AutomaticKeepAliveClientMixin

    final textColor = FormatUtils.getTextColor(context, widget.isMe);
    final textTheme = Theme.of(context).textTheme;

    return BaseBubbleContainer(
      isMe: widget.isMe,
      maxWidth: 280,
      message: widget.message,
      onReply: widget.onReply,
      onReactionTap: widget.onReactionTap,
      onAddReaction: widget.onAddReaction,
      currentUserId: widget.currentUserId,
      replyToMessage: widget.replyToMessage,
      onEdit: widget.onEdit,
      onDelete: widget.onDelete,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [

          if (widget.message.mediaUrl != null)
            LazyMediaLoader(
              key: ValueKey('video_${widget.message.id}'),
              placeholder: Container(
                width: 280,
                height: 200,
                color: Colors.grey.shade300,
                child: const Center(child: Icon(Icons.videocam, size: 48, color: Colors.grey)),
              ),
              child: GestureDetector(
                onTap: _togglePlayPause,
                onLongPress: () => _openFullScreenVideo(context),
                child: Stack(
                  alignment: Alignment.center,
                  children: [
                    ClipRRect(
                      borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
                      child: _isInitialized && _controller != null
                          ? AspectRatio(aspectRatio: _controller!.value.aspectRatio, child: VideoPlayer(_controller!))
                          : widget.message.thumbnailUrl != null
                          ? CachedNetworkImage(
                              imageUrl: widget.message.thumbnailUrl!,
                              width: 280,
                              height: 200,
                              fit: BoxFit.cover,
                              memCacheWidth: 560,
                              maxWidthDiskCache: 560,
                              placeholder: (context, url) => Container(
                                width: 280,
                                height: 200,
                                color: Colors.grey.shade300,
                                child: const Center(child: CircularProgressIndicator()),
                              ),
                              errorWidget: (context, url, error) {
                                return Container(
                                  width: 280,
                                  height: 200,
                                  color: Colors.grey.shade300,
                                  child: const Icon(Icons.videocam, size: 48),
                                );
                              },
                            )
                          : Container(
                              width: 280,
                              height: 200,
                              color: Colors.grey.shade300,
                              child: const Center(child: CircularProgressIndicator()),
                            ),
                    ),

                    if (!_isPlaying)
                      Container(
                        width: 60,
                        height: 60,
                        decoration: BoxDecoration(color: Colors.black.withValues(alpha: 0.6), shape: BoxShape.circle),
                        child: const Icon(Icons.play_arrow, color: Colors.white, size: 36),
                      ),

                    if (widget.message.duration != null && !_isPlaying)
                      Positioned(
                        bottom: 8,
                        right: 8,
                        child: Container(
                          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: Colors.black.withValues(alpha: 0.7),
                            borderRadius: BorderRadius.circular(4),
                          ),
                          child: Text(
                            FormatUtils.formatDuration(widget.message.duration!),
                            style: const TextStyle(color: Colors.white, fontSize: 12, fontWeight: FontWeight.w500),
                          ),
                        ),
                      ),

                    if (_isInitialized && _controller != null)
                      Positioned(
                        bottom: 0,
                        left: 0,
                        right: 0,
                        child: VideoProgressIndicator(
                          _controller!,
                          allowScrubbing: true,
                          colors: const VideoProgressColors(
                            playedColor: Colors.blue,
                            bufferedColor: Colors.grey,
                            backgroundColor: Colors.black26,
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            ),

          if (widget.message.content.isNotEmpty)
            Padding(
              padding: const EdgeInsets.all(12),
              child: Text(widget.message.content, style: textTheme.bodyMedium?.copyWith(color: textColor)),
            ),
        ],
      ),
    );
  }
}

class _FullScreenVideoPlayer extends StatefulWidget {
  const _FullScreenVideoPlayer({required this.videoUrl, this.caption});

  final String videoUrl;
  final String? caption;

  @override
  State<_FullScreenVideoPlayer> createState() => _FullScreenVideoPlayerState();
}

class _FullScreenVideoPlayerState extends State<_FullScreenVideoPlayer> {
  VideoPlayerController? _controller;
  bool _isInitialized = false;
  bool _isPlaying = false;

  @override
  void initState() {
    super.initState();
    _initializeVideo();
  }

  Future<void> _initializeVideo() async {
    try {
      _controller = VideoPlayerController.networkUrl(Uri.parse(widget.videoUrl));

      await _controller!.initialize();

      if (mounted) {
        setState(() {
          _isInitialized = true;
        });

        _controller!.play();
      }

      _controller!.addListener(() {
        if (mounted) {
          setState(() {
            _isPlaying = _controller!.value.isPlaying;
          });
        }
      });
    } catch (e) {
      debugPrint('‚ùå Failed to initialize video: $e');
    }
  }

  @override
  void dispose() {
    _controller?.dispose();
    super.dispose();
  }

  void _togglePlayPause() {
    if (_controller == null || !_isInitialized) return;

    setState(() {
      if (_controller!.value.isPlaying) {
        _controller!.pause();
      } else {
        _controller!.play();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        backgroundColor: Colors.black,
        iconTheme: const IconThemeData(color: Colors.white),
        title: widget.caption != null && widget.caption!.isNotEmpty
            ? Text(widget.caption!, style: const TextStyle(color: Colors.white))
            : null,
      ),
      body: Center(
        child: _isInitialized && _controller != null
            ? GestureDetector(
                onTap: _togglePlayPause,
                child: Stack(
                  alignment: Alignment.center,
                  children: [
                    AspectRatio(aspectRatio: _controller!.value.aspectRatio, child: VideoPlayer(_controller!)),

                    if (!_isPlaying)
                      Container(
                        width: 80,
                        height: 80,
                        decoration: BoxDecoration(color: Colors.black.withValues(alpha: 0.6), shape: BoxShape.circle),
                        child: const Icon(Icons.play_arrow, color: Colors.white, size: 48),
                      ),

                    Positioned(
                      bottom: 0,
                      left: 0,
                      right: 0,
                      child: VideoProgressIndicator(
                        _controller!,
                        allowScrubbing: true,
                        colors: const VideoProgressColors(
                          playedColor: Colors.blue,
                          bufferedColor: Colors.grey,
                          backgroundColor: Colors.black26,
                        ),
                      ),
                    ),
                  ],
                ),
              )
            : const CircularProgressIndicator(color: Colors.white),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/message_long_press_overlay.dart
================================================================
import 'package:flutter/material.dart';
import 'package:flutter_emoji/flutter_emoji.dart';

class MessageLongPressOverlay extends StatefulWidget {
  const MessageLongPressOverlay({
    super.key,
    required this.messageKey,
    required this.isMe,
    required this.onReply,
    required this.onAddReaction,
    required this.onEdit,
    required this.onDelete,
    required this.onQuickReaction,
    required this.canEdit,
  });

  final GlobalKey messageKey;
  final bool isMe;
  final VoidCallback? onReply;
  final VoidCallback? onAddReaction;
  final VoidCallback? onEdit;
  final VoidCallback? onDelete;
  final Function(String emoji) onQuickReaction;
  final bool canEdit;

  @override
  State<MessageLongPressOverlay> createState() => _MessageLongPressOverlayState();
}

class _MessageLongPressOverlayState extends State<MessageLongPressOverlay> with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  late Animation<double> _fadeAnimation;

  static const List<String> _quickEmojis = ['üëç', '‚ù§Ô∏è', 'üòÇ', 'üòÆ', 'üò¢', 'üî•'];

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(duration: const Duration(milliseconds: 200), vsync: this);

    _scaleAnimation = CurvedAnimation(parent: _animationController, curve: Curves.easeOutBack);

    _fadeAnimation = CurvedAnimation(parent: _animationController, curve: Curves.easeOut);

    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  void _close() {
    FocusScope.of(context).unfocus();
    _animationController.reverse().then((_) {
      if (mounted) {
        Navigator.of(context).pop();
      }
    });
  }

  void _handleQuickReaction(String emoji) {
    Navigator.of(context).pop();
    widget.onQuickReaction(emoji);
  }

  void _handleAction(VoidCallback? action) {
    if (action != null) {
      Navigator.of(context).pop();
      Future.delayed(const Duration(milliseconds: 100), () {
        action();
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final RenderBox? renderBox = widget.messageKey.currentContext?.findRenderObject() as RenderBox?;

    if (renderBox == null) {
      return const SizedBox.shrink();
    }

    final position = renderBox.localToGlobal(Offset.zero);
    final size = renderBox.size;
    final screenSize = MediaQuery.of(context).size;

    final emojiBarWidth = 280.0;
    final emojiBarHeight = 56.0;
    final padding = 16.0;
    final spacing = 12.0;

    double emojiBarLeft;
    if (widget.isMe) {
      emojiBarLeft = position.dx + size.width - emojiBarWidth;
      if (emojiBarLeft < padding) emojiBarLeft = padding;
    } else {
      emojiBarLeft = position.dx;
      if (emojiBarLeft + emojiBarWidth > screenSize.width - padding) {
        emojiBarLeft = screenSize.width - emojiBarWidth - padding;
      }
    }

    final spaceAbove = position.dy;
    final spaceBelow = screenSize.height - (position.dy + size.height);

    double emojiBarTop;
    if (spaceAbove >= emojiBarHeight + spacing + padding) {
      emojiBarTop = position.dy - emojiBarHeight - spacing;
    } else if (spaceBelow >= emojiBarHeight + spacing + padding) {
      emojiBarTop = position.dy + size.height + spacing;
    } else {
      emojiBarTop = padding;
    }

    if (emojiBarTop < padding) emojiBarTop = padding;
    if (emojiBarTop + emojiBarHeight > screenSize.height - padding) {
      emojiBarTop = screenSize.height - emojiBarHeight - padding;
    }

    return Material(
      color: Colors.black.withValues(alpha: 0.5),
      child: Stack(
        children: [
          Positioned.fill(
            child: GestureDetector(onTap: _close, behavior: HitTestBehavior.translucent),
          ),
          Positioned(
            left: emojiBarLeft,
            top: emojiBarTop,
            child: FadeTransition(
              opacity: _fadeAnimation,
              child: ScaleTransition(
                scale: _scaleAnimation,
                child: _EmojiBar(emojis: _quickEmojis, onEmojiTap: _handleQuickReaction),
              ),
            ),
          ),
          Positioned(
            left: 0,
            right: 0,
            bottom: 0,
            child: SlideTransition(
              position: Tween<Offset>(
                begin: const Offset(0, 1),
                end: Offset.zero,
              ).animate(CurvedAnimation(parent: _animationController, curve: Curves.easeOut)),
              child: _ActionBar(
                onReply: widget.onReply != null ? () => _handleAction(widget.onReply) : null,
                onCopy: () {
                  _close();
                },
                onEdit: widget.canEdit && widget.onEdit != null ? () => _handleAction(widget.onEdit) : null,
                onDelete: widget.isMe && widget.onDelete != null ? () => _handleAction(widget.onDelete) : null,
                onAddReaction: widget.onAddReaction != null ? () => _handleAction(widget.onAddReaction) : null,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _EmojiBar extends StatelessWidget {
  const _EmojiBar({required this.emojis, required this.onEmojiTap});

  final List<String> emojis;
  final Function(String emoji) onEmojiTap;

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(25),
        boxShadow: [BoxShadow(color: Colors.black.withValues(alpha: 0.2), blurRadius: 8, offset: const Offset(0, 2))],
      ),
      child: Material(
        color: Colors.transparent,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: emojis.map((emoji) {
            return _EmojiButton(emoji: emoji, onTap: () => onEmojiTap(emoji));
          }).toList(),
        ),
      ),
    );
  }
}

class _EmojiButton extends StatefulWidget {
  const _EmojiButton({required this.emoji, required this.onTap});

  final String emoji;
  final VoidCallback onTap;

  @override
  State<_EmojiButton> createState() => _EmojiButtonState();
}

class _EmojiButtonState extends State<_EmojiButton> with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  final EmojiParser emojiParser = EmojiParser();

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(duration: const Duration(milliseconds: 100), vsync: this);
    _scaleAnimation = Tween<double>(
      begin: 1.0,
      end: 1.3,
    ).animate(CurvedAnimation(parent: _controller, curve: Curves.easeInOut));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTapDown: (_) => _controller.forward(),
        onTapUp: (_) {
          _controller.reverse();
          widget.onTap();
        },
        onTapCancel: () => _controller.reverse(),
        borderRadius: BorderRadius.circular(20),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 6),
          child: ScaleTransition(
            scale: _scaleAnimation,
            child: Text(
              emojiParser.emojify(widget.emoji),
              style: const TextStyle(fontSize: 28, fontFamily: 'NotoColorEmoji'),
            ),
          ),
        ),
      ),
    );
  }
}

class _ActionBar extends StatelessWidget {
  const _ActionBar({
    required this.onReply,
    required this.onCopy,
    required this.onEdit,
    required this.onDelete,
    required this.onAddReaction,
  });

  final VoidCallback? onReply;
  final VoidCallback? onCopy;
  final VoidCallback? onEdit;
  final VoidCallback? onDelete;
  final VoidCallback? onAddReaction;

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    final actions = <Widget>[];

    if (onReply != null) {
      actions.add(
        _ActionButton(icon: Icons.reply, label: 'Reply', onTap: onReply!, textTheme: textTheme, colors: colors),
      );
    }

    if (onCopy != null) {
      actions.add(_ActionButton(icon: Icons.copy, label: 'Copy', onTap: onCopy!, textTheme: textTheme, colors: colors));
    }

    if (onEdit != null) {
      actions.add(_ActionButton(icon: Icons.edit, label: 'Edit', onTap: onEdit!, textTheme: textTheme, colors: colors));
    }

    if (onAddReaction != null) {
      actions.add(
        _ActionButton(
          icon: Icons.add_reaction_outlined,
          label: 'React',
          onTap: onAddReaction!,
          textTheme: textTheme,
          colors: colors,
        ),
      );
    }

    if (onDelete != null) {
      actions.add(
        _ActionButton(
          icon: Icons.delete,
          label: 'Delete',
          onTap: onDelete!,
          textTheme: textTheme,
          colors: colors,
          isDestructive: true,
        ),
      );
    }

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
        boxShadow: [BoxShadow(color: Colors.black.withValues(alpha: 0.1), blurRadius: 10, offset: const Offset(0, -2))],
      ),
      child: SafeArea(
        child: Row(mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: actions),
      ),
    );
  }
}

class _ActionButton extends StatelessWidget {
  const _ActionButton({
    required this.icon,
    required this.label,
    required this.onTap,
    required this.textTheme,
    required this.colors,
    this.isDestructive = false,
  });

  final IconData icon;
  final String label;
  final VoidCallback onTap;
  final TextTheme textTheme;
  final ColorScheme colors;
  final bool isDestructive;

  @override
  Widget build(BuildContext context) {
    final color = isDestructive ? Colors.red : colors.onSurface;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 24, color: color),
            const SizedBox(height: 4),
            Text(
              label,
              style: textTheme.labelSmall?.copyWith(color: color, fontWeight: FontWeight.w500),
            ),
          ],
        ),
      ),
    );
  }
}

void showMessageLongPressOverlay({
  required BuildContext context,
  required GlobalKey messageKey,
  required bool isMe,
  VoidCallback? onReply,
  VoidCallback? onAddReaction,
  VoidCallback? onEdit,
  VoidCallback? onDelete,
  required Function(String emoji) onQuickReaction,
  required bool canEdit,
}) {
  FocusScope.of(context).unfocus();
  showDialog(
    context: context,
    barrierColor: Colors.transparent,
    barrierDismissible: true,
    useSafeArea: false,
    builder: (context) => MessageLongPressOverlay(
      messageKey: messageKey,
      isMe: isMe,
      onReply: onReply,
      onAddReaction: onAddReaction,
      onEdit: onEdit,
      onDelete: onDelete,
      onQuickReaction: onQuickReaction,
      canEdit: canEdit,
    ),
  );
}

================================================================
FILE: lib/features/chat/presentation/widgets/message_reactions.dart
================================================================
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_emoji/flutter_emoji.dart';
class MessageReactions extends StatelessWidget {
  MessageReactions({
    super.key,
    required this.reactions,
    required this.currentUserId,
    required this.onReactionTap,
    required this.onAddReaction,
  }) : emojiParser = EmojiParser();

  final String? reactions; // JSON string: {"üëç": [1, 2, 3], "‚ù§Ô∏è": [4, 5]}
  final int currentUserId;
  final Function(String emoji) onReactionTap;
  final VoidCallback onAddReaction;
  final EmojiParser emojiParser;

  @override
  Widget build(BuildContext context) {
    if (reactions == null || reactions!.isEmpty) {
      return const SizedBox.shrink();
    }

    final reactionsMap = _parseReactions(reactions!);

    if (reactionsMap.isEmpty) {
      return const SizedBox.shrink();
    }

    final colors = Theme.of(context).colorScheme;

    return Padding(
      padding: const EdgeInsets.only(top: 4),
      child: Wrap(
        spacing: 4,
        runSpacing: 4,
        children: [
          ...reactionsMap.entries.map((entry) {
            final emoji = entry.key;
            final userIds = entry.value;
            final hasReacted = userIds.contains(currentUserId);

            return GestureDetector(
              onTap: () => onReactionTap(emoji),
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: hasReacted ? colors.primaryContainer : colors.surfaceContainerHighest,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(
                    color: hasReacted ? colors.primary : colors.outlineVariant,
                    width: hasReacted ? 1.5 : 1,
                  ),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      emojiParser.emojify(emoji),
                      style: const TextStyle(fontSize: 16, fontFamily: 'NotoColorEmoji'),
                    ),
                    const SizedBox(width: 4),
                    Text(
                      '${userIds.length}',
                      style: TextStyle(
                        fontSize: 12,
                        fontWeight: hasReacted ? FontWeight.w600 : FontWeight.normal,
                        color: hasReacted ? colors.onPrimaryContainer : colors.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
              ),
            );
          }),
          GestureDetector(
            onTap: onAddReaction,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(
                color: colors.surfaceContainerHighest,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(color: colors.outlineVariant),
              ),
              child: const Icon(Icons.add_reaction_outlined, size: 16),
            ),
          ),
        ],
      ),
    );
  }

  Map<String, List<int>> _parseReactions(String reactionsJson) {
    try {
      final decoded = jsonDecode(reactionsJson) as Map<String, dynamic>;
      final result = <String, List<int>>{};

      decoded.forEach((emoji, userIds) {
        if (userIds is List) {
          result[emoji] = userIds.cast<int>();
        }
      });

      return result;
    } catch (e) {
      return {};
    }
  }
}
class ReactionPickerBottomSheet extends StatelessWidget {
  ReactionPickerBottomSheet({super.key, required this.onEmojiSelected}) : emojiParser = EmojiParser();

  final Function(String emoji) onEmojiSelected;
  final EmojiParser emojiParser;

  static const List<String> _commonEmojis = [
    'üëç',
    '‚ù§Ô∏è',
    'üòÇ',
    'üòÆ',
    'üò¢',
    'üò°',
    'üéâ',
    'üî•',
    'üëè',
    'üíØ',
    '‚úÖ',
    '‚ùå',
    'üôè',
    'üí™',
    'üëÄ',
    'ü§î',
    'üòä',
    'üòé',
    'ü•≥',
    'üòç',
    'ü§ó',
    'üò¥',
    'ü§Ø',
    'üôå',
  ];

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Center(
            child: Container(
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: colors.onSurfaceVariant.withValues(alpha: 0.4),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
          const SizedBox(height: 16),
          Text('React to message', style: textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600)),
          const SizedBox(height: 16),
          GridView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 8,
              mainAxisSpacing: 8,
              crossAxisSpacing: 8,
              childAspectRatio: 1,
            ),
            itemCount: _commonEmojis.length,
            itemBuilder: (context, index) {
              final emoji = _commonEmojis[index];
              return GestureDetector(
                onTap: () {
                  onEmojiSelected(emoji);
                  Navigator.pop(context);
                },
                child: Container(
                  decoration: BoxDecoration(
                    color: colors.surfaceContainerHighest,
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Center(
                    child: Text(
                      emojiParser.emojify(emoji),
                      style: const TextStyle(fontSize: 24, fontFamily: 'NotoColorEmoji'),
                    ),
                  ),
                ),
              );
            },
          ),
          const SizedBox(height: 16),
        ],
      ),
    );
  }
}
Future<void> showReactionPicker(BuildContext context, Function(String emoji) onEmojiSelected) {
  return showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    backgroundColor: Colors.transparent,
    builder: (context) => ReactionPickerBottomSheet(onEmojiSelected: onEmojiSelected),
  );
}

================================================================
FILE: lib/features/chat/presentation/widgets/note_dialog.dart
================================================================
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../domain/entities/user_note_entity.dart';
import '../providers/user_notes_provider.dart';
class NoteDialog extends HookConsumerWidget {
  final String currentUserId;
  final UserNoteEntity? existingNote;

  const NoteDialog({super.key, required this.currentUserId, this.existingNote});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final controller = useTextEditingController(text: existingNote?.content ?? '');
    final characterCount = useState(existingNote?.content.length ?? 0);
    const maxCharacters = 60;

    useEffect(() {
      void listener() {
        characterCount.value = controller.text.length;
      }

      controller.addListener(listener);
      return () => controller.removeListener(listener);
    }, [controller]);

    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              existingNote != null ? 'Edit your note' : 'Add a note',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: controller,
              autofocus: true,
              maxLength: maxCharacters,
              maxLines: 3,
              decoration: InputDecoration(
                hintText: "What's on your mind?",
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                counterText: '${characterCount.value}/$maxCharacters',
              ),
              onChanged: (value) {
              },
            ),
            const SizedBox(height: 24),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                if (existingNote != null) ...[
                  TextButton(
                    onPressed: () {
                      ref.read(userNotesProvider.notifier).deleteNote(currentUserId);
                      Navigator.of(context).pop();
                    },
                    style: TextButton.styleFrom(foregroundColor: Colors.red),
                    child: const Text('Delete'),
                  ),
                  const Spacer(),
                ],
                TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text('Cancel')),
                const SizedBox(width: 8),
                ElevatedButton(
                  onPressed: controller.text.trim().isEmpty
                      ? null
                      : () {
                          ref
                              .read(userNotesProvider.notifier)
                              .createOrUpdateNote(currentUserId, controller.text.trim());
                          Navigator.of(context).pop();
                        },
                  child: const Text('Save'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/online_user_item.dart
================================================================
import 'package:chattrix_ui/core/widgets/user_avatar.dart';
import 'package:chattrix_ui/features/auth/domain/entities/user.dart';
import 'package:flutter/material.dart';

class OnlineUserItem extends StatelessWidget {
  final User user;
  final String? note;
  final VoidCallback onTap;

  const OnlineUserItem({
    super.key,
    required this.user,
    this.note,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final hasNote = note != null && note!.isNotEmpty;
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Semantics(
      label: hasNote
          ? '${user.username}\'s story: $note. Double tap to view.'
          : '${user.username} is online. Double tap to chat.',
      button: true,
      enabled: true,
      child: GestureDetector(
        onTap: onTap,
        child: SizedBox(
          width: 64,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            mainAxisAlignment: MainAxisAlignment.start,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              if (hasNote) ...[
                Container(
                  constraints: const BoxConstraints(maxWidth: 64),
                  padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2), // Gi·ªØ padding nh·ªè
                  decoration: BoxDecoration(
                    color: theme.colorScheme.primary, // D√πng m√†u primary
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(
                      color: isDark ? Colors.transparent : Colors.white.withOpacity(0.8),
                      width: 0.5,
                    ),
                  ),
                  child: Text(
                    note!,
                    style: TextStyle(
                      fontSize: 9,
                      fontWeight: FontWeight.w700,
                      color: theme.colorScheme.onPrimary,
                      height: 1.1,
                    ),
                    maxLines: 1, // *QUAN TR·ªåNG: Gi·ªõi h·∫°n 1 d√≤ng ƒë·ªÉ tr√°nh Overflow (t·ªïng 88px)*
                    overflow: TextOverflow.ellipsis,
                    textAlign: TextAlign.center,
                  ),
                ),
                const SizedBox(height: 2), // *QUAN TR·ªåNG: Kho·∫£ng c√°ch 2px*
              ] else ...[
                const SizedBox(height: 20),
              ],
              SizedBox(
                height: 52, // K√≠ch th∆∞·ªõc avatar 52x52
                width: 52,
                child: Stack(
                  children: [
                    UserAvatar(
                      avatarUrl: user.avatarUrl,
                      displayName: user.username,
                      radius: 26, // Radius 26 -> 52x52
                    ),
                    Container(
                      height: 52,
                      width: 52,
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: theme.colorScheme.primary, // M√†u border Story
                          width: 2.0,
                        ),
                      ),
                    ),
                  ],
                ),
              ),

              const SizedBox(height: 2), // *QUAN TR·ªåNG: Kho·∫£ng c√°ch 2px*
              Text(
                user.username,
                style: const TextStyle(fontSize: 10, fontWeight: FontWeight.w500, height: 1.2),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/reply_message_preview.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/message.dart';
import 'package:flutter/material.dart';

class ReplyMessagePreview extends StatelessWidget {
  const ReplyMessagePreview({super.key, required this.replyToMessage, required this.onCancel});

  final Message replyToMessage;
  final VoidCallback onCancel;

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: colors.surfaceContainerHighest,
        border: Border(top: BorderSide(color: colors.outlineVariant)),
      ),
      child: Row(
        children: [

          Container(
            width: 4,
            height: 48,
            decoration: BoxDecoration(color: colors.primary, borderRadius: BorderRadius.circular(2)),
          ),
          const SizedBox(width: 12),

          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  replyToMessage.senderFullName ?? replyToMessage.senderUsername ?? 'User',
                  style: textTheme.labelMedium?.copyWith(color: colors.primary, fontWeight: FontWeight.w600),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 4),
                Text(
                  _getMessagePreview(),
                  style: textTheme.bodySmall?.copyWith(color: colors.onSurfaceVariant),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
          ),

          IconButton(
            icon: const Icon(Icons.close, size: 20),
            onPressed: onCancel,
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
          ),
        ],
      ),
    );
  }

  String _getMessagePreview() {
    final type = replyToMessage.type.toUpperCase();
    switch (type) {
      case 'IMAGE':
        return 'üì∑ Photo';
      case 'VIDEO':
        return 'üé• Video';
      case 'AUDIO':
      case 'VOICE':
        return 'üé§ Voice message';
      case 'DOCUMENT':
      case 'FILE':
        return 'üìÑ ${replyToMessage.fileName ?? 'Document'}';
      case 'LOCATION':
        return 'üìç ${replyToMessage.locationName ?? 'Location'}';
      case 'TEXT':
      default:
        return replyToMessage.content;
    }
  }
}

class QuotedMessageWidget extends StatelessWidget {
  const QuotedMessageWidget({super.key, required this.replyToMessage, required this.onTap});

  final Message replyToMessage;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    return GestureDetector(
      onTap: onTap,
      child: Container(
        margin: const EdgeInsets.only(bottom: 8),
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: colors.surfaceContainerHighest.withValues(alpha: 0.5),
          borderRadius: BorderRadius.circular(8),
          border: Border(left: BorderSide(color: colors.primary, width: 3)),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              replyToMessage.senderFullName ?? replyToMessage.senderUsername ?? 'User',
              style: textTheme.labelSmall?.copyWith(color: colors.primary, fontWeight: FontWeight.w600),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
            const SizedBox(height: 2),
            Text(
              _getMessagePreview(),
              style: textTheme.bodySmall?.copyWith(color: colors.onSurfaceVariant),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ),
      ),
    );
  }

  String _getMessagePreview() {
    final type = replyToMessage.type.toUpperCase();
    switch (type) {
      case 'IMAGE':
        return 'üì∑ Photo';
      case 'VIDEO':
        return 'üé• Video';
      case 'AUDIO':
      case 'VOICE':
        return 'üé§ Voice message';
      case 'DOCUMENT':
      case 'FILE':
        return 'üìÑ ${replyToMessage.fileName ?? 'Document'}';
      case 'LOCATION':
        return 'üìç ${replyToMessage.locationName ?? 'Location'}';
      case 'TEXT':
      default:
        return replyToMessage.content;
    }
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/typing_indicator_widget.dart
================================================================
import 'package:chattrix_ui/features/chat/domain/entities/typing_indicator.dart';
import 'package:flutter/material.dart';
class TypingIndicatorWidget extends StatelessWidget {
  final List<TypingUser> typingUsers;

  const TypingIndicatorWidget({super.key, required this.typingUsers});
  String _getTypingText() {
    if (typingUsers.isEmpty) return '';

    if (typingUsers.length == 1) {
      return '${typingUsers[0].fullName} is typing';
    } else if (typingUsers.length == 2) {
      return '${typingUsers[0].fullName} and ${typingUsers[1].fullName} are typing';
    } else {
      return '${typingUsers[0].fullName} and ${typingUsers.length - 1} others are typing';
    }
  }

  @override
  Widget build(BuildContext context) {
    if (typingUsers.isEmpty) return const SizedBox.shrink();

    final colors = Theme.of(context).colorScheme;
    final textStyle = Theme.of(
      context,
    ).textTheme.bodySmall?.copyWith(color: colors.onSurface.withOpacity(0.6), fontStyle: FontStyle.italic);

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: colors.surface.withOpacity(0.5),
        border: Border(top: BorderSide(color: colors.onSurface.withOpacity(0.1), width: 1)),
      ),
      child: Row(
        children: [
          Text(_getTypingText(), style: textStyle),
          const SizedBox(width: 4),
          const TypingDotsAnimation(),
        ],
      ),
    );
  }
}
class TypingDotsAnimation extends StatefulWidget {
  final Color? color;
  final double dotSize;

  const TypingDotsAnimation({super.key, this.color, this.dotSize = 4});

  @override
  State<TypingDotsAnimation> createState() => _TypingDotsAnimationState();
}

class _TypingDotsAnimationState extends State<TypingDotsAnimation> with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(vsync: this, duration: const Duration(milliseconds: 1400))..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final color = widget.color ?? Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6);

    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            _buildDot(color, 0),
            const SizedBox(width: 3),
            _buildDot(color, 1),
            const SizedBox(width: 3),
            _buildDot(color, 2),
          ],
        );
      },
    );
  }

  Widget _buildDot(Color color, int index) {
    final delay = index * 0.2;
    final progress = (_controller.value + delay) % 1.0;
    double opacity;
    if (progress < 0.5) {
      opacity = progress * 2; // Fade in
    } else {
      opacity = 2 - (progress * 2); // Fade out
    }

    opacity = opacity.clamp(0.2, 1.0);

    return Container(
      width: widget.dotSize,
      height: widget.dotSize,
      decoration: BoxDecoration(
        color: color.withValues(alpha: opacity),
        shape: BoxShape.circle,
      ),
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/upload_progress_overlay.dart
================================================================
import 'package:flutter/material.dart';

class UploadProgressOverlay extends StatelessWidget {
  const UploadProgressOverlay({super.key, required this.progress, required this.fileName, this.onCancel});

  final double progress; // 0.0 to 1.0
  final String fileName;
  final VoidCallback? onCancel;

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    return Container(
      margin: const EdgeInsets.all(16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [BoxShadow(color: Colors.black.withValues(alpha: 0.2), blurRadius: 8, offset: const Offset(0, 2))],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [

          Row(
            children: [
              Icon(Icons.cloud_upload_outlined, color: colors.primary),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('Uploading', style: textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w600)),
                    Text(
                      fileName,
                      style: textTheme.bodySmall?.copyWith(color: colors.onSurfaceVariant),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),
              if (onCancel != null)
                IconButton(
                  icon: const Icon(Icons.close, size: 20),
                  onPressed: onCancel,
                  padding: EdgeInsets.zero,
                  constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
                ),
            ],
          ),
          const SizedBox(height: 12),

          ClipRRect(
            borderRadius: BorderRadius.circular(4),
            child: LinearProgressIndicator(
              value: progress,
              minHeight: 8,
              backgroundColor: colors.surfaceContainerHighest,
              valueColor: AlwaysStoppedAnimation<Color>(colors.primary),
            ),
          ),
          const SizedBox(height: 8),

          Text(
            '${(progress * 100).toStringAsFixed(0)}%',
            style: textTheme.bodySmall?.copyWith(color: colors.onSurfaceVariant),
          ),
        ],
      ),
    );
  }
}

OverlayEntry showUploadProgress(BuildContext context, {required String fileName, VoidCallback? onCancel}) {
  final overlayEntry = OverlayEntry(
    builder: (context) => Positioned(
      bottom: 80,
      left: 0,
      right: 0,
      child: UploadProgressOverlay(progress: 0.0, fileName: fileName, onCancel: onCancel),
    ),
  );

  Overlay.of(context).insert(overlayEntry);
  return overlayEntry;
}

void updateUploadProgress(OverlayEntry overlayEntry, double progress, String fileName, VoidCallback? onCancel) {
  overlayEntry.markNeedsBuild();
}

class UploadProgressNotifier extends ValueNotifier<UploadProgress?> {
  UploadProgressNotifier() : super(null);

  void startUpload(String fileName) {
    value = UploadProgress(fileName: fileName, progress: 0.0, isUploading: true);
  }

  void updateProgress(double progress) {
    if (value != null) {
      value = value!.copyWith(progress: progress);
    }
  }

  void completeUpload() {
    value = null;
  }

  void cancelUpload() {
    value = null;
  }
}

class UploadProgress {
  final String fileName;
  final double progress;
  final bool isUploading;
  final String? error;

  const UploadProgress({required this.fileName, required this.progress, required this.isUploading, this.error});

  UploadProgress copyWith({String? fileName, double? progress, bool? isUploading, String? error}) {
    return UploadProgress(
      fileName: fileName ?? this.fileName,
      progress: progress ?? this.progress,
      isUploading: isUploading ?? this.isUploading,
      error: error ?? this.error,
    );
  }
}

class UploadProgressWidget extends StatelessWidget {
  const UploadProgressWidget({super.key, required this.uploadProgress, this.onCancel});

  final UploadProgress? uploadProgress;
  final VoidCallback? onCancel;

  @override
  Widget build(BuildContext context) {
    if (uploadProgress == null || !uploadProgress!.isUploading) {
      return const SizedBox.shrink();
    }

    return UploadProgressOverlay(
      progress: uploadProgress!.progress,
      fileName: uploadProgress!.fileName,
      onCancel: onCancel,
    );
  }
}

================================================================
FILE: lib/features/chat/presentation/widgets/voice_recorder_widget.dart
================================================================
import 'dart:async';
import 'dart:io';

import 'package:chattrix_ui/features/chat/services/voice_recorder_provider.dart';
import 'package:chattrix_ui/features/chat/services/voice_recorder_service.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class VoiceRecorderWidget extends HookConsumerWidget {
  const VoiceRecorderWidget({super.key, required this.onRecordingComplete, required this.onCancel});

  final Function(File audioFile, Duration duration) onRecordingComplete;
  final VoidCallback onCancel;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final recorderService = ref.watch(voiceRecorderServiceProvider);
    final isRecording = useState(false);
    final isPaused = useState(false);
    final duration = useState(Duration.zero);
    final durationSubscription = useRef<StreamSubscription?>(null);

    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    useEffect(() {

      durationSubscription.value = recorderService.durationStream.listen((d) {
        duration.value = d;
      });

      _startRecording(recorderService, isRecording);

      return () {
        durationSubscription.value?.cancel();
      };
    }, []);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: colors.surface,
        boxShadow: [BoxShadow(color: Colors.black.withValues(alpha: 0.1), blurRadius: 8, offset: const Offset(0, -2))],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [

          Row(
            children: [

              AnimatedContainer(
                duration: const Duration(milliseconds: 500),
                width: 12,
                height: 12,
                decoration: BoxDecoration(
                  color: isPaused.value ? colors.error.withValues(alpha: 0.5) : colors.error,
                  shape: BoxShape.circle,
                ),
              ),
              const SizedBox(width: 12),

              Text(
                _formatDuration(duration.value),
                style: textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                  fontFeatures: [const FontFeature.tabularFigures()],
                ),
              ),
              const Spacer(),

              Text(
                isPaused.value ? 'Paused' : 'Recording...',
                style: textTheme.bodyMedium?.copyWith(color: colors.onSurfaceVariant),
              ),
            ],
          ),
          const SizedBox(height: 16),

          Container(
            height: 60,
            decoration: BoxDecoration(color: colors.surfaceContainerHighest, borderRadius: BorderRadius.circular(8)),
            child: Center(child: _WaveformVisualizer(isRecording: isRecording.value && !isPaused.value)),
          ),
          const SizedBox(height: 16),

          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [

              _RecorderButton(
                icon: Icons.close,
                label: 'Cancel',
                color: colors.error,
                onPressed: () async {
                  await recorderService.cancelRecording();
                  onCancel();
                },
              ),

              _RecorderButton(
                icon: isPaused.value ? Icons.play_arrow : Icons.pause,
                label: isPaused.value ? 'Resume' : 'Pause',
                color: colors.primary,
                onPressed: () async {
                  if (isPaused.value) {
                    await recorderService.resumeRecording();
                    isPaused.value = false;
                  } else {
                    await recorderService.pauseRecording();
                    isPaused.value = true;
                  }
                },
              ),

              _RecorderButton(
                icon: Icons.send,
                label: 'Send',
                color: colors.primary,
                onPressed: () async {
                  final file = await recorderService.stopRecording();
                  if (file != null) {
                    onRecordingComplete(file, duration.value);
                  } else {
                    onCancel();
                  }
                },
              ),
            ],
          ),
        ],
      ),
    );
  }

  Future<void> _startRecording(VoiceRecorderService service, ValueNotifier<bool> isRecording) async {
    final path = await service.startRecording();
    if (path != null) {
      isRecording.value = true;
    }
  }

  String _formatDuration(Duration duration) {
    final minutes = duration.inMinutes.toString().padLeft(2, '0');
    final seconds = (duration.inSeconds % 60).toString().padLeft(2, '0');
    return '$minutes:$seconds';
  }
}

class _RecorderButton extends StatelessWidget {
  const _RecorderButton({required this.icon, required this.label, required this.color, required this.onPressed});

  final IconData icon;
  final String label;
  final Color color;
  final VoidCallback onPressed;

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        IconButton.filled(
          icon: Icon(icon),
          onPressed: onPressed,
          style: IconButton.styleFrom(
            backgroundColor: color,
            foregroundColor: Colors.white,
            padding: const EdgeInsets.all(16),
          ),
        ),
        const SizedBox(height: 4),
        Text(label, style: textTheme.labelSmall),
      ],
    );
  }
}

class _WaveformVisualizer extends StatefulWidget {
  const _WaveformVisualizer({required this.isRecording});

  final bool isRecording;

  @override
  State<_WaveformVisualizer> createState() => _WaveformVisualizerState();
}

class _WaveformVisualizerState extends State<_WaveformVisualizer> with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(vsync: this, duration: const Duration(milliseconds: 1000))..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;

    if (!widget.isRecording) {
      return Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: List.generate(20, (index) {
          return Container(
            width: 3,
            height: 20,
            margin: const EdgeInsets.symmetric(horizontal: 2),
            decoration: BoxDecoration(
              color: colors.onSurfaceVariant.withValues(alpha: 0.3),
              borderRadius: BorderRadius.circular(2),
            ),
          );
        }),
      );
    }

    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: List.generate(20, (index) {
            final progress = (_controller.value + index / 20) % 1.0;
            final height = 20 + (30 * (0.5 + 0.5 * (progress * 2 - 1).abs()));

            return Container(
              width: 3,
              height: height,
              margin: const EdgeInsets.symmetric(horizontal: 2),
              decoration: BoxDecoration(color: colors.primary, borderRadius: BorderRadius.circular(2)),
            );
          }),
        );
      },
    );
  }
}

================================================================
FILE: lib/features/chat/services/cloudinary_provider.dart
================================================================
import 'package:chattrix_ui/features/chat/services/cloudinary_service.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

final cloudinaryServiceProvider = Provider<CloudinaryService>((ref) {
  return CloudinaryService();
});

================================================================
FILE: lib/features/chat/services/cloudinary_service.dart
================================================================
import 'dart:io';
import 'package:chattrix_ui/core/utils/app_logger.dart';
import 'package:cloudinary_public/cloudinary_public.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';

class CloudinaryService {
  late final CloudinaryPublic _cloudinary;

  CloudinaryService() {
    final cloudName = dotenv.env['CLOUDINARY_CLOUD_NAME'];
    final uploadPreset = dotenv.env['CLOUDINARY_UPLOAD_PRESET'];

    if (cloudName == null || uploadPreset == null) {
      throw Exception('Missing Cloudinary env vars. Check your .env file.');
    }

    _cloudinary = CloudinaryPublic(cloudName, uploadPreset, cache: false);
  }

  Future<CloudinaryUploadResult> uploadImage(File file, {String? fileName}) async {
    try {
      final response = await _cloudinary.uploadFile(
        CloudinaryFile.fromFile(
          file.path,
          resourceType: CloudinaryResourceType.Image,
          folder: 'chattrix/images',
          publicId: fileName,
        ),
      );

      return CloudinaryUploadResult(
        url: response.secureUrl,
        publicId: response.publicId,
        format: response.data['format'],
        width: response.data['width'],
        height: response.data['height'],
        bytes: response.data['bytes'],
      );
    } catch (e) {
      AppLogger.error('Failed to upload image', error: e, tag: 'Cloudinary');
      rethrow;
    }
  }

  Future<CloudinaryUploadResult> uploadVideo(File file, {String? fileName}) async {
    try {
      final response = await _cloudinary.uploadFile(
        CloudinaryFile.fromFile(
          file.path,
          resourceType: CloudinaryResourceType.Video,
          folder: 'chattrix/videos',
          publicId: fileName,
        ),
      );

      final thumbnailUrl = response.secureUrl.replaceAll('.mp4', '.jpg');

      return CloudinaryUploadResult(
        url: response.secureUrl,
        thumbnailUrl: thumbnailUrl,
        publicId: response.publicId,
        format: response.data['format'],
        duration: (response.data['duration'] as num?)?.toDouble(),
        bytes: response.data['bytes'],
      );
    } catch (e) {
      AppLogger.error('Failed to upload video', error: e, tag: 'Cloudinary');
      rethrow;
    }
  }

  Future<CloudinaryUploadResult> uploadAudio(File file, {String? fileName}) async {
    try {
      final response = await _cloudinary.uploadFile(
        CloudinaryFile.fromFile(
          file.path,
          resourceType: CloudinaryResourceType.Video, // Cloudinary uses "video" for audio
          folder: 'chattrix/audio',
          publicId: fileName,
        ),
      );

      return CloudinaryUploadResult(
        url: response.secureUrl,
        publicId: response.publicId,
        format: response.data['format'],
        duration: (response.data['duration'] as num?)?.toDouble(),
        bytes: response.data['bytes'],
      );
    } catch (e) {
      AppLogger.error('Failed to upload audio', error: e, tag: 'Cloudinary');
      rethrow;
    }
  }

  Future<CloudinaryUploadResult> uploadDocument(File file, {String? fileName}) async {
    try {
      final response = await _cloudinary.uploadFile(
        CloudinaryFile.fromFile(
          file.path,
          resourceType: CloudinaryResourceType.Raw,
          folder: 'chattrix/documents',
          publicId: fileName,
        ),
      );

      return CloudinaryUploadResult(
        url: response.secureUrl,
        publicId: response.publicId,
        format: response.data['format'],
        bytes: response.data['bytes'],
      );
    } catch (e) {
      AppLogger.error('Failed to upload document', error: e, tag: 'Cloudinary');
      rethrow;
    }
  }

  Future<void> deleteFile(String publicId, CloudinaryResourceType resourceType) async {
    throw UnimplementedError('File deletion requires API secret. Implement this in your backend.');
  }
}

class CloudinaryUploadResult {
  final String url;
  final String? thumbnailUrl;
  final String publicId;
  final String? format;
  final int? width;
  final int? height;
  final double? duration;
  final int? bytes;

  CloudinaryUploadResult({
    required this.url,
    this.thumbnailUrl,
    required this.publicId,
    this.format,
    this.width,
    this.height,
    this.duration,
    this.bytes,
  });
}

================================================================
FILE: lib/features/chat/services/image_compression_provider.dart
================================================================
import 'package:chattrix_ui/features/chat/services/image_compression_service.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'image_compression_provider.g.dart';

@riverpod
ImageCompressionService imageCompressionService(Ref ref) {
  return ImageCompressionService();
}

================================================================
FILE: lib/features/chat/services/image_compression_service.dart
================================================================
import 'dart:io';

import 'package:flutter_image_compress/flutter_image_compress.dart';
import 'package:path_provider/path_provider.dart';

class ImageCompressionService {
  Future<File> compressImage(File file, {int quality = 85, int maxWidth = 1920, int maxHeight = 1920}) async {
    try {
      final originalSize = await file.length();

      final tempDir = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final targetPath = '${tempDir.path}/compressed_$timestamp.jpg';

      final result = await FlutterImageCompress.compressAndGetFile(
        file.absolute.path,
        targetPath,
        quality: quality,
        minWidth: maxWidth,
        minHeight: maxHeight,
        format: CompressFormat.jpeg,
      );

      if (result == null) {
        return file;
      }

      final compressedFile = File(result.path);
      final compressedSize = await compressedFile.length();

      if (compressedSize >= originalSize) {
        await compressedFile.delete();
        return file;
      }

      return compressedFile;
    } catch (e) {
      return file;
    }
  }

  Future<List<File>> compressImages(
    List<File> files, {
    int quality = 85,
    int maxWidth = 1920,
    int maxHeight = 1920,
  }) async {
    final compressed = <File>[];

    for (final file in files) {
      final result = await compressImage(file, quality: quality, maxWidth: maxWidth, maxHeight: maxHeight);
      compressed.add(result);
    }

    return compressed;
  }

  Future<ImageDimensions?> getImageDimensions(File file) async {
    try {
      return null;
    } catch (e) {
      return null;
    }
  }

  Future<bool> needsCompression(
    File file, {
    int maxSizeBytes = 5 * 1024 * 1024,
    int maxWidth = 1920,
    int maxHeight = 1920,
  }) async {
    try {
      final size = await file.length();
      if (size > maxSizeBytes) {
        return true;
      }

      final dimensions = await getImageDimensions(file);
      if (dimensions != null) {
        if (dimensions.width > maxWidth || dimensions.height > maxHeight) {
          return true;
        }
      }

      return false;
    } catch (e) {
      return false;
    }
  }

  Future<File> compressToTargetSize(
    File file, {
    int targetSizeBytes = 1 * 1024 * 1024,
    int maxWidth = 1920,
    int maxHeight = 1920,
  }) async {
    try {
      final originalSize = await file.length();

      if (originalSize <= targetSizeBytes) {
        return file;
      }

      final qualities = [85, 75, 65, 55, 45];

      for (final quality in qualities) {
        final compressed = await compressImage(file, quality: quality, maxWidth: maxWidth, maxHeight: maxHeight);

        final size = await compressed.length();

        if (size <= targetSizeBytes) {
          return compressed;
        }
      }

      return await compressImage(file, quality: 45, maxWidth: maxWidth, maxHeight: maxHeight);
    } catch (e) {
      return file;
    }
  }
}

class ImageDimensions {
  final int width;
  final int height;

  const ImageDimensions({required this.width, required this.height});

  double get aspectRatio => width / height;

  @override
  String toString() => '${width}x$height';
}

================================================================
FILE: lib/features/chat/services/media_picker_provider.dart
================================================================
import 'package:chattrix_ui/features/chat/services/media_picker_service.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

final mediaPickerServiceProvider = Provider<MediaPickerService>((ref) {
  return MediaPickerService();
});

================================================================
FILE: lib/features/chat/services/media_picker_service.dart
================================================================
import 'dart:io';
import 'package:chattrix_ui/core/utils/app_logger.dart';
import 'package:file_picker/file_picker.dart';
import 'package:geolocator/geolocator.dart';
import 'package:image_picker/image_picker.dart';
import 'package:permission_handler/permission_handler.dart';

class MediaPickerService {
  final ImagePicker _imagePicker = ImagePicker();

  Future<File?> pickImageFromGallery() async {
    try {
      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 1920,
        maxHeight: 1920,
        imageQuality: 85,
      );

      if (image != null) {
        return File(image.path);
      }
      return null;
    } catch (e) {
      rethrow;
    }
  }

  Future<List<File>> pickMultipleImagesFromGallery() async {
    try {
      final List<XFile> images = await _imagePicker.pickMultiImage(maxWidth: 1920, maxHeight: 1920, imageQuality: 85);

      if (images.isNotEmpty) {
        return images.map((image) => File(image.path)).toList();
      }
      return [];
    } catch (e) {
      rethrow;
    }
  }

  Future<File?> takePhoto() async {
    try {
      final status = await Permission.camera.request();
      if (!status.isGranted) {
        return null;
      }

      final XFile? image = await _imagePicker.pickImage(
        source: ImageSource.camera,
        maxWidth: 1920,
        maxHeight: 1920,
        imageQuality: 85,
      );

      if (image != null) {
        return File(image.path);
      }
      return null;
    } catch (e) {
      rethrow;
    }
  }

  Future<File?> pickVideoFromGallery() async {
    try {
      final XFile? video = await _imagePicker.pickVideo(
        source: ImageSource.gallery,
        maxDuration: const Duration(minutes: 5),
      );

      if (video != null) {
        return File(video.path);
      }
      return null;
    } catch (e) {
      rethrow;
    }
  }

  Future<File?> recordVideo() async {
    try {
      final status = await Permission.camera.request();
      if (!status.isGranted) {
        return null;
      }

      final XFile? video = await _imagePicker.pickVideo(
        source: ImageSource.camera,
        maxDuration: const Duration(minutes: 5),
      );

      if (video != null) {
        return File(video.path);
      }
      return null;
    } catch (e) {
      rethrow;
    }
  }

  Future<File?> pickAudioFile() async {
    try {
      final result = await FilePicker.platform.pickFiles(type: FileType.audio, allowMultiple: false);

      if (result != null && result.files.isNotEmpty) {
        final path = result.files.first.path;
        if (path != null) {
          return File(path);
        }
      }
      return null;
    } catch (e) {
      rethrow;
    }
  }

  Future<PickedFile?> pickDocument() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt'],
        allowMultiple: false,
      );

      if (result != null && result.files.isNotEmpty) {
        final file = result.files.first;
        final path = file.path;
        if (path != null) {
          AppLogger.debug('Document picked: $path (${file.name})', tag: 'MediaPicker');
          return PickedFile(file: File(path), name: file.name, size: file.size, extension: file.extension);
        }
      }
      return null;
    } catch (e) {
      rethrow;
    }
  }

  Future<LocationData?> getCurrentLocation() async {
    try {
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        return null;
      }

      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          return null;
        }
      }

      if (permission == LocationPermission.deniedForever) {
        return null;
      }

      final position = await Geolocator.getCurrentPosition(
        locationSettings: const LocationSettings(accuracy: LocationAccuracy.high),
      );

      return LocationData(latitude: position.latitude, longitude: position.longitude);
    } catch (e) {
      rethrow;
    }
  }
}

class PickedFile {
  final File file;
  final String name;
  final int size;
  final String? extension;

  PickedFile({required this.file, required this.name, required this.size, this.extension});
}

class LocationData {
  final double latitude;
  final double longitude;

  LocationData({required this.latitude, required this.longitude});
}

================================================================
FILE: lib/features/chat/services/voice_recorder_provider.dart
================================================================
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'voice_recorder_service.dart';

part 'voice_recorder_provider.g.dart';

@riverpod
VoiceRecorderService voiceRecorderService(Ref ref) {
  final service = VoiceRecorderService();
  ref.onDispose(() => service.dispose());
  return service;
}

================================================================
FILE: lib/features/chat/services/voice_recorder_service.dart
================================================================
import 'dart:async';
import 'dart:io';
import 'package:chattrix_ui/core/utils/app_logger.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:record/record.dart';

class VoiceRecorderService {
  final AudioRecorder _recorder = AudioRecorder();

  String? _currentRecordingPath;
  DateTime? _recordingStartTime;
  Timer? _durationTimer;
  final StreamController<Duration> _durationController = StreamController<Duration>.broadcast();

  Stream<Duration> get durationStream => _durationController.stream;

  Future<bool> isRecording() async {
    return await _recorder.isRecording();
  }

  Future<bool> requestPermission() async {
    final status = await Permission.microphone.request();
    return status.isGranted;
  }

  Future<String?> startRecording() async {
    try {
      final hasPermission = await requestPermission();
      if (!hasPermission) {
        AppLogger.warning('Microphone permission denied', tag: 'VoiceRecorder');
        return null;
      }

      if (await _recorder.isRecording()) {
        AppLogger.warning('Recorder is already active', tag: 'VoiceRecorder');
        return null;
      }

      final tempDir = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final path = '${tempDir.path}/voice_$timestamp.m4a';

      await _recorder.start(
        const RecordConfig(encoder: AudioEncoder.aacLc, bitRate: 128000, sampleRate: 44100),
        path: path,
      );

      _currentRecordingPath = path;
      _recordingStartTime = DateTime.now();
      _startDurationTimer();

      AppLogger.info('Recording started ‚Üí $path', tag: 'VoiceRecorder');
      return path;
    } catch (e, stack) {
      AppLogger.error('startRecording error', error: e, stackTrace: stack, tag: 'VoiceRecorder');
      return null;
    }
  }

  Future<File?> stopRecording() async {
    try {
      if (!await _recorder.isRecording()) {
        AppLogger.warning('stopRecording called but no active recording', tag: 'VoiceRecorder');
        return null;
      }

      final path = await _recorder.stop();
      _stopDurationTimer();

      if (path == null) {
        AppLogger.warning('Recorder stopped but path is null', tag: 'VoiceRecorder');
        return null;
      }

      final file = File(path);
      if (!await file.exists()) {
        AppLogger.warning('Recorded file not found at $path', tag: 'VoiceRecorder');
        return null;
      }

      AppLogger.success('Recording saved: $path', tag: 'VoiceRecorder');

      _currentRecordingPath = null;
      _recordingStartTime = null;

      return file;
    } catch (e, stack) {
      AppLogger.error('stopRecording error', error: e, stackTrace: stack, tag: 'VoiceRecorder');
      return null;
    }
  }

  Future<void> cancelRecording() async {
    try {
      if (await _recorder.isRecording()) {
        await _recorder.stop();
      }

      _stopDurationTimer();

      if (_currentRecordingPath != null) {
        final file = File(_currentRecordingPath!);
        if (await file.exists()) {
          await file.delete();
          AppLogger.info('Recording cancelled and deleted', tag: 'VoiceRecorder');
        }
      }

      _currentRecordingPath = null;
      _recordingStartTime = null;
    } catch (e, stack) {
      AppLogger.error('cancelRecording error', error: e, stackTrace: stack, tag: 'VoiceRecorder');
    }
  }

  Future<void> pauseRecording() async {
    try {
      if (await _recorder.isRecording()) {
        await _recorder.pause();
        _stopDurationTimer();
        AppLogger.debug('Recording paused', tag: 'VoiceRecorder');
      }
    } catch (e, stack) {
      AppLogger.error('pauseRecording error', error: e, stackTrace: stack, tag: 'VoiceRecorder');
    }
  }

  Future<void> resumeRecording() async {
    try {
      if (await _recorder.isPaused()) {
        await _recorder.resume();
        _startDurationTimer();
        AppLogger.debug('Recording resumed', tag: 'VoiceRecorder');
      }
    } catch (e, stack) {
      AppLogger.error('resumeRecording error', error: e, stackTrace: stack, tag: 'VoiceRecorder');
    }
  }

  Duration getCurrentDuration() {
    if (_recordingStartTime == null) {
      return Duration.zero;
    }
    return DateTime.now().difference(_recordingStartTime!);
  }

  void _startDurationTimer() {
    _durationTimer?.cancel();
    _durationTimer = Timer.periodic(const Duration(milliseconds: 100), (timer) {
      if (_recordingStartTime != null) {
        final duration = getCurrentDuration();
        _durationController.add(duration);
      }
    });
  }

  void _stopDurationTimer() {
    _durationTimer?.cancel();
    _durationTimer = null;
  }

  void dispose() {
    _durationTimer?.cancel();
    _durationController.close();
    _recorder.dispose();
  }
}

================================================================
FILE: lib/features/contacts/data/datasources/contact_remote_datasource_impl.dart
================================================================
import 'package:chattrix_ui/core/constants/api_constants.dart';
import 'package:chattrix_ui/core/errors/exceptions.dart';
import 'package:chattrix_ui/features/contacts/data/models/contact_model.dart';
import 'package:chattrix_ui/features/contacts/data/models/friend_request_model.dart';
import 'package:chattrix_ui/features/contacts/domain/datasources/contact_remote_datasource.dart';
import 'package:dio/dio.dart';

class ContactRemoteDataSourceImpl implements ContactRemoteDataSource {
  final Dio dio;

  ContactRemoteDataSourceImpl({required this.dio});

  @override
  Future<FriendRequestModel> sendFriendRequest({required int receiverUserId, String? nickname}) async {
    try {
      final response = await dio.post(
        ApiConstants.sendFriendRequest,
        data: {'receiverUserId': receiverUserId, if (nickname != null) 'nickname': nickname},
      );

      final data = _handleResponse(response);
      return FriendRequestModel.fromJson(data);
    } catch (e) {
      throw _handleError(e);
    }
  }

  @override
  Future<List<FriendRequestModel>> getReceivedFriendRequests() async {
    try {
      final response = await dio.get(ApiConstants.receivedFriendRequests);

      final data = _handleResponse(response);
      final List<dynamic> requestsList = data as List<dynamic>;
      return requestsList.map((json) => FriendRequestModel.fromJson(json)).toList();
    } catch (e) {
      throw _handleError(e);
    }
  }

  @override
  Future<List<FriendRequestModel>> getSentFriendRequests() async {
    try {
      final response = await dio.get(ApiConstants.sentFriendRequests);

      final data = _handleResponse(response);
      final List<dynamic> requestsList = data as List<dynamic>;
      return requestsList.map((json) => FriendRequestModel.fromJson(json)).toList();
    } catch (e) {
      throw _handleError(e);
    }
  }

  @override
  Future<void> acceptFriendRequest({required int friendRequestId}) async {
    try {
      final response = await dio.post(ApiConstants.acceptFriendRequest(friendRequestId));

      _handleResponse(response);
    } catch (e) {
      throw _handleError(e);
    }
  }

  @override
  Future<void> rejectFriendRequest({required int friendRequestId}) async {
    try {
      final response = await dio.post(ApiConstants.rejectFriendRequest(friendRequestId));

      _handleResponse(response);
    } catch (e) {
      throw _handleError(e);
    }
  }

  @override
  Future<void> cancelFriendRequest({required int friendRequestId}) async {
    try {
      final response = await dio.delete(ApiConstants.cancelFriendRequest(friendRequestId));

      _handleResponse(response);
    } catch (e) {
      throw _handleError(e);
    }
  }

  @override
  Future<List<ContactModel>> getContacts() async {
    try {
      final response = await dio.get(ApiConstants.contacts);

      final data = _handleResponse(response);
      final List<dynamic> contactsList = data as List<dynamic>;
      return contactsList.map((json) => ContactModel.fromJson(json)).toList();
    } catch (e) {
      throw _handleError(e);
    }
  }

  @override
  Future<ContactModel> getContactById(int contactId) async {
    try {
      final response = await dio.get(ApiConstants.contactById(contactId));

      final data = _handleResponse(response);
      return ContactModel.fromJson(data);
    } catch (e) {
      throw _handleError(e);
    }
  }

  @override
  Future<void> updateContactNickname({required int contactId, required String nickname}) async {
    try {
      final response = await dio.put(ApiConstants.updateContactNickname(contactId), data: {'nickname': nickname});

      _handleResponse(response);
    } catch (e) {
      throw _handleError(e);
    }
  }

  @override
  Future<void> deleteContact({required int contactId}) async {
    try {
      final response = await dio.delete(ApiConstants.deleteContact(contactId));

      _handleResponse(response);
    } catch (e) {
      throw _handleError(e);
    }
  }

  dynamic _handleResponse(Response response) {
    if (response.statusCode == 200 || response.statusCode == 201) {
      return response.data['data'];
    } else {
      throw ServerException(
        message: response.data['message'] ?? 'Unknown error',
        statusCode: response.statusCode ?? 500,
      );
    }
  }

  Exception _handleError(dynamic error) {
    if (error is DioException) {
      if (error.response != null) {
        final statusCode = error.response!.statusCode ?? 500;
        final message = error.response!.data?['message'] ?? 'An error occurred';
        return ServerException(message: message, statusCode: statusCode);
      } else {
        return NetworkException(message: error.message ?? 'Network error occurred');
      }
    }
    return ServerException(message: error.toString(), statusCode: 500);
  }
}

================================================================
FILE: lib/features/contacts/data/models/contact_model.dart
================================================================
import 'package:chattrix_ui/features/contacts/domain/entities/contact.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'contact_model.freezed.dart';
part 'contact_model.g.dart';

@freezed
abstract class ContactModel with _$ContactModel {
  const ContactModel._();

  const factory ContactModel({
    required int id,
    required int contactUserId,
    required String username,
    required String fullName,
    String? avatarUrl,
    String? nickname,
    @Default(false) bool favorite,
    @Default(false) bool online,
    DateTime? lastSeen,
    required DateTime createdAt,
  }) = _ContactModel;

  factory ContactModel.fromJson(Map<String, dynamic> json) => _$ContactModelFromJson(json);

  Contact toEntity() {
    return Contact(
      id: id,
      contactUserId: contactUserId,
      username: username,
      fullName: fullName,
      avatarUrl: avatarUrl,
      nickname: nickname,
      favorite: favorite,
      online: online,
      lastSeen: lastSeen,
      createdAt: createdAt,
    );
  }
}

================================================================
FILE: lib/features/contacts/data/models/friend_request_cancel_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'friend_request_cancel_dto.freezed.dart';
part 'friend_request_cancel_dto.g.dart';
@freezed
abstract class FriendRequestCancelDto with _$FriendRequestCancelDto {
  const factory FriendRequestCancelDto({required int requestId, required int cancelledBy}) = _FriendRequestCancelDto;

  factory FriendRequestCancelDto.fromJson(Map<String, dynamic> json) => _$FriendRequestCancelDtoFromJson(json);
}

================================================================
FILE: lib/features/contacts/data/models/friend_request_model.dart
================================================================
import 'package:chattrix_ui/features/contacts/domain/entities/friend_request.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'friend_request_model.freezed.dart';
part 'friend_request_model.g.dart';

@freezed
abstract class FriendRequestModel with _$FriendRequestModel {
  const FriendRequestModel._();

  const factory FriendRequestModel({
    required int id,
    required int userId, // Sender khi received, Receiver khi sent
    required String username,
    required String fullName,
    String? avatarUrl,
    String? nickname,
    required FriendRequestStatus status,
    @Default(false) bool online,
    required DateTime requestedAt,
    DateTime? acceptedAt,
    DateTime? rejectedAt,
  }) = _FriendRequestModel;

  factory FriendRequestModel.fromJson(Map<String, dynamic> json) => _$FriendRequestModelFromJson(json);
  FriendRequest toEntityAsReceived(int currentUserId) {
    return FriendRequest(
      id: id,
      senderUserId: userId,
      receiverUserId: currentUserId,
      senderUsername: username,
      senderFullName: fullName,
      senderAvatarUrl: avatarUrl,
      receiverUsername: '', // Not provided
      receiverFullName: '', // Not provided
      receiverAvatarUrl: null,
      nickname: nickname,
      status: status,
      createdAt: requestedAt,
      respondedAt: acceptedAt ?? rejectedAt,
    );
  }

  FriendRequest toEntityAsSent(int currentUserId) {
    return FriendRequest(
      id: id,
      senderUserId: currentUserId,
      receiverUserId: userId,
      senderUsername: '', // Not provided
      senderFullName: '', // Not provided
      senderAvatarUrl: null,
      receiverUsername: username,
      receiverFullName: fullName,
      receiverAvatarUrl: avatarUrl,
      nickname: nickname,
      status: status,
      createdAt: requestedAt,
      respondedAt: acceptedAt ?? rejectedAt,
    );
  }
}

================================================================
FILE: lib/features/contacts/data/models/friend_request_reject_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'friend_request_reject_dto.freezed.dart';
part 'friend_request_reject_dto.g.dart';
@freezed
abstract class FriendRequestRejectDto with _$FriendRequestRejectDto {
  const factory FriendRequestRejectDto({required int requestId, required int rejectedBy}) = _FriendRequestRejectDto;

  factory FriendRequestRejectDto.fromJson(Map<String, dynamic> json) => _$FriendRequestRejectDtoFromJson(json);
}

================================================================
FILE: lib/features/contacts/data/models/websocket/friend_request_cancel_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'friend_request_cancel_dto.freezed.dart';
part 'friend_request_cancel_dto.g.dart';
@freezed
abstract class FriendRequestCancelDto with _$FriendRequestCancelDto {
  const factory FriendRequestCancelDto({required int requestId, required int cancelledBy}) = _FriendRequestCancelDto;

  factory FriendRequestCancelDto.fromJson(Map<String, dynamic> json) => _$FriendRequestCancelDtoFromJson(json);
}

================================================================
FILE: lib/features/contacts/data/models/websocket/friend_request_reject_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'friend_request_reject_dto.freezed.dart';
part 'friend_request_reject_dto.g.dart';
@freezed
abstract class FriendRequestRejectDto with _$FriendRequestRejectDto {
  const factory FriendRequestRejectDto({required int requestId, required int rejectedBy}) = _FriendRequestRejectDto;

  factory FriendRequestRejectDto.fromJson(Map<String, dynamic> json) => _$FriendRequestRejectDtoFromJson(json);
}

================================================================
FILE: lib/features/contacts/data/repositories/contact_repository_impl.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/repositories/base_repository.dart';
import '../../domain/entities/contact.dart';
import '../../domain/entities/friend_request.dart';
import '../../domain/repositories/contact_repository.dart';
import '../datasources/contact_remote_datasource_impl.dart';

class ContactRepositoryImpl extends BaseRepository implements ContactRepository {
  final ContactRemoteDataSourceImpl _remoteDataSource;
  final int _currentUserId;

  ContactRepositoryImpl({required ContactRemoteDataSourceImpl remoteDataSource, required int currentUserId})
    : _remoteDataSource = remoteDataSource,
      _currentUserId = currentUserId;

  @override
  Future<Either<Failure, FriendRequest>> sendFriendRequest({required int receiverUserId, String? nickname}) async {
    return executeApiCall(() async {
      final result = await _remoteDataSource.sendFriendRequest(receiverUserId: receiverUserId, nickname: nickname);
      return result.toEntityAsSent(_currentUserId);
    });
  }

  @override
  Future<Either<Failure, List<FriendRequest>>> getReceivedFriendRequests() async {
    return executeApiCall(() async {
      final result = await _remoteDataSource.getReceivedFriendRequests();
      return result.map((model) => model.toEntityAsReceived(_currentUserId)).toList();
    });
  }

  @override
  Future<Either<Failure, List<FriendRequest>>> getSentFriendRequests() async {
    return executeApiCall(() async {
      final result = await _remoteDataSource.getSentFriendRequests();
      return result.map((model) => model.toEntityAsSent(_currentUserId)).toList();
    });
  }

  @override
  Future<Either<Failure, void>> acceptFriendRequest({required int friendRequestId}) async {
    return executeApiCall(() async {
      await _remoteDataSource.acceptFriendRequest(friendRequestId: friendRequestId);
    });
  }

  @override
  Future<Either<Failure, void>> rejectFriendRequest({required int friendRequestId}) async {
    return executeApiCall(() async {
      await _remoteDataSource.rejectFriendRequest(friendRequestId: friendRequestId);
    });
  }

  @override
  Future<Either<Failure, void>> cancelFriendRequest({required int friendRequestId}) async {
    return executeApiCall(() async {
      await _remoteDataSource.cancelFriendRequest(friendRequestId: friendRequestId);
    });
  }

  @override
  Future<Either<Failure, List<Contact>>> getContacts() async {
    return executeApiCall(() async {
      final result = await _remoteDataSource.getContacts();
      return result.map((model) => model.toEntity()).toList();
    });
  }

  @override
  Future<Either<Failure, Contact>> getContactById(int contactId) async {
    return executeApiCall(() async {
      final result = await _remoteDataSource.getContactById(contactId);
      return result.toEntity();
    });
  }

  @override
  Future<Either<Failure, void>> updateContactNickname({required int contactId, required String nickname}) async {
    return executeApiCall(() async {
      await _remoteDataSource.updateContactNickname(contactId: contactId, nickname: nickname);
    });
  }

  @override
  Future<Either<Failure, void>> deleteContact({required int contactId}) async {
    return executeApiCall(() async {
      await _remoteDataSource.deleteContact(contactId: contactId);
    });
  }
}

================================================================
FILE: lib/features/contacts/domain/datasources/contact_remote_datasource.dart
================================================================
import 'package:chattrix_ui/features/contacts/data/models/contact_model.dart';
import 'package:chattrix_ui/features/contacts/data/models/friend_request_model.dart';

abstract class ContactRemoteDataSource {
  Future<FriendRequestModel> sendFriendRequest({required int receiverUserId, String? nickname});

  Future<List<FriendRequestModel>> getReceivedFriendRequests();

  Future<List<FriendRequestModel>> getSentFriendRequests();

  Future<void> acceptFriendRequest({required int friendRequestId});

  Future<void> rejectFriendRequest({required int friendRequestId});

  Future<void> cancelFriendRequest({required int friendRequestId});

  Future<List<ContactModel>> getContacts();

  Future<ContactModel> getContactById(int contactId);

  Future<void> updateContactNickname({required int contactId, required String nickname});

  Future<void> deleteContact({required int contactId});
}

================================================================
FILE: lib/features/contacts/domain/entities/contact.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'contact.freezed.dart';

@freezed
abstract class Contact with _$Contact {
  const factory Contact({
    required int id,
    required int contactUserId, // Changed from userId to match API spec
    required String username,
    required String fullName,
    String? avatarUrl,
    String? nickname,
    @Default(false) bool favorite,
    required bool online, // Changed from isOnline to match API spec
    DateTime? lastSeen,
    required DateTime createdAt,
  }) = _Contact;
}

================================================================
FILE: lib/features/contacts/domain/entities/friend_request.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'friend_request.freezed.dart';

@freezed
abstract class FriendRequest with _$FriendRequest {
  const factory FriendRequest({
    required int id,
    required int senderUserId,
    required int receiverUserId,
    required String senderUsername,
    required String senderFullName,
    String? senderAvatarUrl,
    required String receiverUsername,
    required String receiverFullName,
    String? receiverAvatarUrl,
    String? nickname,
    required FriendRequestStatus status,
    required DateTime createdAt,
    DateTime? respondedAt,
  }) = _FriendRequest;
}

enum FriendRequestStatus {
  @JsonValue('PENDING')
  pending,
  @JsonValue('ACCEPTED')
  accepted,
  @JsonValue('REJECTED')
  rejected,
  @JsonValue('CANCELLED')
  cancelled,
}

================================================================
FILE: lib/features/contacts/domain/repositories/contact_repository.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../entities/contact.dart';
import '../entities/friend_request.dart';

abstract class ContactRepository {
  Future<Either<Failure, FriendRequest>> sendFriendRequest({required int receiverUserId, String? nickname});

  Future<Either<Failure, List<FriendRequest>>> getReceivedFriendRequests();

  Future<Either<Failure, List<FriendRequest>>> getSentFriendRequests();

  Future<Either<Failure, void>> acceptFriendRequest({required int friendRequestId});

  Future<Either<Failure, void>> rejectFriendRequest({required int friendRequestId});

  Future<Either<Failure, void>> cancelFriendRequest({required int friendRequestId});
  Future<Either<Failure, List<Contact>>> getContacts();

  Future<Either<Failure, Contact>> getContactById(int contactId);

  Future<Either<Failure, void>> updateContactNickname({required int contactId, required String nickname});

  Future<Either<Failure, void>> deleteContact({required int contactId});
}

================================================================
FILE: lib/features/contacts/domain/usecases/accept_friend_request_usecase.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../repositories/contact_repository.dart';

class AcceptFriendRequestUseCase {
  final ContactRepository repository;

  AcceptFriendRequestUseCase(this.repository);

  Future<Either<Failure, void>> call({required int friendRequestId}) {
    return repository.acceptFriendRequest(friendRequestId: friendRequestId);
  }
}

================================================================
FILE: lib/features/contacts/domain/usecases/cancel_friend_request_usecase.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../repositories/contact_repository.dart';

class CancelFriendRequestUseCase {
  final ContactRepository repository;

  CancelFriendRequestUseCase(this.repository);

  Future<Either<Failure, void>> call({required int friendRequestId}) {
    return repository.cancelFriendRequest(friendRequestId: friendRequestId);
  }
}

================================================================
FILE: lib/features/contacts/domain/usecases/get_contacts_usecase.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../entities/contact.dart';
import '../repositories/contact_repository.dart';

class GetContactsUseCase {
  final ContactRepository repository;

  GetContactsUseCase(this.repository);

  Future<Either<Failure, List<Contact>>> call() {
    return repository.getContacts();
  }
}

================================================================
FILE: lib/features/contacts/domain/usecases/get_received_friend_requests_usecase.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../entities/friend_request.dart';
import '../repositories/contact_repository.dart';

class GetReceivedFriendRequestsUseCase {
  final ContactRepository repository;

  GetReceivedFriendRequestsUseCase(this.repository);

  Future<Either<Failure, List<FriendRequest>>> call() {
    return repository.getReceivedFriendRequests();
  }
}

================================================================
FILE: lib/features/contacts/domain/usecases/get_sent_friend_requests_usecase.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../entities/friend_request.dart';
import '../repositories/contact_repository.dart';

class GetSentFriendRequestsUseCase {
  final ContactRepository repository;

  GetSentFriendRequestsUseCase(this.repository);

  Future<Either<Failure, List<FriendRequest>>> call() {
    return repository.getSentFriendRequests();
  }
}

================================================================
FILE: lib/features/contacts/domain/usecases/reject_friend_request_usecase.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../repositories/contact_repository.dart';

class RejectFriendRequestUseCase {
  final ContactRepository repository;

  RejectFriendRequestUseCase(this.repository);

  Future<Either<Failure, void>> call({required int friendRequestId}) {
    return repository.rejectFriendRequest(friendRequestId: friendRequestId);
  }
}

================================================================
FILE: lib/features/contacts/domain/usecases/send_friend_request_usecase.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../entities/friend_request.dart';
import '../repositories/contact_repository.dart';

class SendFriendRequestUseCase {
  final ContactRepository repository;

  SendFriendRequestUseCase(this.repository);

  Future<Either<Failure, FriendRequest>> call({required int receiverUserId, String? nickname}) {
    return repository.sendFriendRequest(receiverUserId: receiverUserId, nickname: nickname);
  }
}

================================================================
FILE: lib/features/contacts/presentation/pages/contacts_demo_page.dart
================================================================
import 'package:flutter/material.dart';

enum RequestStatus { pending, sent }

class UserContactMock {
  final String id;
  final String name;
  final String avatarUrl;
  final bool isOnline;
  final String? bio;

  UserContactMock({required this.id, required this.name, required this.avatarUrl, this.isOnline = false, this.bio});
}

class FriendRequestMock {
  final UserContactMock user;
  final String time;
  final RequestStatus status;
  final int mutualFriends;

  FriendRequestMock({required this.user, required this.time, required this.status, this.mutualFriends = 0});
}
final List<UserContactMock> _allContacts = [
  UserContactMock(id: '1', name: 'An Nguyen', avatarUrl: 'https://i.pravatar.cc/150?u=101', isOnline: true),
  UserContactMock(id: '2', name: 'Anh Tu·∫•n', avatarUrl: 'https://i.pravatar.cc/150?u=102', bio: 'Work hard play hard'),
  UserContactMock(id: '3', name: 'B·∫£o B·∫£o', avatarUrl: 'https://i.pravatar.cc/150?u=103'),
  UserContactMock(id: '4', name: 'B√¨nh Gold', avatarUrl: 'https://i.pravatar.cc/150?u=104', isOnline: true),
  UserContactMock(id: '5', name: 'C∆∞·ªùng ƒê√¥ La', avatarUrl: 'https://i.pravatar.cc/150?u=105'),
  UserContactMock(id: '6', name: 'D≈©ng CT', avatarUrl: 'https://i.pravatar.cc/150?u=106', isOnline: true),
  UserContactMock(id: '7', name: 'ƒê·∫°t Villa', avatarUrl: 'https://i.pravatar.cc/150?u=107'),
  UserContactMock(id: '8', name: 'H∆∞∆°ng Giang', avatarUrl: 'https://i.pravatar.cc/150?u=108'),
  UserContactMock(id: '9', name: 'Kh√° B·∫£nh', avatarUrl: 'https://i.pravatar.cc/150?u=109'),
  UserContactMock(id: '10', name: 'Long N√≥n L√°', avatarUrl: 'https://i.pravatar.cc/150?u=110', bio: 'Rap vi·ªát m√πa 3'),
];
final List<FriendRequestMock> _requests = [
  FriendRequestMock(
    user: UserContactMock(id: 'r1', name: 'S∆°n T√πng MTP', avatarUrl: 'https://i.pravatar.cc/150?u=201'),
    time: '2 ng√†y tr∆∞·ªõc',
    status: RequestStatus.pending,
    mutualFriends: 15,
  ),
  FriendRequestMock(
    user: UserContactMock(id: 'r2', name: 'Jack 97', avatarUrl: 'https://i.pravatar.cc/150?u=202'),
    time: '1 tu·∫ßn tr∆∞·ªõc',
    status: RequestStatus.pending,
    mutualFriends: 2,
  ),
  FriendRequestMock(
    user: UserContactMock(id: 'r3', name: 'ƒêen V√¢u', avatarUrl: 'https://i.pravatar.cc/150?u=203'),
    time: 'V·ª´a xong',
    status: RequestStatus.sent,
    mutualFriends: 5,
  ),
];
class ChatMock {
  final String id;
  final String name;
  final String message;
  final String time;
  final String avatarUrl;
  final int unreadCount;
  final bool isOnline;
  final bool isGroup;

  ChatMock({
    required this.id,
    required this.name,
    required this.message,
    required this.time,
    required this.avatarUrl,
    this.unreadCount = 0,
    this.isOnline = false,
    this.isGroup = false,
  });
}
List<ChatMock> get _groups {
  return [
    ChatMock(
      id: '4',
      name: 'Team Project A',
      message: 'Jacob: I will handle the backend part.',
      time: 'Yesterday',
      avatarUrl: 'https://i.pravatar.cc/150?u=4',
      unreadCount: 5,
      isOnline: true,
      isGroup: true,
    ),
    ChatMock(
      id: '8',
      name: 'Dev Team',
      message: 'Server is down! üö®',
      time: 'Sun',
      avatarUrl: 'https://i.pravatar.cc/150?u=8',
      unreadCount: 99,
      isGroup: true,
    ),
  ];
}
class ContactListDemoPage extends StatefulWidget {
  const ContactListDemoPage({super.key});

  @override
  State<ContactListDemoPage> createState() => _ContactListDemoPageState();
}

class _ContactListDemoPageState extends State<ContactListDemoPage> {
  Map<String, List<UserContactMock>> get _groupedContacts {
    Map<String, List<UserContactMock>> data = {};
    for (var contact in _allContacts) {
      String firstLetter = contact.name[0].toUpperCase();
      if (!data.containsKey(firstLetter)) {
        data[firstLetter] = [];
      }
      data[firstLetter]!.add(contact);
    }
    return data;
  }

  void _showAddContactSheet() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => const AddContactSheet(),
    );
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final backgroundColor = isDark ? Colors.black : Colors.white;
    final surfaceColor = isDark ? const Color(0xFF1C1C1E) : const Color(0xFFF3F4F6);

    final groupedData = _groupedContacts;
    final sortedKeys = groupedData.keys.toList()..sort();

    return Scaffold(
      backgroundColor: backgroundColor,
      body: CustomScrollView(
        physics: const BouncingScrollPhysics(),
        slivers: [
          SliverAppBar(
            backgroundColor: backgroundColor,
            surfaceTintColor: Colors.transparent,
            pinned: true,
            expandedHeight: 100.0,
            flexibleSpace: FlexibleSpaceBar(
              titlePadding: const EdgeInsets.only(left: 16, bottom: 16),
              title: Text(
                'Danh b·∫°',
                style: TextStyle(
                  color: isDark ? Colors.white : Colors.black,
                  fontWeight: FontWeight.w800,
                  fontSize: 28, // Font size l·ªõn gi·ªëng iOS style
                ),
              ),
            ),
            actions: [
              Container(
                margin: const EdgeInsets.only(right: 16),
                decoration: BoxDecoration(color: surfaceColor, shape: BoxShape.circle),
                child: IconButton(
                  icon: Icon(Icons.person_add_rounded, color: isDark ? Colors.white : Colors.black),
                  onPressed: _showAddContactSheet,
                ),
              ),
            ],
          ),
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 0),
              child: Container(
                height: 46,
                decoration: BoxDecoration(
                  color: surfaceColor,
                  borderRadius: BorderRadius.circular(30), // Bo tr√≤n 30px gi·ªëng Chat
                ),
                child: Row(
                  children: [
                    const SizedBox(width: 16),
                    Icon(Icons.search, color: Colors.grey.shade500, size: 24),
                    const SizedBox(width: 8),
                    Text('T√¨m ki·∫øm...', style: TextStyle(color: Colors.grey.shade500, fontSize: 16)),
                  ],
                ),
              ),
            ),
          ),

          const SliverToBoxAdapter(child: SizedBox(height: 16)),
          SliverToBoxAdapter(
            child: Column(
              children: [
                _buildMenuItem(
                  context,
                  icon: Icons.people_alt_rounded,
                  color: Colors.blueAccent,
                  title: 'L·ªùi m·ªùi k·∫øt b·∫°n',
                  badgeCount: _requests.where((r) => r.status == RequestStatus.pending).length,
                  onTap: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const FriendRequestPage())),
                  isDark: isDark,
                  surfaceColor: surfaceColor,
                ),
                _buildMenuItem(
                  context,
                  icon: Icons.groups_rounded,
                  color: Colors.purpleAccent,
                  title: 'Nh√≥m chat',
                  onTap: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const GroupListPage())),
                  isDark: isDark,
                  surfaceColor: surfaceColor,
                ),
              ],
            ),
          ),

          const SliverToBoxAdapter(child: Divider(height: 32, thickness: 0.5)),
          SliverList(
            delegate: SliverChildBuilderDelegate((context, index) {
              final letter = sortedKeys[index];
              final contacts = groupedData[letter]!;

              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                    child: Text(
                      letter,
                      style: TextStyle(color: Colors.grey.shade500, fontWeight: FontWeight.bold, fontSize: 14),
                    ),
                  ),
                  ...contacts.map((contact) => _buildContactItem(contact, isDark, surfaceColor)),
                ],
              );
            }, childCount: sortedKeys.length),
          ),

          const SliverPadding(padding: EdgeInsets.only(bottom: 40)),
        ],
      ),
    );
  }
  Widget _buildMenuItem(
    BuildContext context, {
    required IconData icon,
    required Color color,
    required String title,
    int badgeCount = 0,
    required VoidCallback onTap,
    required bool isDark,
    required Color surfaceColor,
  }) {
    return InkWell(
      onTap: onTap,
      splashColor: Colors.transparent,
      highlightColor: Colors.transparent,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(color: color.withValues(alpha: 0.1), shape: BoxShape.circle),
              child: Icon(icon, color: color, size: 22),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Text(
                title,
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: isDark ? Colors.white : Colors.black,
                ),
              ),
            ),
            if (badgeCount > 0)
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                decoration: BoxDecoration(color: const Color(0xFFEF4444), borderRadius: BorderRadius.circular(10)),
                child: Text(
                  '$badgeCount',
                  style: const TextStyle(color: Colors.white, fontSize: 12, fontWeight: FontWeight.bold),
                ),
              )
            else
              Icon(Icons.chevron_right_rounded, color: Colors.grey.shade400),
          ],
        ),
      ),
    );
  }
  Widget _buildContactItem(UserContactMock contact, bool isDark, Color surfaceColor) {
    return InkWell(
      onTap: () {
      },
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
        child: Row(
          children: [
            Stack(
              children: [
                CircleAvatar(radius: 26, backgroundImage: NetworkImage(contact.avatarUrl)),
                if (contact.isOnline)
                  Positioned(
                    right: 0,
                    bottom: 0,
                    child: Container(
                      width: 14,
                      height: 14,
                      decoration: BoxDecoration(
                        color: const Color(0xFF31A24C),
                        shape: BoxShape.circle,
                        border: Border.all(color: isDark ? Colors.black : Colors.white, width: 2),
                      ),
                    ),
                  ),
              ],
            ),
            const SizedBox(width: 14),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    contact.name,
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w600,
                      color: isDark ? Colors.white : Colors.black,
                    ),
                  ),
                  if (contact.bio != null)
                    Text(
                      contact.bio!,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(fontSize: 13, color: Colors.grey.shade500),
                    ),
                ],
              ),
            ),
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                _buildActionButton(Icons.message_rounded, Colors.blueAccent, isDark, surfaceColor, () {}),
                const SizedBox(width: 8),
                _buildActionButton(
                  Icons.call_rounded,
                  isDark ? Colors.white : Colors.black87,
                  isDark,
                  surfaceColor,
                  () {},
                ),
                const SizedBox(width: 8),
                _buildActionButton(
                  Icons.videocam_rounded,
                  isDark ? Colors.white : Colors.black87,
                  isDark,
                  surfaceColor,
                  () {},
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildActionButton(IconData icon, Color color, bool isDark, Color surfaceColor, VoidCallback onTap) {
    return Container(
      width: 36,
      height: 36,
      decoration: BoxDecoration(color: isDark ? Colors.grey.shade800 : Colors.grey.shade200, shape: BoxShape.circle),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(18),
        child: Icon(icon, size: 18, color: color),
      ),
    );
  }
}
class FriendRequestPage extends StatefulWidget {
  const FriendRequestPage({super.key});

  @override
  State<FriendRequestPage> createState() => _FriendRequestPageState();
}

class _FriendRequestPageState extends State<FriendRequestPage> with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final bgColor = isDark ? Colors.black : Colors.white;

    final receivedList = _requests.where((r) => r.status == RequestStatus.pending).toList();
    final sentList = _requests.where((r) => r.status == RequestStatus.sent).toList();

    return Scaffold(
      backgroundColor: bgColor,
      appBar: AppBar(
        backgroundColor: bgColor,
        title: Text(
          'L·ªùi m·ªùi k·∫øt b·∫°n',
          style: TextStyle(color: isDark ? Colors.white : Colors.black, fontWeight: FontWeight.bold),
        ),
        leading: BackButton(color: isDark ? Colors.white : Colors.black),
        bottom: TabBar(
          controller: _tabController,
          labelColor: Colors.blueAccent,
          unselectedLabelColor: Colors.grey,
          indicatorColor: Colors.blueAccent,
          tabs: [
            Tab(text: 'ƒê√£ nh·∫≠n (${receivedList.length})'),
            Tab(text: 'ƒê√£ g·ª≠i (${sentList.length})'),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildRequestList(receivedList, isReceived: true, isDark: isDark),
          _buildRequestList(sentList, isReceived: false, isDark: isDark),
        ],
      ),
    );
  }

  Widget _buildRequestList(List<FriendRequestMock> list, {required bool isReceived, required bool isDark}) {
    if (list.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.mail_outline_rounded, size: 60, color: Colors.grey.shade300),
            const SizedBox(height: 16),
            Text('Kh√¥ng c√≥ l·ªùi m·ªùi n√†o', style: TextStyle(color: Colors.grey.shade500)),
          ],
        ),
      );
    }
    return ListView.separated(
      padding: const EdgeInsets.all(16),
      itemCount: list.length,
      separatorBuilder: (_, __) => const SizedBox(height: 20),
      itemBuilder: (context, index) {
        final req = list[index];
        return Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            CircleAvatar(radius: 36, backgroundImage: NetworkImage(req.user.avatarUrl)),
            const SizedBox(width: 14),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        req.user.name,
                        style: TextStyle(
                          fontSize: 17,
                          fontWeight: FontWeight.bold,
                          color: isDark ? Colors.white : Colors.black,
                        ),
                      ),
                      Text(req.time, style: TextStyle(fontSize: 12, color: Colors.grey.shade500)),
                    ],
                  ),
                  const SizedBox(height: 4),
                  if (req.mutualFriends > 0)
                    Text('${req.mutualFriends} b·∫°n chung', style: TextStyle(color: Colors.grey.shade500, fontSize: 13)),
                  const SizedBox(height: 12),
                  Row(
                    children: [
                      Expanded(
                        child: ElevatedButton(
                          onPressed: () {},
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.blueAccent,
                            foregroundColor: Colors.white,
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                            padding: const EdgeInsets.symmetric(vertical: 10),
                          ),
                          child: Text(
                            isReceived ? 'Ch·∫•p nh·∫≠n' : 'H·ªßy l·ªùi m·ªùi',
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                        ),
                      ),
                      if (isReceived) ...[
                        const SizedBox(width: 10),
                        Expanded(
                          child: ElevatedButton(
                            onPressed: () {},
                            style: ElevatedButton.styleFrom(
                              backgroundColor: isDark ? Colors.grey.shade800 : Colors.grey.shade200,
                              foregroundColor: isDark ? Colors.white : Colors.black,
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                              padding: const EdgeInsets.symmetric(vertical: 10),
                              elevation: 0,
                            ),
                            child: const Text('X√≥a', style: TextStyle(fontWeight: FontWeight.bold)),
                          ),
                        ),
                      ],
                    ],
                  ),
                ],
              ),
            ),
          ],
        );
      },
    );
  }
}
class GroupListPage extends StatelessWidget {
  const GroupListPage({super.key});

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final bgColor = isDark ? Colors.black : Colors.white;

    return Scaffold(
      backgroundColor: bgColor,
      appBar: AppBar(
        backgroundColor: bgColor,
        title: Text(
          'Nh√≥m c·ªßa b·∫°n',
          style: TextStyle(color: isDark ? Colors.white : Colors.black, fontWeight: FontWeight.bold),
        ),
        leading: BackButton(color: isDark ? Colors.white : Colors.black),
        actions: [
          TextButton(
            onPressed: () {},
            child: const Text('T·∫°o m·ªõi', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
          ),
        ],
      ),
      body: _groups.isEmpty
          ? Center(
              child: Text("Ch∆∞a tham gia nh√≥m n√†o", style: TextStyle(color: Colors.grey.shade500)),
            )
          : ListView.builder(
              itemCount: _groups.length,
              itemBuilder: (context, index) {
                final group = _groups[index];
                return ListTile(
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  leading: Stack(
                    children: [
                      CircleAvatar(radius: 28, backgroundImage: NetworkImage(group.avatarUrl)),
                      Positioned(
                        right: 0,
                        bottom: 0,
                        child: Container(
                          padding: const EdgeInsets.all(2),
                          decoration: BoxDecoration(color: bgColor, shape: BoxShape.circle),
                          child: const Icon(Icons.group_rounded, size: 14, color: Colors.blueAccent),
                        ),
                      ),
                    ],
                  ),
                  title: Text(
                    group.name,
                    style: TextStyle(
                      fontWeight: FontWeight.w600,
                      fontSize: 16,
                      color: isDark ? Colors.white : Colors.black,
                    ),
                  ),
                  subtitle: Text("Ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y: ${group.time}", style: TextStyle(color: Colors.grey.shade500)),
                );
              },
            ),
    );
  }
}
class AddContactSheet extends StatelessWidget {
  const AddContactSheet({super.key});

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final bgColor = isDark ? const Color(0xFF1C1C1E) : Colors.white;
    final textColor = isDark ? Colors.white : Colors.black;

    return Container(
      height: MediaQuery.of(context).size.height * 0.9,
      decoration: BoxDecoration(
        color: bgColor,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('H·ªßy', style: TextStyle(fontSize: 16)),
                ),
                Text(
                  'Th√™m li√™n h·ªá m·ªõi',
                  style: TextStyle(fontSize: 17, fontWeight: FontWeight.bold, color: textColor),
                ),
                TextButton(
                  onPressed: () {},
                  child: const Text('Th√™m', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                ),
              ],
            ),
          ),
          const Divider(height: 1),
          Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              children: [
                Container(
                  width: 80,
                  height: 80,
                  decoration: BoxDecoration(
                    color: isDark ? Colors.grey.shade800 : Colors.grey.shade200,
                    shape: BoxShape.circle,
                  ),
                  child: Icon(Icons.camera_alt_rounded, size: 30, color: Colors.grey.shade400),
                ),
                const SizedBox(height: 24),
                _buildTextField('H·ªç', isDark),
                const SizedBox(height: 12),
                _buildTextField('T√™n', isDark),
                const SizedBox(height: 12),
                _buildTextField('S·ªë ƒëi·ªán tho·∫°i', isDark, keyboardType: TextInputType.phone),
              ],
            ),
          ),
          ListTile(
            leading: Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(color: Colors.blueAccent.withValues(alpha: 0.1), shape: BoxShape.circle),
              child: const Icon(Icons.qr_code_scanner_rounded, color: Colors.blueAccent),
            ),
            title: Text(
              'Qu√©t m√£ QR',
              style: TextStyle(color: textColor, fontWeight: FontWeight.w500),
            ),
            trailing: Icon(Icons.arrow_forward_ios_rounded, size: 16, color: Colors.grey.shade400),
            onTap: () {},
          ),
        ],
      ),
    );
  }

  Widget _buildTextField(String hint, bool isDark, {TextInputType? keyboardType}) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      decoration: BoxDecoration(
        color: isDark ? const Color(0xFF2C2C2E) : Colors.grey.shade100,
        borderRadius: BorderRadius.circular(12),
      ),
      child: TextField(
        keyboardType: keyboardType,
        style: TextStyle(color: isDark ? Colors.white : Colors.black),
        decoration: InputDecoration(
          border: InputBorder.none,
          hintText: hint,
          hintStyle: TextStyle(color: Colors.grey.shade500),
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/contacts/presentation/pages/contacts_page.dart
================================================================
import 'package:chattrix_ui/core/widgets/user_avatar.dart';
import 'package:flutter/material.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
class ContactEntity {
  final String id;
  final String name;
  final String? avatarUrl;
  final String status;
  final bool isOnline;
  ContactEntity({required this.id, required this.name, this.avatarUrl, required this.status, this.isOnline = false});
}

class GroupEntity {
  final String id;
  final String name;
  final int memberCount;
  GroupEntity({required this.id, required this.name, required this.memberCount});
}

class ContactsPage extends ConsumerStatefulWidget {
  const ContactsPage({super.key});

  @override
  ConsumerState<ContactsPage> createState() => _ContactsPageState();
}

class _ContactsPageState extends ConsumerState<ContactsPage> {
  String _searchQuery = "";
  final TextEditingController _searchController = TextEditingController();

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    return DefaultTabController(
      length: 2,
      child: Scaffold(
        backgroundColor: colors.surface, // ƒê·ªïi n·ªÅn ch√≠nh th√†nh surface cho li·ªÅn m·∫°ch
        appBar: AppBar(
          title: Text('Contacts', style: textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold)),
          backgroundColor: colors.surface,
          elevation: 0,
          actions: [IconButton(onPressed: () {}, icon: const Icon(Icons.person_add_alt_1_rounded))],
        ),
        body: Column(
          children: [
            Container(
              color: colors.surface,
              padding: const EdgeInsets.fromLTRB(16, 0, 16, 8),
              child: TextField(
                controller: _searchController,
                onChanged: (value) {
                  setState(() {
                    _searchQuery = value;
                  });
                },
                decoration: InputDecoration(
                  hintText: 'Search friends or groups...',
                  prefixIcon: Icon(Icons.search, color: colors.outline),
                  filled: true,
                  fillColor: colors.surfaceContainerLow,
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide.none),
                  contentPadding: const EdgeInsets.symmetric(vertical: 0),
                  suffixIcon: _searchQuery.isNotEmpty
                      ? IconButton(
                          icon: const Icon(Icons.clear, size: 20),
                          onPressed: () {
                            _searchController.clear();
                            setState(() => _searchQuery = "");
                          },
                        )
                      : null,
                ),
              ),
            ),
            Container(
              color: colors.surface,
              child: TabBar(
                labelColor: colors.primary,
                unselectedLabelColor: colors.onSurfaceVariant,
                indicatorColor: colors.primary,
                indicatorSize: TabBarIndicatorSize.tab,
                dividerColor: colors.outlineVariant.withValues(alpha: 0.5),
                labelStyle: const TextStyle(fontWeight: FontWeight.bold, fontSize: 15),
                tabs: const [
                  Tab(text: "Friends"),
                  Tab(text: "Groups"),
                ],
              ),
            ),
            Expanded(
              child: Container(
                color: colors.surfaceContainerLow, // M√†u n·ªÅn x√°m nh·∫°t cho ph·∫ßn list
                child: TabBarView(
                  children: [
                    _FriendsTab(searchQuery: _searchQuery), // Truy·ªÅn query
                    _GroupsTab(searchQuery: _searchQuery), // Truy·ªÅn query
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
class _FriendsTab extends StatelessWidget {
  final String searchQuery; // Nh·∫≠n t·ª´ kho√° t√¨m ki·∫øm
  const _FriendsTab({required this.searchQuery});

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    final List<ContactEntity> allContacts = [
      ContactEntity(id: '1', name: 'An Nguyen', status: 'Mobile Developer', isOnline: true),
      ContactEntity(id: '2', name: 'Binh Tran', status: 'Sleeping...', isOnline: false),
      ContactEntity(id: '3', name: 'Cuong Le', status: 'At work', isOnline: true),
      ContactEntity(id: '4', name: 'David Beo', status: 'Gym', isOnline: false),
    ];
    final filteredContacts = allContacts.where((contact) {
      return contact.name.toLowerCase().contains(searchQuery.toLowerCase());
    }).toList();
    final Map<String, List<ContactEntity>> groupedContacts = {};
    for (var contact in filteredContacts) {
      final String firstLetter = contact.name[0].toUpperCase();
      if (!groupedContacts.containsKey(firstLetter)) groupedContacts[firstLetter] = [];
      groupedContacts[firstLetter]!.add(contact);
    }
    final sortedKeys = groupedContacts.keys.toList()..sort();

    return SingleChildScrollView(
      padding: const EdgeInsets.only(top: 16),
      child: Column(
        children: [
          if (searchQuery.isEmpty)
            _SectionCard(
              colors: colors,
              children: [
                _MenuTile(
                  icon: FontAwesomeIcons.userGroup,
                  label: 'Friend Requests',
                  colors: colors,
                  textTheme: textTheme,
                  badgeCount: 3,
                ),
              ],
            ),

          if (searchQuery.isEmpty) const SizedBox(height: 24),

          if (filteredContacts.isEmpty)
            Padding(
              padding: const EdgeInsets.only(top: 40),
              child: Text("No friends found", style: TextStyle(color: colors.outline)),
            )
          else
            ...sortedKeys.map(
              (key) => Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Padding(
                    padding: const EdgeInsets.only(left: 32, bottom: 8),
                    child: Text(
                      key,
                      style: TextStyle(color: colors.primary, fontWeight: FontWeight.bold),
                    ),
                  ),
                  _SectionCard(
                    colors: colors,
                    children: groupedContacts[key]!
                        .map((c) => _ContactTile(contact: c, colors: colors, textTheme: textTheme))
                        .toList(),
                  ),
                  const SizedBox(height: 16),
                ],
              ),
            ),

          const SizedBox(height: 40),
        ],
      ),
    );
  }
}
class _GroupsTab extends StatelessWidget {
  final String searchQuery;
  const _GroupsTab({required this.searchQuery});

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    final List<GroupEntity> allGroups = [
      GroupEntity(id: '1', name: 'Flutter Devs VN', memberCount: 1540),
      GroupEntity(id: '2', name: 'Family ‚ù§Ô∏è', memberCount: 6),
      GroupEntity(id: '3', name: 'Project Chattrix', memberCount: 4),
    ];
    final filteredGroups = allGroups.where((group) {
      return group.name.toLowerCase().contains(searchQuery.toLowerCase());
    }).toList();

    return SingleChildScrollView(
      padding: const EdgeInsets.only(top: 16),
      child: Column(
        children: [
          if (searchQuery.isEmpty)
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 0, 16, 24),
              child: ElevatedButton.icon(
                onPressed: () {},
                icon: const Icon(Icons.add),
                label: const Text("Create New Group"),
                style: ElevatedButton.styleFrom(backgroundColor: colors.primary, foregroundColor: colors.onPrimary),
              ),
            ),

          if (filteredGroups.isEmpty)
            Padding(
              padding: const EdgeInsets.only(top: 40),
              child: Text("No groups found", style: TextStyle(color: colors.outline)),
            )
          else
            _SectionCard(
              colors: colors,
              children: filteredGroups
                  .map(
                    (group) => ListTile(
                      leading: Container(
                        width: 40,
                        height: 40,
                        decoration: BoxDecoration(
                          color: colors.primaryContainer,
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: Icon(Icons.groups, color: colors.onPrimaryContainer),
                      ),
                      title: Text(group.name, style: const TextStyle(fontWeight: FontWeight.w600)),
                      subtitle: Text('${group.memberCount} members'),
                      trailing: Icon(Icons.chevron_right, color: colors.outline),
                    ),
                  )
                  .toList(),
            ),
        ],
      ),
    );
  }
}
class _SectionCard extends StatelessWidget {
  final List<Widget> children;
  final ColorScheme colors;
  const _SectionCard({required this.children, required this.colors});
  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [BoxShadow(color: Colors.black.withValues(alpha: 0.02), blurRadius: 10, offset: const Offset(0, 4))],
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(16),
        child: Column(children: children),
      ),
    );
  }
}

class _MenuTile extends StatelessWidget {
  final IconData icon;
  final String label;
  final ColorScheme colors;
  final TextTheme textTheme;
  final int badgeCount;
  const _MenuTile({
    required this.icon,
    required this.label,
    required this.colors,
    required this.textTheme,
    this.badgeCount = 0,
  });
  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: FaIcon(icon, size: 18),
      title: Text(label),
      trailing: badgeCount > 0
          ? CircleAvatar(
              radius: 10,
              backgroundColor: Colors.red,
              child: Text("$badgeCount", style: const TextStyle(fontSize: 10, color: Colors.white)),
            )
          : null,
    );
  }
}

class _ContactTile extends StatelessWidget {
  final ContactEntity contact;
  final ColorScheme colors;
  final TextTheme textTheme;
  const _ContactTile({required this.contact, required this.colors, required this.textTheme});
  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: UserAvatar(displayName: contact.name, avatarUrl: contact.avatarUrl, radius: 20),
      title: Text(contact.name, style: const TextStyle(fontWeight: FontWeight.w600)),
      subtitle: Text(contact.status),
    );
  }
}

================================================================
FILE: lib/features/contacts/presentation/pages/friend_requests_page.dart
================================================================
import 'package:chattrix_ui/core/widgets/user_avatar.dart';
import 'package:chattrix_ui/features/contacts/presentation/providers/contact_providers.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class FriendRequestsPage extends ConsumerStatefulWidget {
  const FriendRequestsPage({super.key});

  @override
  ConsumerState<FriendRequestsPage> createState() => _FriendRequestsPageState();
}

class _FriendRequestsPageState extends ConsumerState<FriendRequestsPage> {
  @override
  void initState() {
    super.initState();
    Future.microtask(() {
      ref.read(contactProvider.notifier).loadReceivedFriendRequests();
      ref.read(contactProvider.notifier).loadSentFriendRequests();
    });
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(contactProvider);
    final colorScheme = Theme.of(context).colorScheme;

    return DefaultTabController(
      length: 2,
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Friend Requests'),
          bottom: const TabBar(
            tabs: [
              Tab(text: 'Received'),
              Tab(text: 'Sent'),
            ],
          ),
        ),
        body: TabBarView(
          children: [
            _buildReceivedRequestsList(state, colorScheme),
            _buildSentRequestsList(state, colorScheme),
          ],
        ),
      ),
    );
  }

  Widget _buildReceivedRequestsList(ContactState state, ColorScheme colorScheme) {
    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (state.receivedRequests.isEmpty) {
      return const Center(child: Text('No received friend requests'));
    }

    return ListView.builder(
      itemCount: state.receivedRequests.length,
      itemBuilder: (context, index) {
        final request = state.receivedRequests[index];
        return Card(
          margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: ListTile(
            leading: UserAvatar(displayName: request.senderFullName, avatarUrl: request.senderAvatarUrl, radius: 20),
            title: Text(request.senderFullName),
            subtitle: Text('@${request.senderUsername}'),
            trailing: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                IconButton(
                  icon: const Icon(Icons.check, color: Colors.green),
                  onPressed: () async {
                    final success = await ref.read(contactProvider.notifier).acceptFriendRequest(request.id);
                    if (success && mounted) {
                      ScaffoldMessenger.of(
                        context,
                      ).showSnackBar(const SnackBar(content: Text('Friend request accepted')));
                    }
                  },
                ),
                IconButton(
                  icon: const Icon(Icons.close, color: Colors.red),
                  onPressed: () async {
                    final success = await ref.read(contactProvider.notifier).rejectFriendRequest(request.id);
                    if (success && mounted) {
                      ScaffoldMessenger.of(
                        context,
                      ).showSnackBar(const SnackBar(content: Text('Friend request rejected')));
                    }
                  },
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildSentRequestsList(ContactState state, ColorScheme colorScheme) {
    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (state.sentRequests.isEmpty) {
      return const Center(child: Text('No sent friend requests'));
    }

    return ListView.builder(
      itemCount: state.sentRequests.length,
      itemBuilder: (context, index) {
        final request = state.sentRequests[index];
        return Card(
          margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: ListTile(
            leading: UserAvatar(
              displayName: request.receiverFullName,
              avatarUrl: request.receiverAvatarUrl,
              radius: 20,
            ),
            title: Text(request.receiverFullName),
            subtitle: Text('@${request.receiverUsername}'),
            trailing: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Chip(
                  label: Text(
                    request.status.name.toUpperCase(),
                    style: TextStyle(color: colorScheme.onSecondaryContainer, fontSize: 12),
                  ),
                  backgroundColor: colorScheme.secondaryContainer,
                ),
                const SizedBox(width: 8),
                IconButton(
                  icon: const Icon(Icons.cancel, color: Colors.red),
                  onPressed: () async {
                    final success = await ref.read(contactProvider.notifier).cancelFriendRequest(request.id);
                    if (success && mounted) {
                      ScaffoldMessenger.of(
                        context,
                      ).showSnackBar(const SnackBar(content: Text('Friend request cancelled')));
                    }
                  },
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

================================================================
FILE: lib/features/contacts/presentation/pages/send_friend_request_page.dart
================================================================
import 'package:chattrix_ui/core/widgets/app_input_field.dart';
import 'package:chattrix_ui/core/widgets/primary_button.dart';
import 'package:chattrix_ui/features/contacts/presentation/providers/contact_providers.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class SendFriendRequestPage extends ConsumerStatefulWidget {
  const SendFriendRequestPage({super.key});

  @override
  ConsumerState<SendFriendRequestPage> createState() => _SendFriendRequestPageState();
}

class _SendFriendRequestPageState extends ConsumerState<SendFriendRequestPage> {
  final _formKey = GlobalKey<FormState>();
  final _userIdController = TextEditingController();
  final _nicknameController = TextEditingController();
  bool _isLoading = false;

  @override
  void dispose() {
    _userIdController.dispose();
    _nicknameController.dispose();
    super.dispose();
  }

  Future<void> _sendFriendRequest() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    final receiverUserId = int.tryParse(_userIdController.text);
    if (receiverUserId == null) {
      setState(() => _isLoading = false);
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Invalid user ID')));
      return;
    }

    final success = await ref
        .read(contactProvider.notifier)
        .sendFriendRequest(
          receiverUserId: receiverUserId,
          nickname: _nicknameController.text.isEmpty ? null : _nicknameController.text,
        );

    setState(() => _isLoading = false);

    if (success && context.mounted) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Friend request sent successfully')));
      Navigator.pop(context);
    } else if (context.mounted) {
      final errorMessage = ref.read(contactProvider).errorMessage ?? 'Failed to send request';
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(errorMessage)));
    }
  }

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;

    return Scaffold(
      appBar: AppBar(title: Text('Add Friend', style: textTheme.titleLarge)),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Text('Enter the user ID of the person you want to add as a friend', style: textTheme.bodyMedium),
              const SizedBox(height: 24),
              AppInputField(
                controller: _userIdController,
                labelText: 'User ID',
                hintText: 'Enter user ID (e.g., 2)',
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter a user ID';
                  }
                  if (int.tryParse(value) == null) {
                    return 'Please enter a valid number';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              AppInputField(
                controller: _nicknameController,
                labelText: 'Nickname (Optional)',
                hintText: 'Enter a nickname for this contact',
              ),
              const SizedBox(height: 24),
              PrimaryButton(
                onPressed: _isLoading ? null : _sendFriendRequest,
                text: 'Send Friend Request',
                isLoading: _isLoading,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/contacts/presentation/providers/contact_providers.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_state_provider.dart';
import 'package:chattrix_ui/features/contacts/data/datasources/contact_remote_datasource_impl.dart';
import 'package:chattrix_ui/features/contacts/data/repositories/contact_repository_impl.dart';
import 'package:chattrix_ui/features/contacts/domain/datasources/contact_remote_datasource.dart';
import 'package:chattrix_ui/features/contacts/domain/entities/contact.dart';
import 'package:chattrix_ui/features/contacts/domain/entities/friend_request.dart';
import 'package:chattrix_ui/features/contacts/domain/repositories/contact_repository.dart';
import 'package:chattrix_ui/features/contacts/domain/usecases/accept_friend_request_usecase.dart';
import 'package:chattrix_ui/features/contacts/domain/usecases/cancel_friend_request_usecase.dart';
import 'package:chattrix_ui/features/contacts/domain/usecases/get_contacts_usecase.dart';
import 'package:chattrix_ui/features/contacts/domain/usecases/get_received_friend_requests_usecase.dart';
import 'package:chattrix_ui/features/contacts/domain/usecases/get_sent_friend_requests_usecase.dart';
import 'package:chattrix_ui/features/contacts/domain/usecases/reject_friend_request_usecase.dart';
import 'package:chattrix_ui/features/contacts/domain/usecases/send_friend_request_usecase.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
final contactRemoteDataSourceProvider = Provider<ContactRemoteDataSource>((ref) {
  return ContactRemoteDataSourceImpl(dio: ref.watch(dioProvider));
});
final contactRepositoryProvider = Provider<ContactRepository>((ref) {
  final authState = ref.watch(authProvider);
  final currentUserId = authState.value?.user?.id ?? 0;

  return ContactRepositoryImpl(
    remoteDataSource: ref.watch(contactRemoteDataSourceProvider) as ContactRemoteDataSourceImpl,
    currentUserId: currentUserId,
  );
});
final getContactsUseCaseProvider = Provider<GetContactsUseCase>((ref) {
  return GetContactsUseCase(ref.watch(contactRepositoryProvider));
});

final sendFriendRequestUseCaseProvider = Provider<SendFriendRequestUseCase>((ref) {
  return SendFriendRequestUseCase(ref.watch(contactRepositoryProvider));
});

final getReceivedFriendRequestsUseCaseProvider = Provider<GetReceivedFriendRequestsUseCase>((ref) {
  return GetReceivedFriendRequestsUseCase(ref.watch(contactRepositoryProvider));
});

final getSentFriendRequestsUseCaseProvider = Provider<GetSentFriendRequestsUseCase>((ref) {
  return GetSentFriendRequestsUseCase(ref.watch(contactRepositoryProvider));
});

final acceptFriendRequestUseCaseProvider = Provider<AcceptFriendRequestUseCase>((ref) {
  return AcceptFriendRequestUseCase(ref.watch(contactRepositoryProvider));
});

final rejectFriendRequestUseCaseProvider = Provider<RejectFriendRequestUseCase>((ref) {
  return RejectFriendRequestUseCase(ref.watch(contactRepositoryProvider));
});

final cancelFriendRequestUseCaseProvider = Provider<CancelFriendRequestUseCase>((ref) {
  return CancelFriendRequestUseCase(ref.watch(contactRepositoryProvider));
});
class ContactState {
  final List<Contact> contacts;
  final List<FriendRequest> receivedRequests;
  final List<FriendRequest> sentRequests;
  final bool isLoading;
  final String? errorMessage;

  ContactState({
    this.contacts = const [],
    this.receivedRequests = const [],
    this.sentRequests = const [],
    this.isLoading = false,
    this.errorMessage,
  });

  ContactState copyWith({
    List<Contact>? contacts,
    List<FriendRequest>? receivedRequests,
    List<FriendRequest>? sentRequests,
    bool? isLoading,
    String? errorMessage,
    bool clearError = false,
  }) {
    return ContactState(
      contacts: contacts ?? this.contacts,
      receivedRequests: receivedRequests ?? this.receivedRequests,
      sentRequests: sentRequests ?? this.sentRequests,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
    );
  }
}
class ContactNotifier extends Notifier<ContactState> {
  @override
  ContactState build() {
    return ContactState();
  }

  String _getFailureMessage(Failure failure) {
    return failure.when(
      server: (message, code, requestId) => message,
      network: (message, code) => 'Kh√¥ng c√≥ k·∫øt n·ªëi m·∫°ng. Vui l√≤ng ki·ªÉm tra l·∫°i.',
      validation: (message, code, details, requestId) {
        if (details != null && details.isNotEmpty) {
          return details.values.join(', ');
        }
        return message;
      },
      auth: (message, code, requestId) => message,
      notFound: (message, code, requestId) => message,
      conflict: (message, code, requestId) => message,
      rateLimit: (message, code, requestId) => 'Qu√° nhi·ªÅu y√™u c·∫ßu. Vui l√≤ng th·ª≠ l·∫°i sau.',
    );
  }

  Future<void> loadContacts() async {
    state = state.copyWith(isLoading: true, clearError: true);

    final result = await ref.read(getContactsUseCaseProvider)();

    result.fold(
      (failure) {
        state = state.copyWith(isLoading: false, errorMessage: _getFailureMessage(failure));
      },
      (contacts) {
        state = state.copyWith(isLoading: false, contacts: contacts);
      },
    );
  }

  Future<void> loadReceivedFriendRequests() async {
    final result = await ref.read(getReceivedFriendRequestsUseCaseProvider)();

    result.fold(
      (failure) {
        state = state.copyWith(errorMessage: _getFailureMessage(failure));
      },
      (requests) {
        state = state.copyWith(receivedRequests: requests);
      },
    );
  }

  Future<void> loadSentFriendRequests() async {
    final result = await ref.read(getSentFriendRequestsUseCaseProvider)();

    result.fold(
      (failure) {
        state = state.copyWith(errorMessage: _getFailureMessage(failure));
      },
      (requests) {
        state = state.copyWith(sentRequests: requests);
      },
    );
  }

  Future<bool> sendFriendRequest({required int receiverUserId, String? nickname}) async {
    state = state.copyWith(isLoading: true, clearError: true);

    final result = await ref.read(sendFriendRequestUseCaseProvider)(receiverUserId: receiverUserId, nickname: nickname);

    return result.fold(
      (failure) {
        state = state.copyWith(isLoading: false, errorMessage: _getFailureMessage(failure));
        return false;
      },
      (friendRequest) {
        state = state.copyWith(isLoading: false, sentRequests: [...state.sentRequests, friendRequest]);
        return true;
      },
    );
  }

  Future<bool> acceptFriendRequest(int requestId) async {
    state = state.copyWith(isLoading: true, clearError: true);

    final result = await ref.read(acceptFriendRequestUseCaseProvider)(friendRequestId: requestId);

    return result.fold(
      (failure) {
        state = state.copyWith(isLoading: false, errorMessage: _getFailureMessage(failure));
        return false;
      },
      (_) {
        state = state.copyWith(
          isLoading: false,
          receivedRequests: state.receivedRequests.where((request) => request.id != requestId).toList(),
        );
        loadContacts();
        return true;
      },
    );
  }

  Future<bool> rejectFriendRequest(int requestId) async {
    state = state.copyWith(isLoading: true, clearError: true);

    final result = await ref.read(rejectFriendRequestUseCaseProvider)(friendRequestId: requestId);

    return result.fold(
      (failure) {
        state = state.copyWith(isLoading: false, errorMessage: _getFailureMessage(failure));
        return false;
      },
      (_) {
        state = state.copyWith(
          isLoading: false,
          receivedRequests: state.receivedRequests.where((request) => request.id != requestId).toList(),
        );
        return true;
      },
    );
  }

  Future<bool> cancelFriendRequest(int requestId) async {
    state = state.copyWith(isLoading: true, clearError: true);

    final result = await ref.read(cancelFriendRequestUseCaseProvider)(friendRequestId: requestId);

    return result.fold(
      (failure) {
        state = state.copyWith(isLoading: false, errorMessage: _getFailureMessage(failure));
        return false;
      },
      (_) {
        state = state.copyWith(
          isLoading: false,
          sentRequests: state.sentRequests.where((request) => request.id != requestId).toList(),
        );
        return true;
      },
    );
  }
}
final contactProvider = NotifierProvider<ContactNotifier, ContactState>(() {
  return ContactNotifier();
});

================================================================
FILE: lib/features/notes/data/datasources/notes_remote_datasource_impl.dart
================================================================
import 'package:chattrix_ui/features/notes/data/models/user_note_model.dart';
import 'package:chattrix_ui/features/notes/domain/datasources/notes_remote_datasource.dart';
import 'package:dio/dio.dart';

class NotesRemoteDatasourceImpl implements NotesRemoteDatasource {
  final Dio _dio;

  NotesRemoteDatasourceImpl(this._dio);

  @override
  Future<UserNoteModel> createOrUpdateNote({
    required String noteText,
    String? musicUrl,
    String? musicTitle,
    String? emoji,
  }) async {
    final response = await _dio.post(
      '/v1/notes',
      data: {
        'noteText': noteText,
        if (musicUrl != null) 'musicUrl': musicUrl,
        if (musicTitle != null) 'musicTitle': musicTitle,
        if (emoji != null) 'emoji': emoji,
      },
    );

    final data = response.data['data'];
    return UserNoteModel.fromJson(data);
  }

  @override
  Future<UserNoteModel?> getMyNote() async {
    final response = await _dio.get('/v1/notes');
    final data = response.data['data'];

    if (data == null) return null;
    return UserNoteModel.fromJson(data);
  }

  @override
  Future<void> deleteMyNote() async {
    await _dio.delete('/v1/notes');
  }

  @override
  Future<List<UserNoteModel>> getContactNotes() async {
    final response = await _dio.get('/v1/notes/contacts');
    final data = response.data['data'] as List;

    return data.map((json) => UserNoteModel.fromJson(json)).toList();
  }

  @override
  Future<UserNoteModel?> getUserNote(int userId) async {
    final response = await _dio.get('/v1/notes/user/$userId');
    final data = response.data['data'];

    if (data == null) return null;
    return UserNoteModel.fromJson(data);
  }
}

================================================================
FILE: lib/features/notes/data/models/note_delete_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'note_delete_dto.freezed.dart';
part 'note_delete_dto.g.dart';
@freezed
abstract class NoteDeleteDto with _$NoteDeleteDto {
  const factory NoteDeleteDto({required int userId}) = _NoteDeleteDto;

  factory NoteDeleteDto.fromJson(Map<String, dynamic> json) => _$NoteDeleteDtoFromJson(json);
}

================================================================
FILE: lib/features/notes/data/models/user_note_dto.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_note_dto.freezed.dart';
part 'user_note_dto.g.dart';
@freezed
abstract class UserNoteDto with _$UserNoteDto {
  const factory UserNoteDto({
    required int id,
    required int userId,
    required String noteText,
    String? emoji,
    required String createdAt,
    required String expiresAt,
  }) = _UserNoteDto;

  factory UserNoteDto.fromJson(Map<String, dynamic> json) => _$UserNoteDtoFromJson(json);
}

================================================================
FILE: lib/features/notes/data/models/user_note_model.dart
================================================================
import 'package:chattrix_ui/features/notes/domain/entities/user_note.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_note_model.freezed.dart';
part 'user_note_model.g.dart';

@freezed
abstract class UserNoteModel with _$UserNoteModel {
  const UserNoteModel._();

  const factory UserNoteModel({
    required int id,
    required int userId,
    required String username,
    required String fullName,
    String? avatarUrl,
    required String noteText,
    String? musicUrl,
    String? musicTitle,
    String? emoji,
    required String createdAt,
    required String expiresAt,
    @Default(0) int replyCount,
  }) = _UserNoteModel;

  factory UserNoteModel.fromJson(Map<String, dynamic> json) => _$UserNoteModelFromJson(json);

  UserNote toEntity() {
    return UserNote(
      id: id,
      userId: userId,
      username: username,
      fullName: fullName,
      avatarUrl: avatarUrl,
      noteText: noteText,
      musicUrl: musicUrl,
      musicTitle: musicTitle,
      emoji: emoji,
      createdAt: DateTime.parse(createdAt),
      expiresAt: DateTime.parse(expiresAt),
      replyCount: replyCount,
    );
  }
}

================================================================
FILE: lib/features/notes/data/repositories/notes_repository_impl.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/repositories/base_repository.dart';
import '../../domain/entities/user_note.dart';
import '../../domain/repositories/notes_repository.dart';
import '../datasources/notes_remote_datasource_impl.dart';

class NotesRepositoryImpl extends BaseRepository implements NotesRepository {
  final NotesRemoteDatasourceImpl _remoteDatasource;

  NotesRepositoryImpl(this._remoteDatasource);

  @override
  Future<Either<Failure, UserNote>> createOrUpdateNote({
    required String noteText,
    String? musicUrl,
    String? musicTitle,
    String? emoji,
  }) async {
    return executeApiCall(() async {
      final model = await _remoteDatasource.createOrUpdateNote(
        noteText: noteText,
        musicUrl: musicUrl,
        musicTitle: musicTitle,
        emoji: emoji,
      );
      return model.toEntity();
    });
  }

  @override
  Future<Either<Failure, UserNote?>> getMyNote() async {
    return executeApiCall(() async {
      final model = await _remoteDatasource.getMyNote();
      return model?.toEntity();
    });
  }

  @override
  Future<Either<Failure, void>> deleteMyNote() async {
    return executeApiCall(() async {
      await _remoteDatasource.deleteMyNote();
    });
  }

  @override
  Future<Either<Failure, List<UserNote>>> getContactNotes() async {
    return executeApiCall(() async {
      final models = await _remoteDatasource.getContactNotes();
      return models.map((m) => m.toEntity()).toList();
    });
  }

  @override
  Future<Either<Failure, UserNote?>> getUserNote(int userId) async {
    return executeApiCall(() async {
      final model = await _remoteDatasource.getUserNote(userId);
      return model?.toEntity();
    });
  }
}

================================================================
FILE: lib/features/notes/domain/datasources/notes_remote_datasource.dart
================================================================
import 'package:chattrix_ui/features/notes/data/models/user_note_model.dart';
abstract class NotesRemoteDatasource {
  Future<UserNoteModel> createOrUpdateNote({
    required String noteText,
    String? musicUrl,
    String? musicTitle,
    String? emoji,
  });
  Future<UserNoteModel?> getMyNote();
  Future<void> deleteMyNote();
  Future<List<UserNoteModel>> getContactNotes();
  Future<UserNoteModel?> getUserNote(int userId);
}

================================================================
FILE: lib/features/notes/domain/entities/user_note.dart
================================================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_note.freezed.dart';
@freezed
abstract class UserNote with _$UserNote {
  const factory UserNote({
    required int id,
    required int userId,
    required String username,
    required String fullName,
    String? avatarUrl,
    required String noteText,
    String? musicUrl,
    String? musicTitle,
    String? emoji,
    required DateTime createdAt,
    required DateTime expiresAt,
    @Default(0) int replyCount,
  }) = _UserNote;
}

================================================================
FILE: lib/features/notes/domain/repositories/notes_repository.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../entities/user_note.dart';
abstract class NotesRepository {
  Future<Either<Failure, UserNote>> createOrUpdateNote({
    required String noteText,
    String? musicUrl,
    String? musicTitle,
    String? emoji,
  });
  Future<Either<Failure, UserNote?>> getMyNote();
  Future<Either<Failure, void>> deleteMyNote();
  Future<Either<Failure, List<UserNote>>> getContactNotes();
  Future<Either<Failure, UserNote?>> getUserNote(int userId);
}

================================================================
FILE: lib/features/notes/domain/usecases/create_or_update_note_usecase.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../entities/user_note.dart';
import '../repositories/notes_repository.dart';

class CreateOrUpdateNoteUseCase {
  final NotesRepository _repository;

  CreateOrUpdateNoteUseCase(this._repository);

  Future<Either<Failure, UserNote>> call({
    required String noteText,
    String? musicUrl,
    String? musicTitle,
    String? emoji,
  }) {
    return _repository.createOrUpdateNote(noteText: noteText, musicUrl: musicUrl, musicTitle: musicTitle, emoji: emoji);
  }
}

================================================================
FILE: lib/features/notes/domain/usecases/delete_my_note_usecase.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../repositories/notes_repository.dart';

class DeleteMyNoteUseCase {
  final NotesRepository _repository;

  DeleteMyNoteUseCase(this._repository);

  Future<Either<Failure, void>> call() {
    return _repository.deleteMyNote();
  }
}

================================================================
FILE: lib/features/notes/domain/usecases/get_contact_notes_usecase.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../entities/user_note.dart';
import '../repositories/notes_repository.dart';

class GetContactNotesUseCase {
  final NotesRepository _repository;

  GetContactNotesUseCase(this._repository);

  Future<Either<Failure, List<UserNote>>> call() {
    return _repository.getContactNotes();
  }
}

================================================================
FILE: lib/features/notes/domain/usecases/get_my_note_usecase.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../entities/user_note.dart';
import '../repositories/notes_repository.dart';

class GetMyNoteUseCase {
  final NotesRepository _repository;

  GetMyNoteUseCase(this._repository);

  Future<Either<Failure, UserNote?>> call() {
    return _repository.getMyNote();
  }
}

================================================================
FILE: lib/features/notes/presentation/providers/notes_providers.dart
================================================================
import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/notes/data/datasources/notes_remote_datasource_impl.dart';
import 'package:chattrix_ui/features/notes/data/repositories/notes_repository_impl.dart';
import 'package:chattrix_ui/features/notes/domain/datasources/notes_remote_datasource.dart';
import 'package:chattrix_ui/features/notes/domain/entities/user_note.dart';
import 'package:chattrix_ui/features/notes/domain/repositories/notes_repository.dart';
import 'package:chattrix_ui/features/notes/domain/usecases/create_or_update_note_usecase.dart';
import 'package:chattrix_ui/features/notes/domain/usecases/delete_my_note_usecase.dart';
import 'package:chattrix_ui/features/notes/domain/usecases/get_contact_notes_usecase.dart';
import 'package:chattrix_ui/features/notes/domain/usecases/get_my_note_usecase.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
final notesRemoteDatasourceProvider = Provider<NotesRemoteDatasource>((ref) {
  final dio = ref.watch(dioProvider);
  return NotesRemoteDatasourceImpl(dio);
});
final notesRepositoryProvider = Provider<NotesRepository>((ref) {
  final datasource = ref.watch(notesRemoteDatasourceProvider) as NotesRemoteDatasourceImpl;
  return NotesRepositoryImpl(datasource);
});
final createOrUpdateNoteUseCaseProvider = Provider<CreateOrUpdateNoteUseCase>((ref) {
  final repository = ref.watch(notesRepositoryProvider);
  return CreateOrUpdateNoteUseCase(repository);
});

final getMyNoteUseCaseProvider = Provider<GetMyNoteUseCase>((ref) {
  final repository = ref.watch(notesRepositoryProvider);
  return GetMyNoteUseCase(repository);
});

final deleteMyNoteUseCaseProvider = Provider<DeleteMyNoteUseCase>((ref) {
  final repository = ref.watch(notesRepositoryProvider);
  return DeleteMyNoteUseCase(repository);
});

final getContactNotesUseCaseProvider = Provider<GetContactNotesUseCase>((ref) {
  final repository = ref.watch(notesRepositoryProvider);
  return GetContactNotesUseCase(repository);
});
final myNoteProvider = FutureProvider<UserNote?>((ref) async {
  final useCase = ref.watch(getMyNoteUseCaseProvider);
  final result = await useCase();

  return result.fold((failure) => throw _mapFailureToException(failure), (note) => note);
});

final contactNotesProvider = FutureProvider<List<UserNote>>((ref) async {
  final useCase = ref.watch(getContactNotesUseCaseProvider);
  final result = await useCase();

  return result.fold((failure) => throw _mapFailureToException(failure), (notes) => notes);
});
Exception _mapFailureToException(Failure failure) {
  return failure.when(
    server: (message, code, requestId) => ServerException(message, code),
    network: (message, code) => NetworkException(message),
    validation: (message, code, details, requestId) => ValidationException(message, details),
    auth: (message, code, requestId) => AuthException(message, code),
    notFound: (message, code, requestId) => NotFoundException(message, code),
    conflict: (message, code, requestId) => ConflictException(message, code),
    rateLimit: (message, code, requestId) => RateLimitException(message),
  );
}
class ServerException implements Exception {
  final String message;
  final String? code;
  ServerException(this.message, [this.code]);

  @override
  String toString() => message;
}

class NetworkException implements Exception {
  final String message;
  NetworkException(this.message);

  @override
  String toString() => message;
}

class ValidationException implements Exception {
  final String message;
  final Map<String, String>? details;
  ValidationException(this.message, [this.details]);

  @override
  String toString() {
    if (details != null && details!.isNotEmpty) {
      return details!.values.join(', ');
    }
    return message;
  }
}

class AuthException implements Exception {
  final String message;
  final String? code;
  AuthException(this.message, [this.code]);

  @override
  String toString() => message;
}

class NotFoundException implements Exception {
  final String message;
  final String? code;
  NotFoundException(this.message, [this.code]);

  @override
  String toString() => message;
}

class ConflictException implements Exception {
  final String message;
  final String? code;
  ConflictException(this.message, [this.code]);

  @override
  String toString() => message;
}

class RateLimitException implements Exception {
  final String message;
  RateLimitException(this.message);

  @override
  String toString() => message;
}

================================================================
FILE: lib/features/profile/data/datasources/profile_remote_datasource_impl.dart
================================================================
import 'package:chattrix_ui/core/constants/api_constants.dart';
import 'package:chattrix_ui/features/profile/data/models/profile_model.dart';
import 'package:chattrix_ui/features/profile/data/models/update_profile_request.dart';
import 'package:chattrix_ui/features/profile/domain/datasources/profile_remote_datasource.dart';
import 'package:dio/dio.dart';

class ProfileRemoteDataSourceImpl implements ProfileRemoteDataSource {
  final Dio dio;

  ProfileRemoteDataSourceImpl({required this.dio});

  @override
  Future<ProfileModel> getProfile() async {
    final response = await dio.get(ApiConstants.getProfile);
    return ProfileModel.fromJson(response.data['data']);
  }

  @override
  Future<ProfileModel> updateProfile(UpdateProfileRequest request) async {
    final response = await dio.put(ApiConstants.updateProfile, data: request.toJson());
    return ProfileModel.fromJson(response.data['data']);
  }
}

================================================================
FILE: lib/features/profile/data/models/profile_model.dart
================================================================
import 'package:chattrix_ui/features/auth/data/models/user_dto.dart';

typedef ProfileModel = UserDto;

================================================================
FILE: lib/features/profile/data/models/update_profile_request.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/gender.dart';
import 'package:chattrix_ui/features/profile/domain/entities/update_profile_params.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'update_profile_request.freezed.dart';
part 'update_profile_request.g.dart';

@freezed
abstract class UpdateProfileRequest with _$UpdateProfileRequest {
  const UpdateProfileRequest._();

  const factory UpdateProfileRequest({
    String? fullName,
    String? avatarUrl,
    String? phone,
    String? bio,
    String? dateOfBirth,
    @JsonKey(unknownEnumValue: Gender.other) Gender? gender,
    String? location,
  }) = _UpdateProfileRequest;

  factory UpdateProfileRequest.fromJson(Map<String, dynamic> json) => _$UpdateProfileRequestFromJson(json);

  factory UpdateProfileRequest.fromParams(UpdateProfileParams params) {
    return UpdateProfileRequest(
      fullName: params.fullName,
      avatarUrl: params.avatarUrl,
      phone: params.phone,
      bio: params.bio,
      dateOfBirth: params.dateOfBirth?.toIso8601String().split('T')[0],
      gender: params.gender,
      location: params.location,
    );
  }
}

================================================================
FILE: lib/features/profile/data/repositories/profile_repository_impl.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/repositories/base_repository.dart';
import '../../../auth/data/mappers/user_mapper.dart';
import '../../domain/entities/profile.dart';
import '../../domain/entities/update_profile_params.dart';
import '../../domain/repositories/profile_repository.dart';
import '../datasources/profile_remote_datasource_impl.dart';
import '../models/update_profile_request.dart';

class ProfileRepositoryImpl extends BaseRepository implements ProfileRepository {
  final ProfileRemoteDataSourceImpl _remoteDataSource;

  ProfileRepositoryImpl(this._remoteDataSource);

  @override
  Future<Either<Failure, Profile>> getProfile() async {
    return executeApiCall(() async {
      final userDto = await _remoteDataSource.getProfile();
      return userDto.toEntity();
    });
  }

  @override
  Future<Either<Failure, Profile>> updateProfile(UpdateProfileParams params) async {
    return executeApiCall(() async {
      final request = UpdateProfileRequest.fromParams(params);
      final userDto = await _remoteDataSource.updateProfile(request);
      return userDto.toEntity();
    });
  }
}

================================================================
FILE: lib/features/profile/domain/datasources/profile_remote_datasource.dart
================================================================
import 'package:chattrix_ui/features/profile/data/models/profile_model.dart';
import 'package:chattrix_ui/features/profile/data/models/update_profile_request.dart';

abstract class ProfileRemoteDataSource {
  Future<ProfileModel> getProfile();

  Future<ProfileModel> updateProfile(UpdateProfileRequest request);
}

================================================================
FILE: lib/features/profile/domain/entities/profile.dart
================================================================
import 'package:chattrix_ui/features/auth/domain/entities/user.dart';
typedef Profile = User;

================================================================
FILE: lib/features/profile/domain/entities/update_profile_params.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/gender.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'update_profile_params.freezed.dart';

@freezed
abstract class UpdateProfileParams with _$UpdateProfileParams {
  const factory UpdateProfileParams({
    String? fullName,
    String? avatarUrl,
    String? phone,
    String? bio,
    DateTime? dateOfBirth,
    Gender? gender,
    String? location,
  }) = _UpdateProfileParams;
}

================================================================
FILE: lib/features/profile/domain/repositories/profile_repository.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../entities/profile.dart';
import '../entities/update_profile_params.dart';

abstract class ProfileRepository {
  Future<Either<Failure, Profile>> getProfile();

  Future<Either<Failure, Profile>> updateProfile(UpdateProfileParams params);
}

================================================================
FILE: lib/features/profile/domain/usecases/get_profile_usecase.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../entities/profile.dart';
import '../repositories/profile_repository.dart';

class GetProfileUseCase {
  final ProfileRepository repository;

  GetProfileUseCase(this.repository);

  Future<Either<Failure, Profile>> call() async {
    return repository.getProfile();
  }
}

================================================================
FILE: lib/features/profile/domain/usecases/update_profile_usecase.dart
================================================================
import 'package:fpdart/fpdart.dart';
import '../../../../core/errors/failures.dart';
import '../entities/profile.dart';
import '../entities/update_profile_params.dart';
import '../repositories/profile_repository.dart';

class UpdateProfileUseCase {
  final ProfileRepository repository;

  UpdateProfileUseCase(this.repository);

  Future<Either<Failure, Profile>> call(UpdateProfileParams params) async {
    return repository.updateProfile(params);
  }
}

================================================================
FILE: lib/features/profile/presentation/pages/edit_profile_page.dart
================================================================
import 'dart:io';

import 'package:bottom_picker/bottom_picker.dart';
import 'package:bottom_picker/resources/arrays.dart';
import 'package:chattrix_ui/core/domain/enums/enums.dart';
import 'package:chattrix_ui/features/profile/domain/entities/update_profile_params.dart';
import 'package:chattrix_ui/features/profile/presentation/providers/profile_providers.dart';
import 'package:chattrix_ui/features/profile/presentation/widgets/profile_picker_widgets.dart';
import 'package:chattrix_ui/features/profile/presentation/widgets/profile_ui_components.dart';
import 'package:chattrix_ui/features/profile/presentation/widgets/single_field_editor.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:intl/intl.dart';

class EditProfilePage extends HookConsumerWidget {
  const EditProfilePage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final colors = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    final profileAsync = ref.watch(profileControllerProvider);

    final username = useState('');
    final fullName = useState('');
    final bio = useState('');
    final phone = useState('');
    final email = useState('');
    final location = useState('');
    final gender = useState<Gender?>(null);
    final dob = useState<DateTime?>(null);
    final visibility = useState<ProfileVisibility>(ProfileVisibility.public);
    final avatarPath = useState<String?>(null);
    final avatarUrl = useState<String?>(null);
    final isInitialized = useState(false);
    final hasUnsavedChanges = useState(false);

    useEffect(() {
      final currentProfile = profileAsync.asData?.value;
      if (!isInitialized.value && currentProfile != null) {
        username.value = currentProfile.username;
        fullName.value = currentProfile.fullName;
        bio.value = currentProfile.bio ?? '';
        phone.value = currentProfile.phone ?? '';
        email.value = currentProfile.email;
        location.value = currentProfile.location ?? '';
        gender.value = currentProfile.gender;
        dob.value = currentProfile.dateOfBirth;
        visibility.value = currentProfile.profileVisibility ?? ProfileVisibility.public;
        avatarUrl.value = currentProfile.avatarUrl;
        isInitialized.value = true;
      }
      return null;
    }, [profileAsync.asData?.value]);

    useEffect(
      () {
        if (isInitialized.value) {
          final currentProfile = profileAsync.asData?.value;
          if (currentProfile != null) {
            final changed =
                username.value != currentProfile.username ||
                fullName.value != currentProfile.fullName ||
                bio.value != (currentProfile.bio ?? '') ||
                phone.value != (currentProfile.phone ?? '') ||
                email.value != currentProfile.email ||
                location.value != (currentProfile.location ?? '') ||
                gender.value != currentProfile.gender ||
                dob.value != currentProfile.dateOfBirth ||
                visibility.value != (currentProfile.profileVisibility ?? ProfileVisibility.public) ||
                avatarPath.value != null;
            hasUnsavedChanges.value = changed;
          }
        }
        return null;
      },
      [
        username.value,
        fullName.value,
        bio.value,
        phone.value,
        email.value,
        location.value,
        gender.value,
        dob.value,
        visibility.value,
        avatarPath.value,
        isInitialized.value,
      ],
    );

    Future<bool> onWillPop() async {
      if (!hasUnsavedChanges.value) return true;

      final shouldPop = await showModalBottomSheet<bool>(
        context: context,
        backgroundColor: colors.surface,
        showDragHandle: true,
        shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(20))),
        builder: (context) => SafeArea(
          child: Padding(
            padding: const EdgeInsets.fromLTRB(24, 0, 24, 24),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(color: colors.errorContainer, borderRadius: BorderRadius.circular(12)),
                      child: Icon(Icons.warning_rounded, color: colors.error, size: 24),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: Text(
                        'Discard changes?',
                        style: textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Text(
                  'You have unsaved changes. Are you sure you want to leave without saving?',
                  style: textTheme.bodyMedium?.copyWith(color: colors.onSurfaceVariant, height: 1.4),
                ),
                const SizedBox(height: 24),
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton(
                        onPressed: () => Navigator.pop(context, false),
                        style: OutlinedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          side: BorderSide(color: colors.outline, width: 1.5),
                        ),
                        child: const Text('Keep Editing', style: TextStyle(fontSize: 15, fontWeight: FontWeight.w600)),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: FilledButton(
                        onPressed: () => Navigator.pop(context, true),
                        style: FilledButton.styleFrom(
                          backgroundColor: colors.error,
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        ),
                        child: const Text('Discard', style: TextStyle(fontSize: 15, fontWeight: FontWeight.w600)),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      );

      return shouldPop ?? false;
    }

    Future<void> saveProfile() async {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(child: CircularProgressIndicator()),
      );

      try {
        final params = UpdateProfileParams(
          fullName: fullName.value,
          phone: phone.value.isNotEmpty ? phone.value : null,
          bio: bio.value.isNotEmpty ? bio.value : null,
          dateOfBirth: dob.value,
          gender: gender.value,
          location: location.value.isNotEmpty ? location.value : null,
          avatarUrl: avatarPath.value != null ? null : avatarUrl.value,
        );

        File? newImageFile;
        if (avatarPath.value != null) {
          newImageFile = File(avatarPath.value!);
        }

        await ref.read(profileControllerProvider.notifier).updateProfile(params: params, newAvatarFile: newImageFile);

        if (context.mounted) {
          Navigator.pop(context);

          final currentState = ref.read(profileControllerProvider);

          if (currentState.hasError) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Update failed: ${currentState.error.toString().replaceAll('Exception: ', '')}'),
                backgroundColor: colors.error,
              ),
            );
          } else {
            hasUnsavedChanges.value = false;
            ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Profile updated successfully!')));
            context.pop();
          }
        }
      } catch (e) {
        if (context.mounted) {
          Navigator.pop(context);
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error: $e'),
              backgroundColor: colors.error,
              behavior: SnackBarBehavior.floating,
              margin: const EdgeInsets.all(16),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            ),
          );
        }
      }
    }

    void openEditor({
      required String title,
      required String label,
      required String currentValue,
      required ValueNotifier<String> notifier,
      required int maxLength,
      int maxLines = 1,
      TextInputType inputType = TextInputType.text,
      String? helperText,
    }) {
      Navigator.of(context).push(
        MaterialPageRoute(
          builder: (context) => SingleFieldEditor(
            title: title,
            label: label,
            initialValue: currentValue,
            maxLength: maxLength,
            maxLines: maxLines,
            inputType: inputType,
            helperText: helperText,
            onSave: (val) {
              notifier.value = val;
              ScaffoldMessenger.of(
                context,
              ).showSnackBar(SnackBar(content: Text('$title updated'), duration: const Duration(seconds: 1)));
            },
          ),
        ),
      );
    }

    void showAvatarPicker() {
      final picker = ImagePicker();
      showModalBottomSheet(
        context: context,
        backgroundColor: Colors.transparent,
        builder: (context) => Container(
          padding: const EdgeInsets.all(24),
          decoration: BoxDecoration(
            color: colors.surface,
            borderRadius: const BorderRadius.vertical(top: Radius.circular(24)),
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              PickerOption(
                icon: Icons.camera_alt_rounded,
                label: 'Take a photo',
                onTap: () async {
                  Navigator.pop(context);
                  final img = await picker.pickImage(source: ImageSource.camera);
                  if (img != null) avatarPath.value = img.path;
                },
              ),
              const SizedBox(height: 12),
              PickerOption(
                icon: Icons.photo_library_rounded,
                label: 'Choose from gallery',
                onTap: () async {
                  Navigator.pop(context);
                  final img = await picker.pickImage(source: ImageSource.gallery);
                  if (img != null) avatarPath.value = img.path;
                },
              ),
              const SizedBox(height: 24),
            ],
          ),
        ),
      );
    }

    void showDatePickerDialog() {
      BottomPicker.date(
        pickerTitle: const Text('Select Birthday', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),
        dateOrder: DatePickerDateOrder.dmy,
        initialDateTime: dob.value ?? DateTime(2000),
        maxDateTime: DateTime.now(),
        minDateTime: DateTime(1900),
        bottomPickerTheme: BottomPickerTheme.blue,
        buttonSingleColor: colors.primary,
        backgroundColor: colors.surface,
        onSubmit: (date) {
          if (date is DateTime) dob.value = date;
        },
        buttonContent: const Padding(
          padding: EdgeInsets.symmetric(horizontal: 10),
          child: Center(
            child: Text(
              'Confirm',
              style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
            ),
          ),
        ),
        buttonWidth: 200,
        displaySubmitButton: true,
      ).show(context);
    }

    void showGenderPicker() {
      showModalBottomSheet(
        context: context,
        shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(20))),
        builder: (context) => Container(
          padding: const EdgeInsets.symmetric(vertical: 20),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text('Select Gender', style: textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
              const SizedBox(height: 10),
              ...Gender.values.map((g) {
                final isSelected = gender.value == g;
                return ListTile(
                  leading: Icon(
                    isSelected ? Icons.radio_button_checked : Icons.radio_button_off,
                    color: isSelected ? colors.primary : colors.onSurfaceVariant,
                  ),
                  title: Text(g.label),
                  onTap: () {
                    gender.value = g;
                    Navigator.pop(context);
                  },
                );
              }),
              const SizedBox(height: 20),
            ],
          ),
        ),
      );
    }

    void showVisibilityPicker() {
      showModalBottomSheet(
        context: context,
        shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(20))),
        builder: (context) {
          return Container(
            padding: const EdgeInsets.symmetric(vertical: 20),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text('Profile Visibility', style: textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
                const SizedBox(height: 10),
                ...ProfileVisibility.values.map(
                  (v) => ListTile(
                    leading: Icon(
                      visibility.value == v ? Icons.radio_button_checked : Icons.radio_button_off,
                      color: visibility.value == v ? colors.primary : colors.onSurfaceVariant,
                    ),
                    title: Text(v.label),
                    onTap: () {
                      visibility.value = v;
                      Navigator.pop(context);
                    },
                  ),
                ),
                const SizedBox(height: 20),
              ],
            ),
          );
        },
      );
    }

    if (profileAsync.isLoading && !isInitialized.value) {
      return Scaffold(
        backgroundColor: colors.surfaceContainerLow,
        appBar: AppBar(title: const Text('Edit Profile'), backgroundColor: colors.surface),
        body: const Center(child: CircularProgressIndicator()),
      );
    }

    return PopScope(
      canPop: false,
      onPopInvokedWithResult: (didPop, result) async {
        if (didPop) return;
        final shouldPop = await onWillPop();
        if (shouldPop && context.mounted) {
          Navigator.of(context).pop();
        }
      },
      child: Scaffold(
        backgroundColor: colors.surfaceContainerLow,
        appBar: AppBar(
          title: const Text('Edit Profile', style: TextStyle(fontWeight: FontWeight.bold)),
          centerTitle: true,
          backgroundColor: colors.surface,
          surfaceTintColor: Colors.transparent,
          elevation: 0.5,
          shadowColor: Colors.black.withValues(alpha: 0.1),
          scrolledUnderElevation: 0.5,
          leading: IconButton(
            icon: const Icon(Icons.arrow_back),
            onPressed: () async {
              final shouldPop = await onWillPop();
              if (shouldPop && context.mounted) {
                context.pop();
              }
            },
          ),
          actions: [
            TextButton(
              onPressed: saveProfile,
              child: Text(
                'Save',
                style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16, color: colors.primary),
              ),
            ),
          ],
        ),
        body: ListView(
          padding: const EdgeInsets.symmetric(vertical: 24),
          children: [
            Center(
              child: GestureDetector(
                onTap: showAvatarPicker,
                child: SizedBox(
                  width: 120,
                  height: 120,
                  child: Stack(
                    children: [
                      Container(
                        width: 120,
                        height: 120,
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          border: Border.all(color: colors.outlineVariant.withValues(alpha: 0.4), width: 1),
                        ),
                        child: CircleAvatar(
                          radius: 60,
                          backgroundColor: colors.surfaceContainerHighest,
                          backgroundImage: avatarPath.value != null
                              ? FileImage(File(avatarPath.value!))
                              : (avatarUrl.value != null ? NetworkImage(avatarUrl.value!) : null) as ImageProvider?,
                          child: avatarPath.value == null && avatarUrl.value == null
                              ? Text(
                                  fullName.value.isNotEmpty ? fullName.value[0].toUpperCase() : '?',
                                  style: textTheme.displayMedium?.copyWith(
                                    color: colors.onSurfaceVariant,
                                    fontWeight: FontWeight.bold,
                                  ),
                                )
                              : null,
                        ),
                      ),
                      Align(
                        alignment: Alignment.bottomRight,
                        child: Container(
                          margin: const EdgeInsets.all(4),
                          padding: const EdgeInsets.all(8),
                          decoration: BoxDecoration(
                            color: colors.primary,
                            shape: BoxShape.circle,
                            border: Border.all(color: colors.surface, width: 3),
                          ),
                          child: const Icon(Icons.camera_alt, size: 18, color: Colors.white),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
            const SizedBox(height: 12),
            Center(
              child: Text(
                'Change Photo',
                style: textTheme.labelMedium?.copyWith(color: colors.primary, fontWeight: FontWeight.w600),
              ),
            ),
            const SizedBox(height: 32),

            const SectionHeader(title: 'PERSONAL INFORMATION'),
            MenuCard(
              children: [
                ProfileMenuItem(
                  label: 'Username',
                  value: '@${username.value}',
                  icon: FontAwesomeIcons.at,
                  onTap: () => openEditor(
                    title: 'Username',
                    label: 'Unique ID',
                    currentValue: username.value,
                    notifier: username,
                    maxLength: 20,
                    helperText: 'Only letters, numbers, dot and underscore.',
                  ),
                ),
                ProfileMenuItem(
                  label: 'Name',
                  value: fullName.value,
                  icon: FontAwesomeIcons.user,
                  onTap: () => openEditor(
                    title: 'Name',
                    label: 'Full Name',
                    currentValue: fullName.value,
                    notifier: fullName,
                    maxLength: 100,
                  ),
                ),
                ProfileMenuItem(
                  label: 'Gender',
                  value: gender.value?.label ?? 'Not set',
                  icon: FontAwesomeIcons.venusMars,
                  onTap: showGenderPicker,
                ),
                ProfileMenuItem(
                  label: 'Birthday',
                  value: dob.value != null ? DateFormat('dd MMM, yyyy').format(dob.value!) : 'Not set',
                  icon: FontAwesomeIcons.cakeCandles,
                  onTap: showDatePickerDialog,
                ),
                ProfileMenuItem(
                  label: 'Location',
                  value: location.value.isNotEmpty ? location.value : 'Not set',
                  icon: FontAwesomeIcons.locationDot,
                  onTap: () => openEditor(
                    title: 'Location',
                    label: 'Current City',
                    currentValue: location.value,
                    notifier: location,
                    maxLength: 100,
                  ),
                ),
              ],
            ),

            const SizedBox(height: 24),

            const SectionHeader(title: 'CONTACT INFO'),
            MenuCard(
              children: [
                ProfileMenuItem(
                  label: 'Email',
                  value: email.value,
                  icon: FontAwesomeIcons.envelope,
                  isVerified: profileAsync.asData?.value.emailVerified ?? false,
                  onTap: () => openEditor(
                    title: 'Email',
                    label: 'Email Address',
                    currentValue: email.value,
                    notifier: email,
                    maxLength: 50,
                    inputType: TextInputType.emailAddress,
                    helperText: 'Changing email will require re-verification.',
                  ),
                ),
                ProfileMenuItem(
                  label: 'Phone',
                  value: phone.value.isNotEmpty ? phone.value : 'Not set',
                  icon: FontAwesomeIcons.phone,
                  onTap: () => openEditor(
                    title: 'Phone',
                    label: 'Phone Number',
                    currentValue: phone.value,
                    notifier: phone,
                    maxLength: 20,
                    inputType: TextInputType.phone,
                  ),
                ),
              ],
            ),

            const SizedBox(height: 24),

            const SectionHeader(title: 'ABOUT'),
            MenuCard(
              children: [
                ProfileMenuItem(
                  label: 'Bio',
                  value: bio.value.isNotEmpty ? bio.value : 'Not set',
                  icon: FontAwesomeIcons.penToSquare,
                  onTap: () => openEditor(
                    title: 'Bio',
                    label: 'About yourself',
                    currentValue: bio.value,
                    notifier: bio,
                    maxLength: 500,
                    maxLines: 5,
                  ),
                ),
              ],
            ),

            const SizedBox(height: 24),

            const SectionHeader(title: 'PRIVACY'),
            MenuCard(
              children: [
                ProfileMenuItem(
                  label: 'Profile Visibility',
                  value: visibility.value.label,
                  icon: visibility.value == ProfileVisibility.private
                      ? FontAwesomeIcons.lock
                      : visibility.value == ProfileVisibility.friendsOnly
                      ? FontAwesomeIcons.userGroup
                      : FontAwesomeIcons.globe,
                  onTap: showVisibilityPicker,
                ),
              ],
            ),
            const SizedBox(height: 40),
          ],
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/profile/presentation/pages/profile_page.dart
================================================================
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/profile/presentation/providers/profile_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:intl/intl.dart';
import '../widgets/profile_shared_components.dart';

class ProfilePage extends ConsumerWidget {
  const ProfilePage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final textTheme = Theme.of(context).textTheme;
    final colors = Theme.of(context).colorScheme;

    final profileAsync = ref.watch(profileControllerProvider);

    return Scaffold(
      backgroundColor: colors.surfaceContainerLow,
      appBar: AppBar(
        title: Text('Profile', style: textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold)),
        centerTitle: false,
        automaticallyImplyLeading: false,
        backgroundColor: colors.surface,
        surfaceTintColor: Colors.transparent,
        elevation: 0.5,
        shadowColor: Colors.black.withValues(alpha: 0.1),
        scrolledUnderElevation: 0.5,
        actions: [
          if (profileAsync.hasValue)
            Padding(
              padding: const EdgeInsets.only(right: 8.0),
              child: IconButton.filledTonal(
                onPressed: () async {
                  final result = await context.push<bool>('/profile/edit');
                  if (result == true && context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: const Text('‚úì Profile updated successfully'),
                        backgroundColor: Colors.green.shade600,
                        behavior: SnackBarBehavior.floating,
                        margin: const EdgeInsets.all(16),
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                        duration: const Duration(seconds: 2),
                      ),
                    );
                  }
                },
                icon: const Icon(Icons.edit, size: 20),
                tooltip: 'Edit',
                style: IconButton.styleFrom(
                  backgroundColor: colors.surfaceContainerHighest.withValues(alpha: 0.5),
                  foregroundColor: colors.onSurface,
                ),
              ),
            ),
          Padding(
            padding: const EdgeInsets.only(right: 16.0),
            child: IconButton.filledTonal(
              onPressed: () => context.push('/settings'),
              icon: const Icon(Icons.settings, size: 20),
              tooltip: 'Settings',
              style: IconButton.styleFrom(
                backgroundColor: colors.surfaceContainerHighest.withValues(alpha: 0.5),
                foregroundColor: colors.onSurface,
              ),
            ),
          ),
        ],
      ),
      body: profileAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(error.toString().replaceAll('Exception: ', ''), textAlign: TextAlign.center),
              const SizedBox(height: 16),
              ElevatedButton(onPressed: () => ref.refresh(profileControllerProvider), child: const Text('Retry')),
            ],
          ),
        ),
        data: (profile) => RefreshIndicator(
          onRefresh: () => ref.refresh(profileControllerProvider.future),
          child: SingleChildScrollView(
            physics: const AlwaysScrollableScrollPhysics(),
            child: Column(
              children: [
                Container(
                  color: colors.surface,
                  width: double.infinity,
                  padding: const EdgeInsets.only(bottom: 24, top: 10),
                  child: Column(
                    children: [
                      Stack(
                        children: [
                          Container(
                            width: 110,
                            height: 110,
                            decoration: BoxDecoration(
                              shape: BoxShape.circle,
                              border: Border.all(color: colors.outlineVariant.withValues(alpha: 0.4), width: 1),
                            ),
                            child: CircleAvatar(
                              radius: 55,
                              backgroundColor: colors.primaryContainer,
                              backgroundImage: profile.avatarUrl != null ? NetworkImage(profile.avatarUrl!) : null,
                              child: profile.avatarUrl == null
                                  ? Text(
                                      profile.fullName.isNotEmpty
                                          ? profile.fullName[0].toUpperCase()
                                          : profile.username[0].toUpperCase(),
                                      style: textTheme.displaySmall?.copyWith(
                                        color: colors.onPrimaryContainer,
                                        fontWeight: FontWeight.bold,
                                      ),
                                    )
                                  : null,
                            ),
                          ),
                          Positioned(
                            bottom: 4,
                            right: 4,
                            child: Container(
                              width: 24,
                              height: 24,
                              decoration: BoxDecoration(
                                color: profile.online ? Colors.green : colors.outlineVariant,
                                shape: BoxShape.circle,
                                border: Border.all(color: colors.surface, width: 3),
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 16),
                      Text(profile.fullName, style: textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold)),
                      Text(
                        '@${profile.username}',
                        style: textTheme.bodyLarge?.copyWith(color: colors.onSurfaceVariant),
                      ),
                      if (profile.bio != null && profile.bio!.isNotEmpty)
                        Padding(
                          padding: const EdgeInsets.fromLTRB(32, 16, 32, 0),
                          child: Text(
                            profile.bio!,
                            textAlign: TextAlign.center,
                            style: textTheme.bodyMedium?.copyWith(color: colors.onSurface, height: 1.5),
                          ),
                        ),
                    ],
                  ),
                ),

                const SizedBox(height: 20),
                const ProfileSectionLabel(title: 'Personal Info'),
                ProfileSectionCard(
                  children: [
                    ProfileInfoTile(
                      icon: FontAwesomeIcons.envelope,
                      label: 'Email',
                      value: profile.email,
                      isVerified: profile.emailVerified,
                      onTap: () {
                        Clipboard.setData(ClipboardData(text: profile.email));
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: const Text('Email copied to clipboard'),
                            duration: const Duration(seconds: 2),
                            behavior: SnackBarBehavior.floating,
                            margin: const EdgeInsets.all(16),
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                        );
                      },
                    ),
                    if (profile.phone != null)
                      ProfileInfoTile(
                        icon: FontAwesomeIcons.phone,
                        label: 'Phone',
                        value: profile.phone!,
                        onTap: () {
                          Clipboard.setData(ClipboardData(text: profile.phone!));
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: const Text('Phone number copied to clipboard'),
                              duration: const Duration(seconds: 2),
                              behavior: SnackBarBehavior.floating,
                              margin: const EdgeInsets.all(16),
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                            ),
                          );
                        },
                      ),
                    if (profile.gender != null)
                      ProfileInfoTile(icon: FontAwesomeIcons.venusMars, label: 'Gender', value: profile.gender!.label),
                    if (profile.dateOfBirth != null)
                      ProfileInfoTile(
                        icon: FontAwesomeIcons.cakeCandles,
                        label: 'Birthday',
                        value: DateFormat('dd MMM, yyyy').format(profile.dateOfBirth!),
                      ),
                    if (profile.location != null)
                      ProfileInfoTile(icon: FontAwesomeIcons.locationDot, label: 'Location', value: profile.location!),
                  ],
                ),

                const SizedBox(height: 24),

                const ProfileSectionLabel(title: 'Settings'),
                ProfileSectionCard(
                  children: [
                    ProfileInfoTile(
                      icon: FontAwesomeIcons.lock,
                      label: 'Privacy',
                      value: profile.profileVisibility?.label ?? 'Public',
                      showArrow: false,
                    ),
                    ProfileNavigationTile(
                      icon: FontAwesomeIcons.rightFromBracket,
                      iconColor: colors.error,
                      label: 'Logout',
                      showArrow: false,
                      onTap: () => _showLogoutBottomSheet(context, ref, colors, textTheme),
                    ),
                  ],
                ),
                const SizedBox(height: 40),
              ],
            ),
          ),
        ),
      ),
    );
  }
  void _showLogoutBottomSheet(BuildContext context, WidgetRef ref, ColorScheme colors, TextTheme textTheme) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        contentPadding: const EdgeInsets.all(24),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(color: colors.errorContainer, shape: BoxShape.circle),
              child: Icon(FontAwesomeIcons.rightFromBracket, color: colors.error, size: 32),
            ),
            const SizedBox(height: 20),
            Text('Logout', style: textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold)),
            const SizedBox(height: 12),
            Text(
              'Are you sure you want to logout from your account?',
              textAlign: TextAlign.center,
              style: textTheme.bodyMedium?.copyWith(color: colors.onSurfaceVariant, height: 1.4),
            ),
            const SizedBox(height: 24),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () => Navigator.pop(context),
                    style: OutlinedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 14),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                      side: BorderSide(color: colors.outline, width: 1.5),
                    ),
                    child: const Text('Cancel', style: TextStyle(fontSize: 15, fontWeight: FontWeight.w600)),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: FilledButton(
                    onPressed: () async {
                      Navigator.pop(context); // Close dialog
                      showDialog(
                        context: context,
                        barrierDismissible: false,
                        builder: (context) => const Center(child: CircularProgressIndicator()),
                      );

                      await ref.read(authNotifierProvider.notifier).logout();

                      if (context.mounted) {
                        Navigator.pop(context); // Close loading
                        context.go('/login');
                      }
                    },
                    style: FilledButton.styleFrom(
                      backgroundColor: colors.error,
                      padding: const EdgeInsets.symmetric(vertical: 14),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                    ),
                    child: const Text('Logout', style: TextStyle(fontSize: 15, fontWeight: FontWeight.w600)),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

================================================================
FILE: lib/features/profile/presentation/pages/settings_page.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/enums.dart';
import 'package:flutter/material.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';
import 'package:go_router/go_router.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../widgets/profile_shared_components.dart';
class ThemeModeNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void toggle() => state = !state;

  void set(bool value) => state = value;
}

class NotificationNotifier extends Notifier<bool> {
  @override
  bool build() => true;

  void toggle() => state = !state;

  void set(bool value) => state = value;
}

class VisibilityNotifier extends Notifier<ProfileVisibility> {
  @override
  ProfileVisibility build() => ProfileVisibility.public;

  void set(ProfileVisibility value) => state = value;
}

class LanguageNotifier extends Notifier<String> {
  @override
  String build() => 'English';

  void set(String value) => state = value;
}
final themeModeProvider = NotifierProvider<ThemeModeNotifier, bool>(() {
  return ThemeModeNotifier();
});

final notificationProvider = NotifierProvider<NotificationNotifier, bool>(() {
  return NotificationNotifier();
});

final visibilityProvider = NotifierProvider<VisibilityNotifier, ProfileVisibility>(() {
  return VisibilityNotifier();
});

final languageProvider = NotifierProvider<LanguageNotifier, String>(() {
  return LanguageNotifier();
});

class SettingsPage extends ConsumerWidget {
  const SettingsPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final colors = Theme.of(context).colorScheme;
    final isDarkMode = ref.watch(themeModeProvider);
    final isNotifEnabled = ref.watch(notificationProvider);
    final currentVisibility = ref.watch(visibilityProvider);
    final currentLanguage = ref.watch(languageProvider);

    return Scaffold(
      backgroundColor: colors.surfaceContainerLow,
      appBar: AppBar(
        title: const Text('Settings', style: TextStyle(fontWeight: FontWeight.w600)),
        centerTitle: true,
        backgroundColor: colors.surface,
        surfaceTintColor: Colors.transparent,
        elevation: 0.5,
        shadowColor: Colors.black.withValues(alpha: 0.1),
        scrolledUnderElevation: 0.5,
        leading: IconButton(icon: const Icon(Icons.arrow_back), onPressed: () => context.pop()),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.symmetric(vertical: 20),
        child: Column(
          children: [
            const ProfileSectionLabel(title: 'General'),
            ProfileSectionCard(
              children: [
                ProfileToggleTile(
                  icon: isDarkMode ? FontAwesomeIcons.moon : FontAwesomeIcons.sun,
                  iconColor: Colors.orange,
                  label: 'Dark Mode',
                  value: isDarkMode,
                  onChanged: (val) => ref.read(themeModeProvider.notifier).set(val),
                ),
                ProfileToggleTile(
                  icon: FontAwesomeIcons.bell,
                  iconColor: Colors.purple,
                  label: 'Notifications',
                  value: isNotifEnabled,
                  onChanged: (val) => ref.read(notificationProvider.notifier).set(val),
                ),
                ProfileNavigationTile(
                  icon: FontAwesomeIcons.globe,
                  iconColor: Colors.blue,
                  label: 'Language',
                  valueLabel: currentLanguage,
                  onTap: () => _showLanguagePicker(context, ref, currentLanguage),
                ),
              ],
            ),
            const SizedBox(height: 24),
            const ProfileSectionLabel(title: 'Privacy'),
            ProfileSectionCard(
              children: [
                ProfileNavigationTile(
                  icon: FontAwesomeIcons.eye,
                  iconColor: Colors.teal,
                  label: 'Profile Visibility',
                  valueLabel: currentVisibility.label,
                  onTap: () => _showVisibilityPicker(context, ref, currentVisibility),
                ),
                ProfileNavigationTile(
                  icon: FontAwesomeIcons.userShield,
                  iconColor: Colors.indigo,
                  label: 'Blocked Users',
                  onTap: () {},
                ),
              ],
            ),
            const SizedBox(height: 24),
            const ProfileSectionLabel(title: 'Account & Security'),
            ProfileSectionCard(
              children: [
                ProfileNavigationTile(
                  icon: FontAwesomeIcons.key,
                  iconColor: colors.primary,
                  label: 'Change Password',
                  onTap: () => _showChangePasswordDialog(context),
                ),
                ProfileNavigationTile(
                  icon: FontAwesomeIcons.trashCan,
                  iconColor: colors.error,
                  label: 'Delete Account',
                  onTap: () => _showDeleteConfirmDialog(context, colors),
                ),
              ],
            ),

            const SizedBox(height: 24),
          ],
        ),
      ),
    );
  }
  void _showLanguagePicker(BuildContext context, WidgetRef ref, String current) {
    final languages = ['English', 'Vietnamese', 'Spanish', 'French'];

    showModalBottomSheet(
      context: context,
      backgroundColor: Theme.of(context).colorScheme.surface,
      showDragHandle: true,
      builder: (context) {
        return SafeArea(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text('Select Language', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
              const SizedBox(height: 10),
              ...languages.map(
                (lang) => ListTile(
                  leading: lang == current ? const Icon(Icons.check, color: Colors.blue) : const SizedBox(width: 24),
                  title: Text(lang),
                  onTap: () {
                    ref.read(languageProvider.notifier).set(lang);
                    Navigator.pop(context);
                  },
                ),
              ),
              const SizedBox(height: 10),
            ],
          ),
        );
      },
    );
  }
  void _showVisibilityPicker(BuildContext context, WidgetRef ref, ProfileVisibility current) {
    showModalBottomSheet(
      context: context,
      backgroundColor: Theme.of(context).colorScheme.surface,
      showDragHandle: true,
      builder: (context) {
        return SafeArea(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text('Who can see your profile?', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
              const SizedBox(height: 10),
              ...ProfileVisibility.values.map(
                (visibility) => ListTile(
                  leading: Icon(
                    visibility == current ? Icons.radio_button_checked : Icons.radio_button_off,
                    color: visibility == current ? Theme.of(context).colorScheme.primary : Colors.grey,
                  ),
                  title: Text(visibility.label),
                  onTap: () {
                    ref.read(visibilityProvider.notifier).set(visibility);
                    Navigator.pop(context);
                  },
                ),
              ),
              const SizedBox(height: 10),
            ],
          ),
        );
      },
    );
  }
  void _showChangePasswordDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Change Password'),
        content: const Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(decoration: InputDecoration(labelText: 'Current Password')),
            TextField(decoration: InputDecoration(labelText: 'New Password')),
            TextField(decoration: InputDecoration(labelText: 'Confirm New Password')),
          ],
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
          FilledButton(onPressed: () => Navigator.pop(context), child: const Text('Update')),
        ],
      ),
    );
  }
  void _showDeleteConfirmDialog(BuildContext context, ColorScheme colors) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Account?'),
        content: const Text('This action cannot be undone.'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Cancel')),
          FilledButton(
            style: FilledButton.styleFrom(backgroundColor: colors.error),
            onPressed: () => Navigator.pop(context),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }
}

================================================================
FILE: lib/features/profile/presentation/providers/profile_providers.dart
================================================================
import 'dart:io';

import 'package:chattrix_ui/core/errors/failures.dart';
import 'package:chattrix_ui/features/auth/presentation/providers/auth_providers.dart';
import 'package:chattrix_ui/features/chat/services/cloudinary_provider.dart';
import 'package:chattrix_ui/features/profile/data/datasources/profile_remote_datasource_impl.dart';
import 'package:chattrix_ui/features/profile/data/repositories/profile_repository_impl.dart';
import 'package:chattrix_ui/features/profile/domain/datasources/profile_remote_datasource.dart';
import 'package:chattrix_ui/features/profile/domain/entities/profile.dart';
import 'package:chattrix_ui/features/profile/domain/entities/update_profile_params.dart';
import 'package:chattrix_ui/features/profile/domain/repositories/profile_repository.dart';
import 'package:chattrix_ui/features/profile/domain/usecases/get_profile_usecase.dart';
import 'package:chattrix_ui/features/profile/domain/usecases/update_profile_usecase.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'profile_providers.g.dart';

@riverpod
ProfileRemoteDataSource profileRemoteDataSource(Ref ref) {
  return ProfileRemoteDataSourceImpl(dio: ref.watch(dioProvider));
}

@riverpod
ProfileRepository profileRepository(Ref ref) {
  return ProfileRepositoryImpl(ref.watch(profileRemoteDataSourceProvider) as ProfileRemoteDataSourceImpl);
}

@riverpod
GetProfileUseCase getProfileUseCase(Ref ref) {
  return GetProfileUseCase(ref.watch(profileRepositoryProvider));
}

@riverpod
UpdateProfileUseCase updateProfileUseCase(Ref ref) {
  return UpdateProfileUseCase(ref.watch(profileRepositoryProvider));
}

@riverpod
class ProfileController extends _$ProfileController {
  @override
  FutureOr<Profile> build() async {
    return _fetchProfile();
  }

  Future<Profile> _fetchProfile() async {
    final useCase = ref.read(getProfileUseCaseProvider);
    final result = await useCase();

    return result.fold((failure) => throw _mapFailureToException(failure), (profile) => profile);
  }

  Future<void> updateProfile({required UpdateProfileParams params, File? newAvatarFile}) async {
    state = const AsyncValue.loading();

    state = await AsyncValue.guard(() async {
      String? avatarUrl = params.avatarUrl;

      if (newAvatarFile != null) {
        final cloudinaryService = ref.read(cloudinaryServiceProvider);
        final uploadResult = await cloudinaryService.uploadImage(newAvatarFile);
        avatarUrl = uploadResult.url;
      }

      final updatedParams = params.copyWith(avatarUrl: avatarUrl);
      final updateUseCase = ref.read(updateProfileUseCaseProvider);
      final result = await updateUseCase(updatedParams);

      return result.fold((failure) => throw _mapFailureToException(failure), (newProfile) => newProfile);
    });
  }
  Exception _mapFailureToException(Failure failure) {
    return failure.when(
      server: (message, code, requestId) => ServerException(message, code),
      network: (message, code) => NetworkException(message),
      validation: (message, code, details, requestId) => ValidationException(message, details),
      auth: (message, code, requestId) => AuthException(message, code),
      notFound: (message, code, requestId) => NotFoundException(message, code),
      conflict: (message, code, requestId) => ConflictException(message, code),
      rateLimit: (message, code, requestId) => RateLimitException(message),
    );
  }
}
class ServerException implements Exception {
  final String message;
  final String? code;
  ServerException(this.message, [this.code]);

  @override
  String toString() => message;
}

class NetworkException implements Exception {
  final String message;
  NetworkException(this.message);

  @override
  String toString() => message;
}

class ValidationException implements Exception {
  final String message;
  final Map<String, String>? details;
  ValidationException(this.message, [this.details]);

  @override
  String toString() {
    if (details != null && details!.isNotEmpty) {
      return details!.values.join(', ');
    }
    return message;
  }
}

class AuthException implements Exception {
  final String message;
  final String? code;
  AuthException(this.message, [this.code]);

  @override
  String toString() => message;
}

class NotFoundException implements Exception {
  final String message;
  final String? code;
  NotFoundException(this.message, [this.code]);

  @override
  String toString() => message;
}

class ConflictException implements Exception {
  final String message;
  final String? code;
  ConflictException(this.message, [this.code]);

  @override
  String toString() => message;
}

class RateLimitException implements Exception {
  final String message;
  RateLimitException(this.message);

  @override
  String toString() => message;
}

================================================================
FILE: lib/features/profile/presentation/widgets/profile_picker_widgets.dart
================================================================
import 'package:chattrix_ui/core/domain/enums/enums.dart';
import 'package:flutter/material.dart';

class PickerOption extends StatelessWidget {
  final IconData icon;
  final String label;
  final VoidCallback onTap;

  const PickerOption({super.key, required this.icon, required this.label, required this.onTap});

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(16),
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
        decoration: BoxDecoration(
          color: colors.surfaceContainerHighest.withValues(alpha: 0.3),
          borderRadius: BorderRadius.circular(16),
        ),
        child: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(color: colors.primary.withValues(alpha: 0.1), shape: BoxShape.circle),
              child: Icon(icon, color: colors.primary, size: 20),
            ),
            const SizedBox(width: 16),
            Text(
              label,
              style: TextStyle(fontWeight: FontWeight.w600, fontSize: 16, color: colors.onSurface),
            ),
          ],
        ),
      ),
    );
  }
}

class GenderOption extends StatelessWidget {
  final Gender gender;
  final Gender? selectedGender;
  final Function(Gender) onSelect;

  const GenderOption({super.key, required this.gender, required this.selectedGender, required this.onSelect});

  @override
  Widget build(BuildContext context) {
    final isSelected = selectedGender == gender;
    final colors = Theme.of(context).colorScheme;
    return ListTile(
      leading: Icon(
        isSelected ? Icons.radio_button_checked : Icons.radio_button_off,
        color: isSelected ? colors.primary : colors.onSurfaceVariant,
      ),
      title: Text(gender.label),
      onTap: () => onSelect(gender),
    );
  }
}

================================================================
FILE: lib/features/profile/presentation/widgets/profile_shared_components.dart
================================================================
import 'package:flutter/material.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';

class ProfileSectionLabel extends StatelessWidget {
  final String title;

  const ProfileSectionLabel({super.key, required this.title});

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    return Padding(
      padding: const EdgeInsets.fromLTRB(24, 0, 24, 8),
      child: Align(
        alignment: Alignment.centerLeft,
        child: Text(
          title.toUpperCase(),
          style: TextStyle(
            color: colors.onSurfaceVariant,
            fontSize: 12,
            fontWeight: FontWeight.bold,
            letterSpacing: 1.0,
          ),
        ),
      ),
    );
  }
}

class ProfileSectionCard extends StatelessWidget {
  final List<Widget> children;

  const ProfileSectionCard({super.key, required this.children});

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(color: colors.surface, borderRadius: BorderRadius.circular(16)),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(16),
        child: Column(children: children),
      ),
    );
  }
}

enum ProfileTileType { navigation, toggle, info }

class ProfileTile extends StatelessWidget {
  final IconData icon;
  final Color? iconColor;
  final String label;
  final String? value;
  final Color? textColor;
  final ProfileTileType type;

  final bool switchValue;
  final ValueChanged<bool>? onChanged;

  final VoidCallback? onTap;
  final bool showArrow;
  final bool isVerified;
  final bool isDestructive;

  const ProfileTile({
    super.key,
    required this.icon,
    this.iconColor,
    required this.label,
    this.value,
    this.textColor,
    this.type = ProfileTileType.navigation,
    this.switchValue = false,
    this.onChanged,
    this.onTap,
    this.showArrow = true,
    this.isVerified = false,
    this.isDestructive = false,
  });

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    final effectiveIconColor = isDestructive ? colors.error : (iconColor ?? colors.primary);

    final effectiveTextColor = isDestructive ? colors.error : (textColor ?? colors.onSurface);

    return InkWell(
      onTap: type == ProfileTileType.toggle ? () => onChanged?.call(!switchValue) : onTap,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: effectiveIconColor.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(8),
              ),
              child: FaIcon(icon, size: 16, color: effectiveIconColor),
            ),
            const SizedBox(width: 16),

            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  if (value != null && value!.isNotEmpty) ...[
                    Text(label, style: textTheme.bodySmall?.copyWith(color: colors.onSurfaceVariant)),
                    const SizedBox(height: 2),
                    Row(
                      children: [
                        Flexible(
                          child: Text(
                            value!,
                            style: textTheme.bodyMedium?.copyWith(
                              color: effectiveTextColor,
                              fontWeight: FontWeight.w600,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        if (isVerified) ...[
                          const SizedBox(width: 6),
                          const Icon(Icons.verified, color: Colors.blue, size: 16),
                        ],
                      ],
                    ),
                  ] else
                    Text(
                      label,
                      style: textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.w500, color: effectiveTextColor),
                    ),
                ],
              ),
            ),

            if (type == ProfileTileType.toggle)
              Switch(
                value: switchValue,
                activeThumbColor: Colors.white,
                activeTrackColor: colors.primary,
                inactiveThumbColor: Colors.white,
                inactiveTrackColor: colors.outlineVariant,
                trackOutlineColor: WidgetStateProperty.all(Colors.transparent),
                trackOutlineWidth: WidgetStateProperty.all(0),
                onChanged: onChanged,
              )
            else ...[
              if (value != null && value!.isNotEmpty && type == ProfileTileType.navigation)
                Padding(
                  padding: const EdgeInsets.only(right: 8.0),
                  child: Text(
                    value!,
                    style: textTheme.bodySmall?.copyWith(color: colors.primary, fontWeight: FontWeight.bold),
                  ),
                ),
              if (showArrow) Icon(Icons.chevron_right, size: 20, color: colors.outlineVariant),
            ],
          ],
        ),
      ),
    );
  }
}

class ProfileInfoTile extends StatelessWidget {
  final IconData icon;
  final String label;
  final String value;
  final bool isVerified;
  final bool isDestructive;
  final bool showArrow;
  final VoidCallback? onTap;

  const ProfileInfoTile({
    super.key,
    required this.icon,
    required this.label,
    required this.value,
    this.isVerified = false,
    this.isDestructive = false,
    this.showArrow = false,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return ProfileTile(
      icon: icon,
      label: label,
      value: value,
      type: ProfileTileType.info,
      isVerified: isVerified,
      isDestructive: isDestructive,
      showArrow: showArrow,
      onTap: onTap,
    );
  }
}

class ProfileNavigationTile extends StatelessWidget {
  final IconData icon;
  final Color? iconColor;
  final String label;
  final String? valueLabel;
  final VoidCallback onTap;
  final bool showArrow;

  const ProfileNavigationTile({
    super.key,
    required this.icon,
    this.iconColor,
    required this.label,
    this.valueLabel,
    required this.onTap,
    this.showArrow = true,
  });

  @override
  Widget build(BuildContext context) {
    return ProfileTile(
      icon: icon,
      iconColor: iconColor,
      label: label,
      value: valueLabel,
      type: ProfileTileType.navigation,
      showArrow: showArrow,
      onTap: onTap,
    );
  }
}

class ProfileToggleTile extends StatelessWidget {
  final IconData icon;
  final Color? iconColor;
  final String label;
  final bool value;
  final ValueChanged<bool> onChanged;

  const ProfileToggleTile({
    super.key,
    required this.icon,
    this.iconColor,
    required this.label,
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return ProfileTile(
      icon: icon,
      iconColor: iconColor,
      label: label,
      type: ProfileTileType.toggle,
      switchValue: value,
      onChanged: onChanged,
      showArrow: false,
    );
  }
}

class ProfileDivider extends StatelessWidget {
  const ProfileDivider({super.key});

  @override
  Widget build(BuildContext context) {
    return Divider(
      height: 1,
      thickness: 1,
      indent: 56,
      color: Theme.of(context).colorScheme.outlineVariant.withValues(alpha: 0.3),
    );
  }
}

List<Widget> buildProfileItems(List<Widget> items) {
  if (items.isEmpty) return [];

  final result = <Widget>[];
  for (int i = 0; i < items.length; i++) {
    result.add(items[i]);
    if (i < items.length - 1) {
      result.add(const ProfileDivider());
    }
  }
  return result;
}

================================================================
FILE: lib/features/profile/presentation/widgets/profile_ui_components.dart
================================================================
import 'package:flutter/material.dart';
export 'profile_shared_components.dart';
import 'profile_shared_components.dart';
typedef SectionHeader = ProfileSectionLabel;
typedef MenuCard = ProfileSectionCard;
class ProfileMenuItem extends StatelessWidget {
  final String label;
  final String value;
  final IconData icon;
  final bool isVerified;
  final VoidCallback onTap;

  const ProfileMenuItem({
    super.key,
    required this.label,
    required this.value,
    required this.icon,
    this.isVerified = false,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return ProfileInfoTile(
      icon: icon,
      label: label,
      value: value,
      isVerified: isVerified,
      showArrow: true,
      onTap: onTap,
    );
  }
}

================================================================
FILE: lib/features/profile/presentation/widgets/single_field_editor.dart
================================================================
import 'package:flutter/material.dart';

class SingleFieldEditor extends StatefulWidget {
  final String title;
  final String label;
  final String initialValue;
  final int maxLength;
  final int maxLines;
  final TextInputType inputType;
  final String? helperText;
  final Function(String) onSave;

  const SingleFieldEditor({
    super.key,
    required this.title,
    required this.label,
    required this.initialValue,
    required this.maxLength,
    required this.onSave,
    this.maxLines = 1,
    this.inputType = TextInputType.text,
    this.helperText,
  });

  @override
  State<SingleFieldEditor> createState() => _SingleFieldEditorState();
}

class _SingleFieldEditorState extends State<SingleFieldEditor> {
  late TextEditingController _controller;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.initialValue);
  }

  void _save() {
    widget.onSave(_controller.text.trim());
    Navigator.pop(context);
  }

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    return Scaffold(
      backgroundColor: colors.surface,
      appBar: AppBar(
        title: Text(widget.title),
        centerTitle: true,
        actions: [
          TextButton(
            onPressed: _save,
            child: Text(
              'Done',
              style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16, color: colors.primary),
            ),
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(widget.label, style: TextStyle(color: colors.onSurfaceVariant, fontSize: 13)),
            const SizedBox(height: 8),
            TextFormField(
              controller: _controller,
              autofocus: true,
              maxLength: widget.maxLength,
              maxLines: widget.maxLines,
              keyboardType: widget.inputType,
              style: const TextStyle(fontSize: 16),
              decoration: InputDecoration(
                filled: true,
                fillColor: colors.surfaceContainerHighest.withValues(alpha: 0.3),
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide.none),
                contentPadding: const EdgeInsets.all(16),
                suffixIcon: IconButton(icon: const Icon(Icons.clear, size: 20), onPressed: () => _controller.clear()),
                helperText: widget.helperText,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

================================================================
FILE: lib/main.dart
================================================================
import 'package:chattrix_ui/core/utils/riverpod_logger.dart';
import 'package:flutter/material.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

import 'core/router/app_router.dart';
import 'core/theme/app_theme.dart';
import 'core/toast/toast_overlay.dart';
import 'features/call/presentation/state/call_notifier.dart';
import 'features/chat/presentation/providers/chat_websocket_provider_new.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await dotenv.load(fileName: ".env");
  runApp(ProviderScope(observers: [RiverpodLogger()], child: const MyApp()));
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.watch(webSocketConnectionProvider);
    ref.watch(callProvider);

    return MaterialApp.router(
      title: 'Chattrix',
      debugShowCheckedModeBanner: false,
      showPerformanceOverlay: false,
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: ThemeMode.light,
      builder: (context, child) => ToastOverlay(child: child ?? const SizedBox.shrink()),
      routerConfig: AppRouter.router(ref),
    );
  }
}

================================================================
FILE: lib/main_preview.dart
================================================================
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';

void main() {
  runApp(const AvatarStoryPreviewApp());
}

class AvatarStoryPreviewApp extends StatelessWidget {
  const AvatarStoryPreviewApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Messenger Note Style',
      themeMode: ThemeMode.light,
      theme: ThemeData.light().copyWith(
        scaffoldBackgroundColor: Colors.white,
        colorScheme: const ColorScheme.light(primary: Color(0xFF0084FF)),
      ),
      home: const ExampleWidget(),
    );
  }
}

class ExampleWidget extends HookWidget {
  const ExampleWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final count = useState(0);
    final renderCount = useRef(0);
    renderCount.value++;
    print("ƒê√£ render l·∫ßn th·ª©: ${renderCount.value}");

    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text("S·ªë hi·ªÉn th·ªã: ${count.value}", style: TextStyle(fontSize: 24)),

            SizedBox(height: 20),

            ElevatedButton(
              onPressed: () {
                count.value++;
              },
              child: Text("TƒÉng s·ªë (Rebuild)"),
            ),

            ElevatedButton(
              onPressed: () {
                renderCount.value = 0;
                print("ƒê√£ reset bi·∫øn ng·∫ßm v·ªÅ 0");
              },
              child: Text("Reset Ref (Kh√¥ng Rebuild)"),
            ),
          ],
        ),
      ),
    );
  }
}

